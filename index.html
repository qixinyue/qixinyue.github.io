<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本站主要提供python教学的系列知识汇总">
<meta property="og:type" content="website">
<meta property="og:title" content="响神的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="响神的博客">
<meta property="og:description" content="本站主要提供python教学的系列知识汇总">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="响神的博客">
<meta name="twitter:description" content="本站主要提供python教学的系列知识汇总">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>响神的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">响神的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">python入门到精通</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/julia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/julia/" itemprop="url">Julia知识详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T19:05:04+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Julia</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,347 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>编程界的新宠Julia发布1.0正式版本，多种优势集于一身</p>
<p>源编程语言 Julia 迎来 1.0 正式版本。在 8 月 9 日的于伦敦举行的 JuliaCon 2018 会议上，Julia1.0 版本正式发布，这对 Julia 来说是自 2012 年 2 月公司成立以来最重要的时刻。Julia 是一种面向科学、数值计算的简单、高效的开源编程语言。而此次发布的Julia 1.0 是第一个完善、稳定和向前兼容的 Julia 版本。Julia 的联合创始人 Jeff Bezanson，Stefan Karpinski，Viral Shah 和 Alan Edelman 在会上对新版本进行了介绍。从问世至今的六年半时间里，Julia 的累积下载次数超过 200 万，已被应用于自动驾驶汽车、机器人、3D 打印、精准医疗、增强现实、基因组学、能源交易、机器学习、金融风控和太空任务设计等多个领域。此次 Julia 1.0 版本的发布，更是将商业用户越来越看重的稳定性与原有的快速、高生产力的特性结合起来，足以媲美 Python，R，C++和 Java 等编程语言。众多来自科技、咨询和金融等行业的公司都有采用 Julia 语言并雇佣 Julia 开发人员，其中包括：亚马逊、苹果、贝莱德集团、博思艾伦咨询公司、Capital One、康卡斯特、迪斯尼、安永、脸书、美国联邦航空管理局、纽约联储银行、福特、谷歌、IBM、英特尔、毕马威、微软、NASA、甲骨文、普华永道和优步。除了商业公司，目前还有超过 700 所大学、研究机构和实验室使用 Julia，其中不乏 MIT、哈佛、加州理工、劳伦斯·伯克利国家实验室、橡树岭国家实验室等知名大学和实验室。Julia 社区已有超过 700 名贡献者，开发了超过 1900 个扩展包。截至目前，Julia 已被下载超过 200 多万次，在 GitHub 上获得超过 41000 个星星，下载量年增长率超过 101%。Julia 兼具 Python 和 R 等高级语言的易用性和 C++的运行速度。它是目前唯一经过千万亿次量级计算考验的高级编程语言。在世界排名第 6 的超级计算机上，Julia 在 9300 个英特尔 Knights Landing (KNL) 计算节点上调用 65 万个核与 130 万个线程，对 1.88 亿个天体进行编目，仅耗时 14.6 分钟。外在金融风控模型和天文学图像分析等应用领域，Julia 对速度和性能的提升可达到 1000 倍以上。不论是在笔记本电脑还是在超级计算机上，不管采用 1 个还是数千个具备多线程、GPU 和并行计算能力的节点，Julia 均可保持出色的表现。对美国联邦航空管理局的飞机防撞系统（Aircraft Collision Avoidance System (ACAS-X)）、贝莱德集团的阿拉丁分析平台（Aladdin analytics platform）和纽约联储银行的动态随机通用平衡 (DSGE) 宏观经济学模型等项目，Julia 都被应用在其中且发挥了重要作用。</p>
<h1 id="julia环境的搭建"><a href="#julia环境的搭建" class="headerlink" title="julia环境的搭建"></a>julia环境的搭建</h1><p>1 在linux下执行sudo pip install julia,前提是pip是可以使用的</p>
<p>2 windows下到官网<a href="https://julialang.org/downloads/" target="_blank" rel="noopener">https://julialang.org/downloads/</a> 进行下载</p>
<p>3 进行测试环境是否ok</p>
<pre><code>linux下命令行输入julia,出现如下界面则表示安装成功
桌面/$ julia
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)
 _/ |\__&apos;_|_|_|\__&apos;_|  |  Official https://julialang.org/ release
|__/                   |


julia&gt; 
</code></pre><p>4 第一行julia代码运行</p>
<pre><code>julia&gt; print(&apos;hello julia&apos;)
ERROR: syntax: invalid character literal

julia&gt; print(&quot;hello julia&quot;)
hello julia
julia&gt; print(&apos;a&apos;)
a
在这里需要注意的是julia对单引号&apos;&apos;的操作不能像python一样，而是和c语言的char现象一致
</code></pre><p>5 第一个jl文件的运行</p>
<pre><code>新建一个名为hello.jl的文件，在里面写一段代码：
println(&quot;hello julia in .jl file&quot;)

在控制台进行运行，结果如下
/桌面/julia$ julia hello.jl 
hello julia in .jl file
</code></pre><p>6 将执行指令写入并保存到.jl文件中，如下指令</p>
<pre><code>/桌面/julia$ julia -e &apos;println(&quot;hello julia&quot;); for x in ARGS; println(x); end&apos; foo bar
hello julia
foo
bar

echo &apos;println(PROGRAM_FILE); for x in ARGS; println(x); end&apos; &gt; script.jl

然后在控制台运行 
julia script.jl foo bar
</code></pre><p>7 julia运行程序的表达式</p>
<p>表达式： julia [switches] – [programfile] [args…]</p>
<table>
<thead>
<tr>
<th>开关</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v， –version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-h， –help</td>
<td>打印此邮件</td>
</tr>
<tr>
<td>-J， –sysimage <file></file></td>
<td>启动给定的系统映像文件</td>
</tr>
<tr>
<td>-H， –home <dir></dir></td>
<td>设置julia可执行文件的位置</td>
</tr>
<tr>
<td>–startup-file={yes/no}</td>
<td>加载 ~/.julia/config/startup.jl</td>
</tr>
<tr>
<td>–handle-signals={yes/no}</td>
<td>启用或禁用Julia的默认信号处理程序</td>
</tr>
<tr>
<td>–sysimage-native-code={yes/no}</td>
<td>如果可用，请使用系统映像中的本机代码</td>
</tr>
<tr>
<td>–compiled-modules={yes/no}</td>
<td>启用或禁用模块的增量预编译</td>
</tr>
<tr>
<td>-e， –eval <expr></expr></td>
<td>评估 <expr></expr></td>
</tr>
<tr>
<td>-E， –print <expr></expr></td>
<td>评估<expr>并显示结果</expr></td>
</tr>
<tr>
<td>-L， –load <file></file></td>
<td><file>立即加载所有处理器</file></td>
</tr>
<tr>
<td>-p，–procs {N/auto}</td>
<td>整数值N启动N个额外的本地工作进程; auto启动与本地CPU线程数（逻辑核心数）一样多的工作程序</td>
</tr>
<tr>
<td>–machine-file <file></file></td>
<td>在上面列出的主机上运行进程 <file></file></td>
</tr>
<tr>
<td>-i</td>
<td>互动模式; REPL运行并且isinteractive()是真的</td>
</tr>
<tr>
<td>-q， –quiet</td>
<td>安静的启动：没有横幅，抑制REPL警告</td>
</tr>
<tr>
<td>–banner={yes/no/auto}</td>
<td>启用或禁用启动横幅</td>
</tr>
<tr>
<td>–color={yes/no/auto}</td>
<td>启用或禁用彩色文本</td>
</tr>
<tr>
<td>–history-file={yes/no}</td>
<td>加载或保存历史记录</td>
</tr>
<tr>
<td>–depwarn={yes/no/error}</td>
<td>启用或禁用语法和方法弃用警告（error将警告转换为错误）</td>
</tr>
<tr>
<td>–warn-overwrite={yes/no}</td>
<td>启用或禁用方法覆盖警告</td>
</tr>
<tr>
<td>-C， –cpu-target <target></target></td>
<td>限制cpu功能的使用，最高为<target>; 设置为help查看可用选项</target></td>
</tr>
<tr>
<td>-O， –optimize={0,1,2,3}</td>
<td>设置优化级别（如果未指定，则默认级别为2;如果不使用级别，则默认级别为3）</td>
</tr>
<tr>
<td>-g， -g <level></level></td>
<td>启用/设置调试信息生成的级别（如果未指定，则默认级别为1;如果不使用级别，则默认级别为2）</td>
</tr>
<tr>
<td>–inline={yes/no}</td>
<td>控制是否允许内联，包括覆盖@inline声明</td>
</tr>
<tr>
<td>–check-bounds={yes/no}</td>
<td>始终或从不发出边界检查（忽略声明）</td>
</tr>
<tr>
<td>–math-mode={ieee,fast}</td>
<td>禁止或启用不安全的浮点优化（覆盖@fastmath声明）</td>
</tr>
<tr>
<td>–code-coverage={none/user/all}</td>
<td>计算源代码行的执行次数</td>
</tr>
<tr>
<td>–code-coverage</td>
<td>相当于 –code-coverage=user</td>
</tr>
<tr>
<td>–track-allocation={none/user/all}</td>
<td>计算每个源行分配的字节数</td>
</tr>
<tr>
<td>–track-allocation</td>
<td>相当于 –track-allocation=user</td>
</tr>
</tbody>
</table>
<p>8 查看版本号</p>
<pre><code>julia&gt; VERSION
v&quot;1.0.0&quot;
</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Julia中的变量是与值相关联（或绑定）的名称，不需要事先声明变量的类型，而是根据赋值表达式生成对应类型的数据，用变量进行保存。<br>例如：</p>
<pre><code>julia&gt; x = 10
10
julia&gt; x+1
11
julia&gt; x = 1+2
3

julia&gt; x = &quot;hello julia&quot;
&quot;hello julia&quot;
</code></pre><p>在上面示例中，x是指向存储的常量10</p>
<h2 id="变量命名规则："><a href="#变量命名规则：" class="headerlink" title="变量命名规则："></a>变量命名规则：</h2><p>1 变量区分大小写，a 与 A不是一个对象<br>2 变量采用的utf-8编码<br>3 变量字符集合：数字字母下划线，其他等同于字母的符号，首字母不为数字<br>4 不能和系统关键字同名</p>
<h2 id="文体约定"><a href="#文体约定" class="headerlink" title="文体约定"></a>文体约定</h2><p>虽然Julia对有效名称的限制很少，但采用以下约定变得很有用：</p>
<ul>
<li>变量名称为小写。</li>
<li>可以用下划线（’_’）表示单词分隔，但不鼓励使用下划线，除非该名称很难以其他方式阅读。</li>
<li>Types和Modules的名称以大写字母开头，单词分隔用上面的驼峰表示而不是下划线。</li>
<li>functions和macros的名称是小写的，没有下划线。</li>
<li>写入其参数的函数具有以其结尾的名称!。这些函数有时被称为“变异”或“就地”函数，因为它们旨在在调用函数后生成其参数的更改，而不仅仅是返回值。</li>
</ul>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>以下是Julia的原始数字类型：</p>
<h3 id="整数类型："><a href="#整数类型：" class="headerlink" title="整数类型："></a><strong>整数类型：</strong></h3><table>
<thead>
<tr>
<th>类型</th>
<th>签？</th>
<th>位数</th>
<th>最小的价值</th>
<th>最大的价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8</td>
<td>✓</td>
<td>8</td>
<td>-2 ^ 7</td>
<td>2 ^ 7 - 1</td>
</tr>
<tr>
<td>UInt8</td>
<td></td>
<td>8</td>
<td>0</td>
<td>2 ^ 8 - 1</td>
</tr>
<tr>
<td>Int16</td>
<td>✓</td>
<td>16</td>
<td>-2 ^ 15</td>
<td>2 ^ 15 - 1</td>
</tr>
<tr>
<td>UInt16</td>
<td></td>
<td>16</td>
<td>0</td>
<td>2 ^ 16 - 1</td>
</tr>
<tr>
<td>Int32</td>
<td>✓</td>
<td>32</td>
<td>-2 ^ 31</td>
<td>2 ^ 31 - 1</td>
</tr>
<tr>
<td>UInt32</td>
<td></td>
<td>32</td>
<td>0</td>
<td>2 ^ 32 - 1</td>
</tr>
<tr>
<td>Int64</td>
<td>✓</td>
<td>64</td>
<td>-2 ^ 63</td>
<td>2 ^ 63 - 1</td>
</tr>
<tr>
<td>UInt64</td>
<td></td>
<td>64</td>
<td>0</td>
<td>2 ^ 64 - 1</td>
</tr>
<tr>
<td>Int128</td>
<td>✓</td>
<td>128</td>
<td>-2 ^ 127</td>
<td>2 ^ 127 - 1</td>
</tr>
<tr>
<td>UInt128</td>
<td></td>
<td>128</td>
<td>0</td>
<td>2 ^ 128 - 1</td>
</tr>
<tr>
<td>Bool</td>
<td>N / A</td>
<td>8</td>
<td>false （0）</td>
<td>true （1）</td>
</tr>
</tbody>
</table>
<h3 id="浮点类型："><a href="#浮点类型：" class="headerlink" title="浮点类型："></a><strong>浮点类型：</strong></h3><table>
<thead>
<tr>
<th>类型</th>
<th>精确</th>
<th>位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float16</td>
<td>半</td>
<td>16</td>
</tr>
<tr>
<td>Float32</td>
<td>单</td>
<td>32</td>
</tr>
<tr>
<td>Float64</td>
<td>双</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>查看本机是32位还是64位</p>
<pre><code>julia&gt; typeof(1) 返回值为Int64则为64位，返回值为Int32 则为32位机
Int64
</code></pre><p>32位机无法表示的数字时会自动转换为Int64类型</p>
<h3 id="无符号整数使用0x前缀和十六进制（基数为16）数字"><a href="#无符号整数使用0x前缀和十六进制（基数为16）数字" class="headerlink" title="无符号整数使用0x前缀和十六进制（基数为16）数字"></a><strong>无符号整数使用0x前缀和十六进制（基数为16）数字</strong></h3><p>进行输入和输出0-9a-f（大写数字A-F也适用于输入）。无符号值的大小由使用的十六进制数字数决定：<br>(ans)是只在交互模式下才能使用的变量，保存的内容是上一个表达式的运算结果</p>
<pre><code>julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64

julia&gt; 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia&gt; typeof(ans)
UInt128
</code></pre><h3 id="还支持二进制和八进制文字："><a href="#还支持二进制和八进制文字：" class="headerlink" title="还支持二进制和八进制文字："></a><strong>还支持二进制和八进制文字：</strong></h3><pre><code>julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o010
0x08

julia&gt; typeof(ans)
UInt8

julia&gt; 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia&gt; typeof(ans)
UInt128
</code></pre><p>在二进制，八进制和十六进制前加-号表示取补码。它们产生一个与无符号文字相同大小的无符号整数</p>
<pre><code>julia&gt; -0x2
0xfe

julia&gt; -0x0002
0xfffe
</code></pre><h3 id="原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出："><a href="#原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出：" class="headerlink" title="原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出："></a>原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出：</h3><pre><code>julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println(&quot;$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]&quot;)
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
</code></pre><h3 id="溢出行为"><a href="#溢出行为" class="headerlink" title="溢出行为"></a>溢出行为</h3><p>在Julia中，超出给定类型的最大可表示值会导致环绕行为：</p>
<pre><code>julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true
</code></pre><h3 id="除法错误"><a href="#除法错误" class="headerlink" title="除法错误"></a>除法错误</h3><p>除法需要考虑除数为0的情况<br>1 一个非0数字除以0，得到Inf<br>2 0/0  -&gt; NaN<br>3 任意数对0求余数，报错<br>4 一个常规数字对Inf进行除法，得到的结果为0.0<br>5 一个常规数字对NaN除法，得到的结果还是NaN<br>6 Inf/Inf –&gt; Nan<br>7 0/Inf  –&gt; NaN</p>
<pre><code>julia&gt; 3%0
ERROR: DivideError: integer division error
 in rem at ./int.jl:80

julia&gt; 3/0
Inf

julia&gt; 0/0
NaN

julia&gt; 0%0
ERROR: DivideError: integer division error
 in rem at ./int.jl:80

julia&gt; x = 1/0
Inf

julia&gt; 2/x
0.0

julia&gt; x = 0/0
NaN

julia&gt; 2/x
NaN
</code></pre><h3 id="浮点数字"><a href="#浮点数字" class="headerlink" title="浮点数字"></a>浮点数字</h3><p>可以使用科学计数法 1.3e4 = 13000.0<br><strong>另外可以使用f替代e来实现科学计数法</strong> 0.5f2 = 50.0f0<br>还支持半精度浮点数（Float16），但它们在软件中实现并Float32用于计算。</p>
<pre><code>julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
Float16(8.0)
</code></pre><p><strong>下划线_可用作数字分隔符：</strong></p>
<pre><code>julia&gt; 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
</code></pre><p><strong>Machine epsilon</strong> (暂时不知道怎么翻译)<br>大多数实数不能用浮点数精确表示,所以需要一个精度来判断该值与表达式所写值得差值是否满足精度，满足则认为是正确表示的。</p>
<p>Julia提供eps，它给出了1.0到下一个更大的可表示浮点值之间的距离：</p>
<pre><code>julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() # same as eps(Float64)
2.220446049250313e-16
</code></pre><p>这个东西就像我们结帐的时候，都是以最低单位为分的，但是在实际过程中，都是以元为最低单位进行结算，但是分确实就是我国的最低结算单位，在银行等地方还是会用到的。</p>
<p>Julia还提供了<strong>nextfloat与prevfloat</strong>它们分别返回下一个最大或最小的可表示浮点数的参数功能：</p>
<pre><code>julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bitstring(prevfloat(x))
&quot;00111111100111111111111111111111&quot;

julia&gt; bitstring(x)
&quot;00111111101000000000000000000000&quot;

julia&gt; bitstring(nextfloat(x))
&quot;00111111101000000000000000000001&quot;
</code></pre><h3 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h3><p>如果数字没有精确的浮点表示，则必须将其四舍五入到适当的可表示值。但是，如果需要，可以根据IEEE 754标准中提出的舍入模式改变完成此舍入的方式。</p>
<p>使用的默认模式始终是RoundNearest，它舍入到最接近的可表示值，并使用最低有效位向最近的值四舍五入。</p>
<h3 id="任意精度算术"><a href="#任意精度算术" class="headerlink" title="任意精度算术"></a>任意精度算术</h3><p>为了允许使用任意精度整数和浮点数进行计算，Julia分别包装了GNU多精度算术库（GMP）和GNU MPFR库。Julia中的BigInt和BigFloat类型分别用于任意精度整数和浮点数。</p>
<p>存在构造函数以从原始数字类型创建这些类型，并且parse可以用于从AbstractStrings 构造它们。一旦创建，由于Julia的类型提升和转换机制，它们与所有其他数字类型一起参与算术运算：</p>
<pre><code>julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, &quot;123456789012345678901234567890&quot;) + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, &quot;1.23456789012345678901&quot;)
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000
</code></pre><p>但是，上述基本类型之间的类型提升和BigInt/ BigFloat不是自动的，必须明确说明。</p>
<pre><code>julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt
</code></pre><p>BigFloat可以通过调用setprecision和全局更改默认精度（有效数的位数）和舍入操作模式setrounding，并且所有进一步的计算将考虑这些更改。或者，通过使用与do块相同的函数，只能在特定代码块的执行中更改精度或舍入：</p>
<pre><code>julia&gt; setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.1000000000004
</code></pre><h3 id="数字文字系数-（此乃神器）"><a href="#数字文字系数-（此乃神器）" class="headerlink" title="数字文字系数 ###（此乃神器）"></a>数字文字系数 ###（此乃神器）</h3><p>为了使常见的数字公式和表达式更清晰，Julia允许变量紧跟数字文字，表示乘法。这使得写多项式表达式更加清晰：</p>
<pre><code>julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0
julia&gt; 4^2x
4096（备注：先计算的是2x后再计算的幂）
</code></pre><p>数字文字也可用作带括号的表达式的系数：</p>
<pre><code>julia&gt; 2(x-1)^2 - 3(x-1) + 1
3
</code></pre><p>另外，带括号的表达式可以用作变量的系数，意味着表达式乘以变量：</p>
<pre><code>julia&gt; (x-1)x
6
</code></pre><p><strong>但是</strong>，两个带括号的表达式的并置，也不能在括号表达式之前放置变量，都可以用来暗示乘法：</p>
<pre><code>julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
</code></pre><p><strong>后置括号跟函数的参数调用冲突，所以这样的写法会报错</strong></p>
<h3 id="字面零和一"><a href="#字面零和一" class="headerlink" title="字面零和一"></a>字面零和一</h3><p>Julia提供的函数返回对应于指定类型或给定变量类型的文字0和1。</p>
<p>功能    描述<br>zero(x)    x变量类型或类型的字面零x<br>one(x)    文字类型x或类型的变量x<br>这些函数在数值比较中很有用，可以避免不必要的类型转换带来的开销。</p>
<p>例子：</p>
<pre><code>julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.0
</code></pre><h2 id="数学运算和基本功能"><a href="#数学运算和基本功能" class="headerlink" title="数学运算和基本功能"></a>数学运算和基本功能</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>所有原始数字类型都支持以下算术运算符：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+x</td>
<td>一元加</td>
<td>身份操作</td>
</tr>
<tr>
<td>-x</td>
<td>一元减去</td>
<td>将值映射到它们的加法反转</td>
</tr>
<tr>
<td>x + y</td>
<td>二进制加</td>
<td>执行添加</td>
</tr>
<tr>
<td>x - y</td>
<td>二进制减去</td>
<td>执行减法</td>
</tr>
<tr>
<td>x * y</td>
<td>时</td>
<td>执行乘法运算</td>
</tr>
<tr>
<td>x / y</td>
<td>划分</td>
<td>执行分裂</td>
</tr>
<tr>
<td>x ÷ y</td>
<td>整数除</td>
<td>x / y，截断为整数</td>
</tr>
<tr>
<td>x \ y</td>
<td>逆分</td>
<td>相当于 y / x</td>
</tr>
<tr>
<td>x ^ y</td>
<td>功率</td>
<td>提升x到了y力量</td>
</tr>
<tr>
<td>x % y</td>
<td>余</td>
<td>相当于 rem(x,y)</td>
</tr>
</tbody>
</table>
<p>以及对Bool类型的否定：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>!x</td>
<td>否定</td>
<td>改变true，false反之亦然</td>
</tr>
</tbody>
</table>
<p><strong>julia中/是算术除法，÷是地板除法</strong></p>
<p>按位运算符<br>所有原始整数类型都支持以下按位运算符：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>~x</td>
<td>按位不是</td>
</tr>
<tr>
<td>x &amp; y</td>
<td>按位和</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>按位或</td>
</tr>
<tr>
<td>x ⊻ y</td>
<td>按位xor（独占或）</td>
</tr>
<tr>
<td><strong>x &gt;&gt;&gt; y</strong></td>
<td><strong>逻辑右移</strong></td>
</tr>
<tr>
<td>x &gt;&gt; y</td>
<td>算术右移</td>
</tr>
<tr>
<td>x &lt;&lt; y</td>
<td>逻辑/算术移位左</td>
</tr>
</tbody>
</table>
<p>所有二进制算术和按位赋值运算符如下：<br>+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</p>
<h3 id="矢量化的“点”运算符-此乃第二大神器）"><a href="#矢量化的“点”运算符-此乃第二大神器）" class="headerlink" title="矢量化的“点”运算符 ###(此乃第二大神器）"></a>矢量化的“点”运算符 ###(此乃第二大神器）</h3><p>对于每个二进制操作^，都有一个相应的“点”操作.^，它被自动定义为^在数组上逐个元素地执行。例如，[1,2,3] ^ 3未定义，因为“立方”（非正方形）数组没有标准数学意义，而是[1,2,3] .^ 3定义为计算元素（或“矢量化”）结果[1^3, 2^3, 3^3]。类似地，对于像!或一样的一元运算符.x，有一个对应.x的元素应用运算符。</p>
<pre><code>julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27

julia&gt; [1,2,3] .+4
3-element Array{Int64,1}:
 5
 6
 7

julia&gt; x = 3
3

julia&gt; [1,2,3] .*x
3-element Array{Int64,1}:
 3
 6
 9
</code></pre><h3 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h3><p>为所有原始数字类型定义标准比较操作：</p>
<table>
<thead>
<tr>
<th>操作者</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等</td>
</tr>
<tr>
<td>!=， ≠</td>
<td>不相等</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=， ≤</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=， ≥</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
<p>根据IEEE 754标准比较浮点数：</p>
<ul>
<li>有限数字以通常的方式排序。</li>
<li>正零等于但不大于负零。</li>
<li>Inf等于自己，比其他任何值都大。</li>
<li>-Inf等于自己，小于任意值。</li>
<li><p>NaN 不等于，不小于，不大于任何东西，包括它本身。不可做比较运算</p>
<pre><code>julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false
</code></pre></li>
</ul>
<p>Julia提供了额外的函数来测试特殊值的数字，这在哈希键比较的情况下非常有用：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>测试是否</th>
</tr>
</thead>
<tbody>
<tr>
<td>isequal(x, y)</td>
<td>x并且y是相同的</td>
</tr>
<tr>
<td>isfinite(x)</td>
<td>x 是一个有限数，非无穷</td>
</tr>
<tr>
<td>isinf(x)</td>
<td>x 是无穷的</td>
</tr>
<tr>
<td>isnan(x)</td>
<td>x 不是一个数字</td>
</tr>
</tbody>
</table>
<p><strong>isequal认为NaNs彼此相等：</strong></p>
<pre><code>julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true
</code></pre><p><strong>isequal 也可用于区分带符号的零：</strong></p>
<pre><code>julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false
</code></pre><h3 id="连续比较-（此乃第三大神器）"><a href="#连续比较-（此乃第三大神器）" class="headerlink" title="连续比较 ###（此乃第三大神器）"></a>连续比较 ###（此乃第三大神器）</h3><p>与大多数语言不同，除了Python之外，比较可以任意链接：</p>
<pre><code>julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true

julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)
julia&gt; v(1)&lt;v(2)&lt;v(3)&lt;v(4)&lt;v(5)
2
1
3
4
5
true
</code></pre><p>链式比较中的评估顺序是不确定的。强烈建议不要在链式比较中使用带副作用的表达式（如打印）。如果需要副作用，&amp;&amp;应明确使用短路操作器。</p>
<h3 id="运算符优先级和相关性"><a href="#运算符优先级和相关性" class="headerlink" title="运算符优先级和相关性"></a>运算符优先级和相关性</h3><p>Julia应用以下顺序和操作的关联性，从最高优先级到最低优先级：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>操作符</th>
<th>关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td>句法</td>
<td>.  ::</td>
<td>从左往右</td>
</tr>
<tr>
<td>幂</td>
<td>^</td>
<td>从右往左</td>
</tr>
<tr>
<td>一元</td>
<td>+ - √</td>
<td>从右往左[1]</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左往右</td>
</tr>
<tr>
<td>馏分</td>
<td>//</td>
<td>从左往右</td>
</tr>
<tr>
<td>乘除</td>
<td>* / % &amp; \ ÷</td>
<td>从左往右[2]</td>
</tr>
<tr>
<td>加减</td>
<td>+ - &#124; ⊻</td>
<td>从左往右[2]</td>
</tr>
<tr>
<td>句法</td>
<td>: ..</td>
<td>从左往右</td>
</tr>
<tr>
<td>句法</td>
<td>&gt;    从左往右</td>
</tr>
<tr>
<td>句法</td>
<td>&lt;</td>
<td>从右往左</td>
</tr>
<tr>
<td>比较</td>
<td>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</td>
<td>非关联</td>
</tr>
<tr>
<td>控制流</td>
<td>‘&amp;&amp;’&gt;’&#124;&#124;’&gt;’?’</td>
<td>从右往左</td>
</tr>
<tr>
<td>配对</td>
<td>=&gt;</td>
<td>从右往左</td>
</tr>
<tr>
<td>赋值</td>
<td>= += -= *= /= //= \= ^= ÷= %= &#124;= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>从右往左</td>
</tr>
</tbody>
</table>
<p>[1]<br>一元运算符+和-需要围绕它们的参数明确括号以使它们与运算符++等消除歧义。一元运算符的其他组合被解析为具有右关联性，例如√√-aas √(√(-a))。</p>
<p>[2]<br>运算符+，++和<em>是非关联的。a + b + c被解析为+(a, b, c)而不是+(+(a, b), c)。但是，后备方法+(a, b, c, d…)和</em>(a, b, c, d…)默认为左关联。</p>
<h3 id="求和-积运算-（此乃第四大神器）"><a href="#求和-积运算-（此乃第四大神器）" class="headerlink" title="求和 积运算 ###（此乃第四大神器）"></a>求和 积运算 ###（此乃第四大神器）</h3><pre><code>julia&gt; +(1,2,3)
6

julia&gt; +(+(1,2,3),4)
10

julia&gt; *(1,2,3,4)
24
</code></pre><p>运输符优先级函数<br>您还可以通过内置函数找到任何给定运算符的数字优先级Base.operator_precedence，其中较高的数字优先：</p>
<pre><code>julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(9,11,15)
</code></pre><p>通过调用内置函数也可以找到表示运算符关联性的符号Base.operator_associativity–此函数在官网上面有，但是我的版本里面是没有的定义。<br>官网上面写的运行结果为（看个人电脑情况吧，没有搞清楚怎么回事）</p>
<pre><code>julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)
</code></pre><h3 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h3><p>Julia支持三种形式的数值转换，它们在处理不精确转换时有所不同。</p>
<ul>
<li>T(x)或convert(T,x)转换x为T类型的值。 T取值可以是Int8 Int16 Float16等</li>
</ul>
<p>如果T是浮点类型，则结果是最接近的可表示值，可以是正无穷大或负无穷大。<br>如果T是整数类型，InexactError则如果x不能表示，则引发a T。</p>
<ul>
<li><p>x % T将整数转换x为整数类型的值全T等到x模数2^n，其中n是位数T。换句话说，二进制表示被截断以适合。</p>
</li>
<li><p>round函数采取类型T作为可选参数。例如，round(Int,x)是一个简写Int(round(x))。</p>
</li>
</ul>
<h3 id="舍-amp-入函数使用说明"><a href="#舍-amp-入函数使用说明" class="headerlink" title="舍&amp;入函数使用说明"></a>舍&amp;入函数使用说明</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>round(x)</td>
<td>就近取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>round(T, x)</td>
<td>就近取整</td>
<td>T</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>floor(T, x)</td>
<td>向下取整</td>
<td>T</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>向上取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>ceil(T, x)</td>
<td>向上取整</td>
<td>T</td>
</tr>
<tr>
<td>trunc(x)</td>
<td>向0取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>trunc(T, x)</td>
<td>向0取整</td>
<td>T</td>
</tr>
</tbody>
</table>
<h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a>除法函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>div(x,y), x÷y</td>
<td>取整整除</td>
</tr>
<tr>
<td>fld(x,y)</td>
<td>向下取整整除</td>
</tr>
<tr>
<td>cld(x,y)</td>
<td>向上取整整除</td>
</tr>
<tr>
<td>rem(x,y)</td>
<td>取模</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>取模</td>
</tr>
<tr>
<td>mod1(x,y)</td>
<td>取模，但是在整除时返回值为y</td>
</tr>
<tr>
<td>divrem(x,y)</td>
<td>返回商和余数的元组（a,b）</td>
</tr>
<tr>
<td>fldmod(x,y)</td>
<td>返回商和余数的元组（a,b）</td>
</tr>
<tr>
<td>gcd(x,y…)</td>
<td>最大公约数</td>
</tr>
<tr>
<td>lcm(x,y…)</td>
<td>最小公倍数</td>
</tr>
</tbody>
</table>
<h3 id="符号和绝对值函数"><a href="#符号和绝对值函数" class="headerlink" title="符号和绝对值函数"></a>符号和绝对值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td>x的绝对值</td>
</tr>
<tr>
<td>abs2(x)</td>
<td>x^2</td>
</tr>
<tr>
<td>sign(x)</td>
<td>正数返回1，负数返回-1 ，0返回0</td>
</tr>
<tr>
<td>signbit(x)</td>
<td>负数返回true,其他都返回false</td>
</tr>
<tr>
<td>copysign(x,y)</td>
<td>将y的符号给到x，返回之后的x</td>
</tr>
<tr>
<td>flipsign(x,y)</td>
<td>x的符号取决于x*y的符号，返回之后的x</td>
</tr>
</tbody>
</table>
<h3 id="指数-对数-平方根函数"><a href="#指数-对数-平方根函数" class="headerlink" title="指数 对数 平方根函数"></a>指数 对数 平方根函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sqrt(x), √x</td>
<td>对x进行开方</td>
</tr>
<tr>
<td>cbrt(x), ∛x</td>
<td>对x进行开3次方</td>
</tr>
<tr>
<td>hypot(x,y)</td>
<td>返回x y的平方和之后的根，也就是向量(x,y)的长度</td>
</tr>
<tr>
<td>exp(x)</td>
<td>底数为e，返回e^x的结果</td>
</tr>
<tr>
<td>expm1(x)</td>
<td>返回exp(x)-1</td>
</tr>
<tr>
<td>ldexp(x,n)</td>
<td>返回2^n * x的结果，<strong>这里x必须为Float类型</strong></td>
</tr>
<tr>
<td>log(x)</td>
<td>自然数对数</td>
</tr>
<tr>
<td>log(b,x)</td>
<td>返回以b为底，x为基数的对数</td>
</tr>
<tr>
<td>log2(x)</td>
<td>返回以2为底，x为基数的对数</td>
</tr>
<tr>
<td>log10(x)</td>
<td>返回以10为底，x为基数的对数</td>
</tr>
<tr>
<td>log1p(x)</td>
<td>返回log(x+1)的结果</td>
</tr>
<tr>
<td>exponent(x)</td>
<td>返回整数部分2进制的位数，exponent(127.0)=6 exponent(128.0)=7 </td>
</tr>
<tr>
<td>significand(x)</td>
<td>返回值为1.a，a的算法为x%8/8</td>
</tr>
</tbody>
</table>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>sin 正弦   sinA = a/c a为A的对角的边长，c为斜边<br>cos余弦    cosA = b/c b为另外的一条直角边<br>tan  正切  tanA = a/b<br>cot  余切  cotA = b/a<br>sec  正割  secA = c/b<br>csc余割    cscA = c/a<br>sinh   cosh   tanh   coth   sech   csch 双曲xx<br>asin   acos   atan   acot   asec   acsc  反xx  x=sin(y) -&gt; y = asin(x) + pi/2*N<br>asinh  acosh  atanh  acoth  asech  acsch 反双曲xx<br>sinc   cosc 周期为2的正余弦函数</p>
<p>以d结束的三角函数都是以度数作为单位进行运算的，前面和之前的一样<br>sind   cosd   tand   cotd   secd   cscd<br>asind  acosd  atand  acotd  asecd  acscd</p>
<p>举例：</p>
<pre><code>julia&gt; sind(90)
1.0

julia&gt; sind(45)
0.7071067811865476
</code></pre><p>更多特殊函数请移步 <a href="https://github.com/JuliaMath/SpecialFunctions.jl" target="_blank" rel="noopener">SpecialFunctions.jl</a></p>
<h2 id="复数和有理数"><a href="#复数和有理数" class="headerlink" title="复数和有理数"></a>复数和有理数</h2><p>复数表示方式示例 2+3im,其中2为实部，3为虚部，im是虚部的标志，将3im写前面语法上是对的，但是输出的时候会显示为2+3im<br>使用复数执行所有标准算术运算：</p>
<pre><code>julia&gt; (1 + 2im)*(2 - 3im)
8 + 1im

julia&gt; (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia&gt; (1 + 2im) + (1 - 2im)
2 + 0im

julia&gt; (-3 + 2im) - (5 - 1im)
-8 + 3im

julia&gt; (-1 + 2im)^2
-3 - 4im

julia&gt; (-1 + 2im)^2.5
2.729624464784009 - 6.9606644595719im

julia&gt; (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia&gt; 3(2 - 5im)
6 - 15im

julia&gt; 3(2 - 5im)^2
-63 - 60im

julia&gt; 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
</code></pre><p>注意 3/4im == 3/(4<em>im) == -(3/4</em>im)</p>
<h3 id="复数函数"><a href="#复数函数" class="headerlink" title="复数函数"></a>复数函数</h3><pre><code>julia&gt; z = 1 + 2im
1 + 2im

julia&gt; real(1 + 2im) # real part of z
1

julia&gt; imag(1 + 2im) # imaginary part of z
2

julia&gt; conj(1 + 2im) # complex conjugate of z
1 - 2im

julia&gt; abs(1 + 2im) # absolute value of z
2.23606797749979  #sqrt(a^2+b^2)

julia&gt; abs2(1 + 2im) # squared absolute value
5  #a^2+b^2

julia&gt; angle(1 + 2im) # phase angle in radians
1.1071487177940904
</code></pre><p>conj(x)    返回的是复数x的共轭复数，实部一样，虚部取-运算</p>
<p>有如下公式成立：<br><strong>x = conj(X)/abs2(x)</strong></p>
<p>angle(x)函数是求复数相角，是在matlab中的一种方法，计算复数x向量的相角，返回值为为-pi~pi之间，结果准确表达的含义是向量与x轴正向的夹角的弧度，当向量无限趋近于-x轴方向时越接近最值pi或者-pi</p>
<pre><code>julia&gt; sqrt(1im)
0.7071067811865476 + 0.7071067811865475im


julia&gt; sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia&gt; cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia&gt; exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia&gt; sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
</code></pre><p>说明一下，有如下公式成立</p>
<p><strong>angle(x)/2 = angle(sqrt(x))</strong></p>
<p>复数的开发实际是将相位/2，求新得到的相位上的长度的对应表示方法<br>复数的构造函数complex(a,b) -&gt; (a+bim)</p>
<p>注意一下INF Nan在复数上的表示</p>
<pre><code>julia&gt; 1 + Inf*im
1.0 + Inf*im

julia&gt; 1 + NaN*im
1.0 + NaN*im
</code></pre><h2 id="有理数"><a href="#有理数" class="headerlink" title="有理数"></a>有理数</h2><p>分数表示方式 2//3表示的是三分之二</p>
<pre><code>julia&gt; 2//3 == 6//9
true

julia&gt; 2//3 == 9//27
false

julia&gt; 3//7 &lt; 1//2
true

julia&gt; 3//4 &gt; 2//3
true

julia&gt; 2//4 + 1//6
2//3

julia&gt; 5//12 - 1//4
1//6

julia&gt; 5//8 * 3//12
5//32

julia&gt; 6//5 / 10//7
21//25
</code></pre><p>特殊注意的是分母为0时的情况</p>
<pre><code>julia&gt; 5//0
1//0

julia&gt; -3//0
-1//0

julia&gt; 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
 in call at ./rational.jl:8
</code></pre><p>5//0显示为1//0，然后与分数运算，结果为1//0</p>
<pre><code>julia&gt; 5//0 + 1//2
1//0

julia&gt; 5//0 *1//2
1//0

julia&gt; 5//0 *10
1//0

julia&gt; 5//0 +1
1//0

julia&gt; 5//0 *100
1//0
</code></pre><p>分数表示的运算和浮点数运算规则一样，只是表示的方法一直都是分数</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>Julia的字符串支持的编码是UTF-8的，支持中文以及大众语言，当然,ascii的字符处理起来更快一点。</p>
<h3 id="字符串高级功能"><a href="#字符串高级功能" class="headerlink" title="字符串高级功能"></a>字符串高级功能</h3><p>关于Julia的字符串有一些值得注意的高级功能：</p>
<ul>
<li>Julia中用于字符串（和字符串文字）的内置具体类型是String。它通过UTF-8编码支持所有Unicode字符。（提供了一个函数来转换为/从其他Unicode编码转换。）</li>
<li>所有字符串类都是抽象类AbstractString的子类，外部包定义了其他AbstractString子类型（例如，用于其他编码-gbk）。如果定义了一个函数需要一个字符串参数，则应该将类型声明为AbstractString，这样可以接受任何类型字符串。</li>
<li>像C和Java一样，但与大多数动态语言不同，Julia有一个用于表示单个字符的第一类类型，称为AbstractChar。内置Char子类型AbstractChar是32位基本类型，可以表示任何Unicode字符（并且基于UTF-8编码）。</li>
<li>与在Java中一样，字符串是不可变的：AbstractString不能更改对象的值。要构造不同的字符串值，可以从其他字符串的来构造新字符串。</li>
<li>从概念上讲，字符串是从索引到字符的部分函数：对于某些索引值，不返回任何字符值，而是抛出异常。这允许通过编码表示的字节索引而不是字符索引有效地索引到字符串，这对于Unicode字符串的可变宽度编码不能有效且简单地实现。</li>
<li><strong>字符串的索引值下标从1开始的，a[0]会报错julia&gt; ab[0]</strong><br>ERROR: BoundsError: attempt to access 16-element Array{UInt8,1}:</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>字符是用单引号表示的，里面只能包含表示一个字符的表达式或者字母，如果不止一个字符则会报错</p>
<pre><code>julia&gt; &apos;x&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char

julia&gt; Int(&apos;x&apos;)
120

julia&gt; typeof(ans)
Int64

julia&gt; &apos;\u0&apos;
&apos;\0&apos;: ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; &apos;\u78&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &apos;\u2200&apos;
&apos;∀&apos;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; &apos;\U10ffff&apos;
&apos;\U10ffff&apos;: Unicode U+10ffff (category Cn: Other, not assigned)
更多ASCII字符表示可以百度一下
</code></pre><p>字符是可以比较和做加减法运算的，但是不能2个字符进行加法</p>
<pre><code>julia&gt; a = &apos;a&apos;
&apos;a&apos;

julia&gt; b = &apos;b&apos;
&apos;b&apos;

julia&gt; a+b
ERROR: MethodError: `+` has no method matching +(::Char, ::Char)
Closest candidates are:
  +(::Any, ::Any, ::Any, ::Any...)
  +(::Integer, ::Char)
  +(::Char, ::Integer)

julia&gt; a+1
&apos;b&apos;

julia&gt; a+2
&apos;c&apos;

julia&gt; b -a
1

julia&gt; b-1
&apos;a&apos;
</code></pre><h2 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h2><h3 id="字符串表示方式"><a href="#字符串表示方式" class="headerlink" title="字符串表示方式"></a>字符串表示方式</h3><p>字符串可以用双引号 三引号进行表示，当字符串内容里面需要有双引号的时候，可以使用三引号，也可以选择转义</p>
<pre><code>julia&gt; str = &quot;Hello, world.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;&quot;&quot;Contains &quot;quote&quot; characters&quot;&quot;&quot;
&quot;Contains \&quot;quote\&quot; characters&quot;
</code></pre><h3 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h3><p><strong>字符串的默认最后一个字符的下标为end</strong>，str[end]就是取最后一个元素，但是<strong>没有start，起始值就是1，也不是0</strong>，不能想当然。<br><strong>独此一份，Julia的下标是从1开始的，与其他计算机编程语言都不同</strong></p>
<pre><code>julia&gt; str[1]
&apos;H&apos;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
&apos;,&apos;: ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[end]
&apos;\n&apos;: ASCII/Unicode U+000a (category Cc: Other, control)
</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>返回字符串str的第四位到第九位，包含9</p>
<pre><code>julia&gt; str[4:9]
&quot;lo, wo&quot;  
</code></pre><p>返回的是<strong>字符类型</strong></p>
<pre><code>julia&gt; str[6] 
&apos;,&apos;: ASCII/Unicode U+002c (category Po: Punctuation, other)
</code></pre><p>返回的是<strong>字符串类型</strong></p>
<pre><code>julia&gt; str[6:6]
&quot;,&quot; 
</code></pre><p>切片函数SubString(str,start,stop) #避免end歧义所以用的stop</p>
<pre><code>julia&gt; str = &quot;long string&quot;
&quot;long string&quot;

julia&gt; substr = SubString(str, 1, 4)
&quot;long&quot;

julia&gt; typeof(substr)
SubString{String}
</code></pre><p>unicode &amp; utf-8<br>这个知识点是计算机都有的，自行百度，其中一个：<br><a href="https://blog.csdn.net/humadivinity/article/details/79403625" target="_blank" rel="noopener">https://blog.csdn.net/humadivinity/article/details/79403625</a></p>
<h3 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h3><ul>
<li>for x in str的方式遍历<br>s = “a b c d”<br>julia&gt; for c in s<pre><code>    println(c)
end
</code></pre>a</li>
</ul>
<p>b</p>
<p>c</p>
<p>d</p>
<ul>
<li>foreach函数（我的版本中无效，官网是有写的）<br>foreach(display,s)</li>
</ul>
<h3 id="字符串构造函数"><a href="#字符串构造函数" class="headerlink" title="字符串构造函数"></a>字符串构造函数</h3><p>string(s1,s2,s3,s4)  -&gt;返回值为s1s2s3s4的拼接结果</p>
<pre><code>julia&gt; greet = &quot;Hello&quot;
&quot;Hello&quot;

julia&gt; whom = &quot;world&quot;
&quot;world&quot;

julia&gt; string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)
&quot;Hello, world.\n&quot;
</code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串不支持 s<em>number的格式来复制字符串，但是支持 s1 </em> s2 * s3来对s1 s2 s3进行拼接</p>
<h3 id="字符串引用"><a href="#字符串引用" class="headerlink" title="字符串引用"></a>字符串引用</h3><p>使用$符号后面接变量名称来引用变量存放的内容</p>
<pre><code>julia&gt; &quot;$greet, $whom.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;1 + 2 = $(1 + 2)&quot;
&quot;1 + 2 = 3&quot;

julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; &quot;v: $v&quot;
&quot;v: [1, 2, 3]&quot;

julia&gt; name = &apos;Bob&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &quot;hi, $name&quot;
&quot;hi, Bob&quot;
</code></pre><h3 id="三引号字符串"><a href="#三引号字符串" class="headerlink" title="三引号字符串"></a>三引号字符串</h3><p>三引号字符串可以隐式换行，想在字符串中保持原文内容不变，可以采用三引号来表示。<br>显示的时候换行是用的 \n 来显示的</p>
<h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><p>字符串可以进行：<br>1 大小比较运算​<br>2 相等判断<br>3 查找是否包含<br>4 重复复制字符串 repeat(s,10) s复制10次<br>5 将列表转换为字符串，有2个参数，第二个可选，第一个参数含义是列表中的元素用参数1进行拼接，如果第二个参数有，则表示在最后一个元素前添加该参数，示例如下</p>
<pre><code>julia&gt; join([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;],&quot;,&quot;,&quot; and &quot;)
&quot;aaa,bbb,ccc and ddd&quot;
</code></pre><p>6 其他一些有用的函数有包括：</p>
<p>firstindex(str)给出了可用于索引的最小（字节）索引str（对于字符串总是1，对于其他容器不一定是真的）。<br>lastindex(str)给出了可用于索引的最大（字节）索引str。<br>length(str)中的字符数str。<br>length(str, i, j)有效字符的数量指标的str，从i到j。<br>ncodeunits(str)字符串中的代码单元数。<br>codeunit(str, i)给出str索引处字符串中的代码单元值i。<br>thisind(str, i) 给一个字符串中的任意索引找到索引指向的字符的第一个索引。<br>nextind(str, i, n=1)找到n索引后开始的第th个字符的开头i。<br>prevind(str, i, n=1)找到n索引前的第th个字符的开头i。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式的表示方式<br>r”xxxxx”</p>
<p>你可以从RegexMatch对象中提取以下信息：</p>
<p>整个子串匹配： m.match<br>捕获的子串作为字符串数组： m.captures<br>整个匹配开始的偏差： m.offset<br>捕获的子串的偏移量作为向量： m.offsets</p>
<pre><code>julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2
</code></pre><p>子组的访问方式</p>
<pre><code>julia&gt; m=match(r&quot;(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)&quot;,&quot;12:45&quot;)
RegexMatch(&quot;12:45&quot;, hour=&quot;12&quot;, minute=&quot;45&quot;)

julia&gt; m[:minute]
&quot;45&quot;

julia&gt; m[2]
&quot;45&quot;
</code></pre><p><strong>将2个单词交换位置：</strong></p>
<pre><code>julia&gt; replace(&quot;first second&quot;, r&quot;(\w+) (?&lt;agroup&gt;\w+)&quot; =&gt; s&quot;\g&lt;agroup&gt; \1&quot;)
&quot;second first&quot;

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/web前端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/web前端/" itemprop="url">web前端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T11:11:31+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,356 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="前端学习体系"><a href="#前端学习体系" class="headerlink" title="前端学习体系"></a>前端学习体系</h2><pre><code>1.HTML-用来勾勒出网页的结构和内容-骨架
2.CSS-用来美化网页-皮肤-化妆
3.JavaScript-让网页呈现出动态的数据和效果
4.jQuery-js框架，提高JavaScript开发效率
</code></pre><h2 id="浏览器介绍"><a href="#浏览器介绍" class="headerlink" title="浏览器介绍"></a>浏览器介绍</h2><pre><code>chrome safari  ---&gt; webkit
firefox ---&gt; mozilla
</code></pre><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><pre><code>html保存在服务器，html运行在浏览器
html--超文本标记语言
</code></pre><h2 id="HTMl-语法"><a href="#HTMl-语法" class="headerlink" title="HTMl 语法"></a>HTMl 语法</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>&lt;标签&gt;&lt;/标签&gt;
ex:&lt;div&gt;&lt;/div&gt;
</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>&lt;标签 属性1=&quot;值1&quot; 属性2=&quot;值2&quot; ..&gt;&lt;/标签&gt;
ex:&lt;span id=&quot;s1&quot; style=&quot;..&quot;&gt;&lt;/span&gt;
</code></pre><h3 id="标签与标签之间的嵌套关系"><a href="#标签与标签之间的嵌套关系" class="headerlink" title="标签与标签之间的嵌套关系"></a>标签与标签之间的嵌套关系</h3><pre><code>&lt;div&gt;
    &lt;span id=&quot;s1&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><h3 id="标签的分类"><a href="#标签的分类" class="headerlink" title="标签的分类"></a>标签的分类</h3><pre><code>    1.闭合标签/双标签
        &lt;body&gt;内容&lt;/body&gt;
    2.非闭合标签/单标签
        &lt;标签&gt;
        &lt;标签/&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        单标签没有内容这个概念

总结：学习html，就是学习固定标签，固定属性
            以及标签间的嵌套关系
</code></pre><h2 id="HTML用法"><a href="#HTML用法" class="headerlink" title="HTML用法"></a>HTML用法</h2><pre><code>HTML  经历了5个版本
HTML4 之前版本很宽泛，宽松
HTML4 非常严谨
HTML5 是最新也是最流行的版本。比HTML4宽泛

&lt;!doctype html&gt;&lt;!--文档定义标签--&gt;
&lt;html&gt;&lt;!--根元素--&gt;
    &lt;head&gt;
        &lt;!--本网页相关信息--&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!--网页的主体，
        在页面中显示的所有内容
        都写在body里面--&gt;
        hello world!My first page!!
    &lt;/body&gt;
&lt;/html&gt;

总结：doctype用于约束HTML文档内部的
      标签，属性和嵌套关系
            不写doctype,同一篇代码，会在不同浏览器
            中，有巨大显示差异。
</code></pre><h2 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h2><h3 id="文本标签–跟论文格式非常相似"><a href="#文本标签–跟论文格式非常相似" class="headerlink" title="文本标签–跟论文格式非常相似"></a>文本标签–跟论文格式非常相似</h3><pre><code>标题  &lt;hn&gt;&lt;/hn&gt;  n=1~6
ex:   &lt;h1&gt;&lt;/h1&gt;
            ...
            &lt;h6&gt;&lt;/h6&gt;
总结：h1最大，h6最小
            字体加粗
            垂直方向，上下都有空间

段落 paragraph
    &lt;p&gt;&lt;/p&gt;
            垂直方向，上下都有空间
</code></pre><h3 id="课堂案例："><a href="#课堂案例：" class="headerlink" title="课堂案例："></a>课堂案例：</h3><pre><code>使用hn标签和p标签，写自己的简易的简历
属性 align=&quot;center&quot; 可以使用在标题标签中
</code></pre><h3 id="列表标签-显得有条理"><a href="#列表标签-显得有条理" class="headerlink" title="列表标签 显得有条理"></a>列表标签 显得有条理</h3><pre><code>3.1无序列表    
    u--unordered
    l--list
    i--item
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    ...
&lt;/ul&gt;
3.2有序列表
&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    ...
&lt;/ol&gt;
</code></pre><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><pre><code>&lt;div&gt;&lt;/div&gt;
div看不见，功能是为了逻辑分区
&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; 头
&lt;div id=&quot;nav&quot;&gt;&lt;/div&gt; 导航栏
&lt;div id=&quot;contents&quot;&gt;&lt;/div&gt; 内容
&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt; 脚

H5添加了很多和div一样，
但是更容易读容易理解的标签
&lt;header&gt;&lt;/header&gt;
&lt;nav&gt;&lt;/nav&gt;
&lt;footer&gt;&lt;/footer&gt;

块级分区    div在这个区域独占一行

行级(行内)分区
    &lt;span&gt;&lt;/span&gt;
    如果只是一行文字内部的区域
    进行分区设置属性、修改样式
    这种时候使用行内分区

    行内分区不会换行，会和其他文字混合
    在同一行上span
</code></pre><h3 id="元素-标签-的显示方式"><a href="#元素-标签-的显示方式" class="headerlink" title="元素(标签)的显示方式"></a>元素(标签)的显示方式</h3><pre><code>1.行级元素(行内)
    可以和其他行级元素位于同一行显示
    span
2.块级元素
    自己独占一行
    hn p div ul li ol
</code></pre><h3 id="其他的行内元素"><a href="#其他的行内元素" class="headerlink" title="其他的行内元素"></a>其他的行内元素</h3><pre><code>i/em      斜体
b/strong  粗体
u         下划线
del/s            删除线
</code></pre><h3 id="实体引用，实体替换符号"><a href="#实体引用，实体替换符号" class="headerlink" title="实体引用，实体替换符号"></a>实体引用，实体替换符号</h3><pre><code>行内元素的空格折叠现象
写代码的时候，不管连写多少个空格和
回车，显示成一个空格

&lt;br&gt;
&lt;br/&gt;回车

&amp;nbsp; 空格
&amp;lt;  &lt;  
&amp;gt;  &gt;
</code></pre><p>复习：</p>
<p>1.网站运行的流程<br>    .html存储在服务器，运行在浏览器<br>2.h5 html的标准框架</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>3.文本标签<br>    hn p ul li ol<br>4.分区标签<br>    块级分区 div  header footer nav<br>    行级分区 span i em s del u strong b<br>5.块级元素与行级元素的区别<br>    块级元素，自己独占一行<br>    行级元素，可以与其他行级元素位于同一行<br>6.实体替代符号<br>    &nbsp;&lt;&gt;</p>
<p>作业：<br>1.网站的运行流程<br>2.行级元素与块级元素的区别<br>3.今天所有的demo重新敲一遍<br>4.详细的完善个人简历要使用div分区<br>    建议使用i b u等标签给关键内容修改样式</p>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><p>是一个单标签，最重要的属性src<br><img src="/2018/08/11/web前端/图片路径"></p>
<p>图片路径的写法<br>主机、路径、文件名都写清晰了<br>绝对路径<br>在一个显示其他网站中的图片，<br>这种行为图片盗链<br>通常使用绝对路径，称提供网页图片的网站为图床</p>
<p>好处就是，节省了自己服务器的存储空间<br>坏处，图床网站把图片路径改变，<br>            自己的网站就显示不出来了</p>
<p>相对路径–参照物–&gt;当前.html文件</p>
<pre><code>&lt;img src=&quot;08.png&quot;&gt;
&lt;img src=&quot;img/07.png&quot;&gt;
&lt;img src=&quot;../img/06.png&quot;&gt;
</code></pre><p>img的其他属性<br>img行级元素，自带了width和height<br>图片的失真<br>为了解决图片失真的问题<br>通常width和height只写一个<br>让另外一个去自适应</p>
<p>alt：找不到图片时，显示的文本<br>title：鼠标悬停在元素上，弹出的文本</p>
<p>img标签支持下面几种图片格式<br>png 支持透明色<br>jpg 不支持透明色<br>gif 支持动态图   256色</p>
<h2 id="超链接-用于跳转页面"><a href="#超链接-用于跳转页面" class="headerlink" title="超链接 用于跳转页面"></a>超链接 用于跳转页面</h2><p>作用：链接到网页，图片，下载<br>    <a href="http://www.baidu.cn/" target="_blank" rel="noopener">文本链接</a><br>    <a href="img/08.png">点我出图片</a><br>    <a href="01_img.html">跳转到01_img.html</a></p>
<p>a标签的属性<br>target    _self 链接页面在当前选项卡打开 默认值<br>                    _blank 链接页面在新的选项卡打开</p>
<p>两个页面之间的跳转，是超链接<br>一个页面内部的位置跳转，是锚点</p>
<p>H5锚点的用法:<br>在需要跳转的位置<br>标签内添加id属性<br>比如id=”abc”<br>在a标签中的href属性中<br>添加值 href=”#abc”<br>这样点击a标签，页面就会跳转到锚点的位置<br>另：href=”#”会让页面直接跳转到顶部</p>
<pre><code>&lt;h3 id=&quot;a&quot;&gt;charAt&lt;/h3&gt;
&lt;a href=&quot;#a&quot;&gt;charAt()方法&lt;/a&gt;
</code></pre><h2 id="网页中表格标签"><a href="#网页中表格标签" class="headerlink" title="网页中表格标签"></a>网页中表格标签</h2><pre><code>&lt;table border=&quot;2px&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;aaaa&lt;/td&gt;
        &lt;td&gt;bbbb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;cccc&lt;/td&gt;
        &lt;td&gt;dddd&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>table是表格<br>tr  table row 行<br>td  table data 列</p>
<p>table的常用属性<br>width     宽<br>height    高<br>border    边框宽度<br>align     表格对其<br>cellpadding  边框与内容的距离<br>cellspacing  边框之间的距离</p>
<p>跨列，一个单元格占据多列</p>
<td colspan="n"></td><br>从左向右跨n列<br><br>跨行，一个单元格占据多行<br><br>    <td rowspan="n"></td>

<p>从上到下占n行<br>由于占据了下面几个单元格的位置<br>下面n-1行，都减少一个td</p>
<p>表分组<br>    <thead></thead><br>    <tbody></tbody><br>    <tfoot></tfoot></p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>用于在页面中显示一个可以收集用户<br>填写的数据的控件</p>
<p>总结：<br>想通过网页把用户填入的信息发送给服务器处理<br>1.所有的标签必须在form表单中<br>2.form表单中的标签，必须有name属性<br>3.使用submit把数据提交给服务器</p>
<p>form表单的主要属性，以下了解即可<br>action:表单提交的url<br>method:表单提交数据的方法<br>enctype:表单数据的编码格式</p>
<p><strong>input 9种类型</strong></p>
<h3 id="文本框和密码框"><a href="#文本框和密码框" class="headerlink" title="文本框和密码框"></a>文本框和密码框</h3><pre><code>&lt;input type=&quot;text&quot; name=&quot;...&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;...&quot;&gt;
</code></pre><p>value属性 值<br>placeholder 文本提示<br>maxlength:限制输入的字符数<br>readonly:只读。自能看，不能改</p>
<h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><p>我们学习过span，span可用在任何地方<br>lable的作用跟span类似，但是只用在表单中</p>
<h3 id="radio-单选框"><a href="#radio-单选框" class="headerlink" title="radio 单选框"></a>radio 单选框</h3><pre><code>&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;
&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;
</code></pre><p>name属性，决定了一组单选<br>value属性，才能提交值！<br>checked=”checked” 默认选中</p>
<h3 id="checkbox-多选框"><a href="#checkbox-多选框" class="headerlink" title="checkbox 多选框"></a>checkbox 多选框</h3><p>name属性，决定了一组多选<br>value属性，才能提交值！<br>checked=”checked” 默认选中</p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>submit 提交</p>
<pre><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
</code></pre><h3 id="button-按钮"><a href="#button-按钮" class="headerlink" title="button 按钮"></a>button 按钮</h3><pre><code>&lt;input type=&quot;button&quot; value=&quot;点点我&quot;
onclick=&quot;alert(&apos;111111111111&apos;)&quot;&gt;
</code></pre><h3 id="reset-重置-基本不用"><a href="#reset-重置-基本不用" class="headerlink" title="reset 重置 基本不用"></a>reset 重置 基本不用</h3><h3 id="隐藏域-hidden"><a href="#隐藏域-hidden" class="headerlink" title="隐藏域 hidden"></a>隐藏域 hidden</h3><p>在form中存在，但是用户看不到<br>隐藏域包含着不给用户看的信息<br>隐藏域的信息，可以提交给服务器</p>
<p><strong>其他类型</strong><br>文件选择器-上传文件用的</p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>有name属性才能提交</p>
<h3 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h3><p>多重的，可以选择多个文件</p>
<h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><pre><code>&lt;textarea&gt;大量的文本&lt;/textarea&gt;    
</code></pre><p>rows cols描述的是文本区域内<br>可见的宽度和高度<br>原本的意思，每一行显示多少个字符，<br>显示多少行字符。<br>但是由于系统编码不同，浏览器解析不同<br>导致显示字符数差异很大。</p>
<h3 id="下拉列表-下拉选"><a href="#下拉列表-下拉选" class="headerlink" title="下拉列表(下拉选)"></a>下拉列表(下拉选)</h3><pre><code>&lt;select&gt;
    &lt;option&gt;&lt;/option&gt;
    ...
    &lt;option&gt;&lt;/option&gt;
&lt;/select&gt;
</code></pre><p>总结：<br>1.当option没有value属性<br>    select标签的value值是<br>    选中的那个option标签的内容<br>2.当option有value属性<br>    select标签的value值是<br>    选中的那个option标签的value值</p>
<p>表单标签总结:</p>
<ul>
<li>1.只有含有name属性的表单标签才可以提交数据</li>
<li>2.radio和checkbox必须<br>设置value属性才可以提交数据</li>
<li>3.text的value是直接设置值<br>placeholder是设置提示</li>
<li>4.radio和checkbox默认选中checked</li>
<li>5.select默认选中是selected</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code>&lt;span style=&quot;color:#f00;font-size:30px&quot;&gt;内联样式的使用&lt;/span&gt;
在标签的style属性中写样式
特点
内联样式使用不多
1.不能重用
2.内联样式优先级最高
项目代码完全不使用内联
只有在学习和调试过程中
</code></pre><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><pre><code>在head标签中，写style标签
在style标签内部写样式
选择器{
    属性：值;
}
样式代码可以重用,但只能在本html中重用
在项目使用不多
</code></pre><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code>创建一个.css文件
在html文件中，head标签中引用这个css文件
&lt;link href=&quot;03.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre><h2 id="层叠样式表的规则特性"><a href="#层叠样式表的规则特性" class="headerlink" title="层叠样式表的规则特性"></a>层叠样式表的规则特性</h2><pre><code>1.层叠效果
    多个样式作用在同一个标签上
    如果样式属性不重复
    那么这些样式都会产生效果
2.继承
    父级元素的样式会继承给子元素
    子元素可以重新写样式，
    不使用父级元素的样式
3.优先级
    优先级最低的 浏览器默认样式
    优先级最高的 内联样式

    内部样式和外部样式--就近优先
    以被影响标签为基准，哪个样式离这个标签近
    就使用哪个样式的效果
</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code>选择器的作用，为了选出当前页面中
符合要求的一个或者多个标签

样式属性的作用，给选出来的标签设置样式

选择器{样式属性:值;}
</code></pre><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><pre><code>*{color:#f00;}
少用，写通用样式的时候使用
</code></pre><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><pre><code>选出当前页面中，标签名称符合要求的标签
ex:div{} span{} p{} body{}
使用范围：设置某个标签的通用样式

body{
    maring:0px;
    padding:0px;
}
</code></pre><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><pre><code>唯一不重复
&lt;p id=&quot;p1&quot;&gt;id选择器1&lt;/p&gt;
#p1{
    color:#f00;
    font-size:25px;
    width:150px;        
}

id选择器 #id值
注意，同一个html中，ID值是唯一不可重复
在同一个html，使用id选择器，
只能找到一个标签
</code></pre><h3 id="类选择器-class选择器"><a href="#类选择器-class选择器" class="headerlink" title="类选择器 class选择器"></a>类选择器 class选择器</h3><pre><code>如果编写html标签时，需要让某些标签应用一类样式，就使用类选择器标签的属性,class为类名

&lt;div class=&quot;d1&quot;&gt;&lt;/div&gt;
.d1{
        width:200px;
        height:100px;
        background-color:#006699;
        border:1px solid #f00;
}

多类选择器

    .w200{
        width:200px;
    }
    .h50{
        height:50px;
    }
    .bgc_red{
        background-color:#f00;
    }        
    &lt;div class=&quot;w200 h50 bgc_red&quot;&gt;&lt;/div&gt;

    当一个标签，想匹配多个样式的时候，使用多类选择器
</code></pre><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><pre><code>把一系列选择器当成一组，设置共有样式。
#p1,.d1,h1,ul,li{
        border:2px solid #000;
}
逗号分隔，可以使用标签选择器，
id选择器，class选择器，混合编写
一般用于设置公共样式
一般项目中分组选择器，写在最开始的部分
</code></pre><h3 id="后代选择器-派生"><a href="#后代选择器-派生" class="headerlink" title="后代选择器(派生)"></a>后代选择器(派生)</h3><pre><code>div h1{
        color:#f00;
}

div内部只要存在h1，就可以定位h1
</code></pre><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><pre><code>div&gt;h1{
    background-color:pink;
}
h1必须是div的儿子才可以被匹配
</code></pre><h2 id="css常用样式属性"><a href="#css常用样式属性" class="headerlink" title="css常用样式属性"></a>css常用样式属性</h2><h3 id="布局-相关属性"><a href="#布局-相关属性" class="headerlink" title="布局 相关属性"></a>布局 相关属性</h3><pre><code>width: 宽
height:高
单位：px cm 100%
</code></pre><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><pre><code>margin:设置外边距
margin:10px;   同时设置4个方向的外边距
margin:10px 20px; 上下为10 左右为20
margin:0px auto;  块级元素水平居中
margin:10px 20px 30px 40px;
                上   右   下   左
margin-top:10px;  上边距
margin-right:
margin-bottom:
margin-left:

设置外边距，视觉效果，块级元素在位移
</code></pre><h4 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h4><pre><code>padding:10px;    设置4个方向的内边距
padding:10px 20px; 上下10px  左右20px
padding:10px 20px 30px 40px
                上    右   下   左
padding-top
padding-right
padding-bottom
padding-left

改变内边距，视觉效果，元素大小改变
</code></pre><h4 id="盒子模型-框结构"><a href="#盒子模型-框结构" class="headerlink" title="盒子模型(框结构)"></a><strong>盒子模型(框结构)</strong></h4><pre><code>css渲染页面时，使用盒子模型
元素之间的留白，元素背景填充范围，
元素大小。对这些属性的控制规则，
就是盒子模型

我们写的元素，
在浏览器中占据的空间是多少(宽度)

左外边距+左边框+左内边距
+内容区域(我们设置的宽高)
+右内边距+右边框+右外边距

总结：
div默认占据宽度，
是父容器的内容区域宽度的100%
div默认的高，是内部内容的高
如果内部没有内容或者没有高
高度为0
</code></pre><h3 id="背景属性background"><a href="#背景属性background" class="headerlink" title="背景属性background"></a>背景属性background</h3><pre><code>1.背景颜色
    background-color:合法的颜色值
    background:合法的颜色值

    合法的颜色值：
    1.颜色的单词 red pink
    2.#ffffff 6位16进制字符串
    3.#aabbcc ---&gt; #abc  #f00 #ff0000
    4.rgb(255,255,255);
    5.rgba(255,255,255,0~1)

2.背景图片 
    background-image:url(&quot;图片路径&quot;)
    background-repeat:no-repeat;平铺方式        
                    repeat
                    repeat-x;
                    repeat-y;
    background-position:center center;背景图片定位
                        center top bottom left right
                        可以直接写数值100px 200px
    background-size:500px 500px;设置背景图片的大小
</code></pre><p><strong>注意点：</strong></p>
<pre><code>块级元素和行级元素区别
块级元素可以设置宽高
行级元素，除了自代宽高属性的标签，
其他行级元素，设置宽高无效
margin-top,margin-bottom对行级元素无效
</code></pre><p><strong><br>选择器补充</strong></p>
<pre><code>伪类选择器
:hover
当鼠标悬浮在标签上，使用此样式
</code></pre><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript?"></a>什么是JavaScript?</h2><p>JavaScript是运行的客户端的解释性脚本语言。</p>
<p>客户端是浏览器(包括:IE、Firefox、Chrome、Safari、Opera)</p>
<p>解释性脚本是指程序语言的一种执行方式;</p>
<p>JavaScript与Java之间不存在任何关系;</p>
<p>JavaScript最早由网景公司在 1995 年发行的 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript.</p>
<p>Microsoft在其IE浏览器推出JScript与其抗衡.</p>
<p>欧洲计算机制造商协会(ECMA)在借鉴JavaScript1.5的基础上推出</p>
<p>ECMAScript,从而成为所有脚本语言的标准.</p>
<p>ECMAScript(ES)最新的版本为ECMAScript-6(简称ES6)</p>
<h2 id="JavaScript的语法结构"><a href="#JavaScript的语法结构" class="headerlink" title="JavaScript的语法结构"></a>JavaScript的语法结构</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   ...
   ...
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径及名称&quot;&gt;&lt;/script&gt;
</code></pre><p>第一步:创建JS文件并且写入相关的代码;</p>
<p>第二步:在网页文件内调用相关的JS文件;</p>
<p>说明:</p>
<pre><code>A.JS严格区分大小写;

B.每行JS代码必须以分号结尾;

C.JavaScript文件的扩展名为.js
</code></pre><h2 id="变量-Varaible"><a href="#变量-Varaible" class="headerlink" title="变量(Varaible)"></a>变量(Varaible)</h2><p>变量是指存储在计算机内存中有名称的信息,其值在程序运行期间可以发生变化;</p>
<p>声明变量</p>
<p>var 变量名称;</p>
<p>var 变量名称 = 值;</p>
<h3 id="变量名称的命名规范"><a href="#变量名称的命名规范" class="headerlink" title="变量名称的命名规范"></a>变量名称的命名规范</h3><pre><code>A.变量名称必须以字母或下划线开头,包含字母、数字及下划线;

B.变量名称禁止与系统关键字相同;

C.变量名称必须遵守&quot;驼峰标记法&quot;;

D.变量名称必须含义明确;
</code></pre><h3 id="JavaScript关键字"><a href="#JavaScript关键字" class="headerlink" title="JavaScript关键字:"></a>JavaScript关键字:</h3><p>var、if、else、switch、case、break、default、for、while、function</p>
<p>ECMAScript关键字:</p>
<p>class、float、boolean、object、extends、public、protected、private、interface、abstract、implements</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符型-string"><a href="#字符型-string" class="headerlink" title="字符型(string):"></a>字符型(string):</h3><p>必须括在双引号或单引号之间;</p>
<pre><code>转义符:
\n,换行
\r,回车
\t,水平制表符
\v,垂直制表符
\f,换页(走纸)
\\,反斜线
\&apos;,单引号
\&quot;,双引号
</code></pre><h3 id="数值型-number"><a href="#数值型-number" class="headerlink" title="数值型(number)"></a>数值型(number)</h3><p>包括整型和浮点型,可以带有符号位,可存储八进制、十进制、十六进制的数字;</p>
<p>八进制的表示方法为0[0-7]+</p>
<p>十六进制的表示方法0[x|X][0-9a-fA-F]+</p>
<h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型(boolean)"></a>布尔型(boolean)</h3><p>只能存储true或false</p>
<h3 id="未定义-undefined"><a href="#未定义-undefined" class="headerlink" title="未定义(undefined)"></a>未定义(undefined)</h3><p>值只能为undefined</p>
<pre><code>以下变量的值为undefined

A.声明但没有赋值的变量;

B.声明但赋值为undefined的变量;

C.引用对象不存在的属性;
</code></pre><h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h3><p>属性与方法的集合体;</p>
<pre><code>{
    propert:value,
    ....,
    method:function([parameter,...]){
        ...
        ...
    }
}
</code></pre><h3 id="null-空对象"><a href="#null-空对象" class="headerlink" title="null(空对象)"></a>null(空对象)</h3><p>其作用是为断开继承链(原型链);</p>
<h3 id="function-自定义函数"><a href="#function-自定义函数" class="headerlink" title="function(自定义函数)"></a>function(自定义函数)</h3><p>可以重复执行的代码段;</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="按作用划分"><a href="#按作用划分" class="headerlink" title="按作用划分"></a>按作用划分</h3><p>1 字符运算符: + </p>
<p>2 数学运算符:+(正号)、-(负号)、*、/、%、+、-</p>
<p>3 比较运算符:&gt;、&gt;=、==(等于)、!=(不等于)、===、!==(不全等)、&lt;=、&lt;</p>
<p>  全等:(1)值相同(2)数据类型相同</p>
<p>4 逻辑运算符:!、&amp;&amp;、||  </p>
<p>  短路现象:在进行&amp;&amp;或||运算时,只有第一个表达式的值可以</p>
<p>  确定整个表达式结果时,后续表达式将忽略执行;</p>
<p>5 自增/自减运算符</p>
<p>  i++、i–,后缀形式:先使用,后加减</p>
<p>  ++i、–i,前缀形式:先加减,后使用</p>
<p>6 赋值运算符:=、+=、-=、*=、/=、%=</p>
<h3 id="按参加运算的操作数的数量"><a href="#按参加运算的操作数的数量" class="headerlink" title="按参加运算的操作数的数量"></a>按参加运算的操作数的数量</h3><ul>
<li><p>单目运算符:只有一个操作数,如负数(-)、逻辑非(!)</p>
</li>
<li><p>双目运算符:有两个操作数,如加号(+)、大于(&gt;)等</p>
</li>
<li><p>三目运算符:expression ? value1 : value2</p>
</li>
</ul>
<p><strong>运算符优先级</strong></p>
<p>一、二、三、赋值</p>
<p>算术、比较、逻辑</p>
<p>案例:</p>
<pre><code>var p = !true || 3 + 2 - 5 &lt;= 7
        false || 3 + 2 - 5 &lt;= 7
        false || 0 &lt;= 7
        false || true
        true
</code></pre><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre><code>if(condition){
   ...
   ...
}

if(condition){
    ...
    ...
} else {
    ...
    ...
}

if(condition){
    ...
} else if(condition){
    ... 
} else if(condition){
    ...
} ... else{
    ...
}
</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><pre><code>switch(expression){
    case 值1:
       ...
       break;
    case 值2:
       ...
       break;
    case N
       break;
    default:
       ...
       break;
}
</code></pre><p>说明:</p>
<p>A. if语句的条件表达式只能为布尔型(可能存在数据类型的自动转换)</p>
<p>   switch语句的表达式可以为任意数据类型(布尔除外)</p>
<p>B. if语句每次执行时都将对变量进行取值操作;而switch只进行一次取值操作;</p>
<p>C. switch语句进行全等运算;</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>1 for语句</p>
<pre><code>for(expr1;expr2;expr3){
    ...
}
</code></pre><p>  说明:</p>
<p>  expr1,在循环之前无条件执行一次,一般于变量初始化;</p>
<p>  expr2,在循环前执行一次,以判断能否进入循环体;</p>
<p>  expr3,在循环后执行一次,一般用于步长的计算;</p>
<p>  for语句的表达式可以省略其中任何一个或全部;</p>
<p>2 while语句</p>
<pre><code>while(条件表达式){
   ...
   ...
}
</code></pre><p>  说明:</p>
<p>  A.死循环:指条件永远为真的循环语句.</p>
<p>  B.for语句和while语句同属”当型循环(先判断,后执行)”,所以可以互换;</p>
<p>3 do…while循环</p>
<pre><code>do{
  ...
  ...
} while(条件表达式);
</code></pre><p>  说明:</p>
<p>  A.do…while是先执行,后判断;</p>
<p>  B.do…while语句至少执行一次;而当型循环(for、while)至少执行零次;</p>
<p>4 for…in语句</p>
<pre><code>for(key in array){
    ...
    ...
}
</code></pre><p>5 break语句:结束switch及循环语句 </p>
<p>6 continue语句:跳过当前的循环而进行下一次的循环</p>
<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="构建String对象"><a href="#构建String对象" class="headerlink" title="构建String对象"></a>构建String对象</h4><p>   直接量方式 </p>
<p>   ‘string’或”string”</p>
<p>   构造函数方式</p>
<pre><code>new String(&apos;string&apos;)
</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>   length</p>
<p>   描述:返回字符串的长度</p>
<p>   语法:int object.length</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>   toLowerCase()</p>
<p>   描述:将字符转换小写字母</p>
<p>   语法:</p>
<pre><code>string object.toLowerCase(void)
</code></pre><hr>
<p>   toUpperCase()</p>
<p>   描述:将字符转换大写字母</p>
<p>   语法：</p>
<pre><code>string object.toUpperCase(void)
</code></pre><hr>
<p>   substr()</p>
<p>   描述:截取字符串</p>
<p>   语法:</p>
<pre><code>string object.substr(int start[,int length])
</code></pre><p>   说明:</p>
<p>   A.字符串从0开始编号;</p>
<p>   B.如果省略length参数,则返回到字符串结尾之间的字符</p>
<p>   C.如果start参数为负数,则倒数;</p>
<hr>
<p>   substring</p>
<p>   描述:截取字符串</p>
<p>   语法:string object.substring(int start[,int end])</p>
<p>   说明:</p>
<p>   A.返回的字符串包含起始位,不包含结束位;</p>
<p>   B.如果省略end参数,则返回到字符串结尾之间的字符;</p>
<hr>
<p>   indexOf()</p>
<p>   描述:返回字符串第一次出现的位置,如果没有出现,则返回-1</p>
<p>   语法:int object.indexOf(string)</p>
<hr>
<p>   lastIndexOf()</p>
<p>   描述:返回字符串最后一次出现的位置,如果没有出现,则返回-1</p>
<p>   语法:int object.lastIndexOf(string)</p>
<hr>
<p>   replace()方法</p>
<p>   描述:字符串替换</p>
<p>   语法:</p>
<p>   string object.replace(string search,string replacement)</p>
<p>   string object.replace(object RegExp,string replacement)</p>
<hr>
<p>   split()</p>
<p>   描述:使用分隔符拆分字符串</p>
<p>   语法:</p>
<p>   array object.split(delimiter)</p>
<p>   array object.split(RegExp)   </p>
<h4 id="ES6新增方法"><a href="#ES6新增方法" class="headerlink" title="ES6新增方法"></a>ES6新增方法</h4><p>   trim()</p>
<p>   描述:删除第一个之前及最后一个字符之后的空白</p>
<p>   语法:string object.trim(void)</p>
<hr>
<p>   startsWith()</p>
<p>   描述:检测字符是否以指字符开头</p>
<p>   语法:bool object.startsWith(string)</p>
<hr>
<p>   endsWith()</p>
<p>   描述:检测字符是否以指字符结尾</p>
<p>   语法:bool object.endsWith(string)</p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p>  Math对象是一个静态对象.</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>  Math.PI,圆周率</p>
<p>  Math.SQRT2,2的平方根</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>  Math.ceil()</p>
<p>  描述:进一取整</p>
<p>  语法:number Math.ceil(number)</p>
<hr>
<p>  Math.floor()</p>
<p>  描述:舍一取整</p>
<p>  语法:number Math.floor(number)</p>
<hr>
<p>  Math.pow()</p>
<p>  描述:幂运算</p>
<p>  语法:number Math.pow(base,exp)</p>
<hr>
<p>  Math.sqrt()</p>
<p>  描述:平方根</p>
<p>  语法:number Math.sqrt(number)</p>
<hr>
<p>  Math.min()</p>
<p>  描述:最小值</p>
<p>  语法:number Math.min(num1,num2,…)</p>
<hr>
<p>  Math.max()</p>
<p>  描述:最大值</p>
<p>  语法:number Math.max(num1,num2,…)</p>
<hr>
<p>  Math.random()</p>
<p>  描述:产生介于0~1之间的随机数(0&lt;=X&lt;1)</p>
<p>  语法:number Math.random(void)</p>
<hr>
<p>  Math.round()</p>
<p>  描述:四舍五入(仅保留到整数位置)</p>
<p>  语法:number Math.round(number)</p>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><h4 id="构建Date对象"><a href="#构建Date对象" class="headerlink" title="构建Date对象"></a>构建Date对象</h4><p>   new Date()</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>   getYear()</p>
<p>   描述:获取年份(从公元1900到现在经历的年份)</p>
<p>   语法:int object.getYear(void)</p>
<hr>
<p>   getFullYear()</p>
<p>   描述:获取年份</p>
<p>   语法:int object.getFullYear(void)</p>
<hr>
<p>   getMonth()</p>
<p>   描述:获取月份(取值范围为0~11)</p>
<p>   语法:int object.getMonth(void)</p>
<hr>
<p>   getDate()</p>
<p>   描述:获取日期(xx号)</p>
<p>   语法:int object.getDate(void)</p>
<hr>
<p>   getDay()</p>
<p>   描述:获取星期的第几天(0为星期日,依次类推)</p>
<p>   语法:int object.getDay(void)</p>
<hr>
<p>   getHours()</p>
<p>   描述:获取小数</p>
<p>   语法:int object.getHours(void)</p>
<hr>
<p>   getMinutes()</p>
<p>   描述:获取分钟数</p>
<p>   语法:int object.getMinutes(void)</p>
<hr>
<p>   getSeconds()</p>
<p>   描述:获取秒数</p>
<p>   语法:int object.getSeconds(void)</p>
<hr>
<p>   getMilliseconds()</p>
<p>   描述:获取毫秒</p>
<p>   语法:int object.getMilliseconds(void)</p>
<hr>
<p>   getTime()</p>
<p>   描述:返回从公元1970年到现在的毫秒数</p>
<p>   语法:int object.getTime(void)</p>
<hr>
<p>   toUTCString()/toGMTString()</p>
<p>   描述:将日期转换成UTC/GMT格式</p>
<p>   语法:string object.toUTCString(void)</p>
<pre><code>string object.toGMTString(void)
</code></pre><h4 id="ES6新增的方法"><a href="#ES6新增的方法" class="headerlink" title="ES6新增的方法"></a>ES6新增的方法</h4><pre><code>Date.now() 静态方法

描述:返回从公元1970年到现在的毫秒数

语法:int Date.now(void)

说明:该方法为静态方法
</code></pre><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="构建Array对象"><a href="#构建Array对象" class="headerlink" title="构建Array对象"></a>构建Array对象</h4><p>   直接量方式</p>
<p>   [value,…]</p>
<p>   构造函数方式</p>
<p>   new Array(length)</p>
<p>   new Array(value,…)</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>   length</p>
<p>   描述:获取数组成员的数量</p>
<p>   语法:int object.length</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><p>   unshift()</p>
<p>   描述:在数组的开头添加一个或多个成员,并返回数组的新长度</p>
<p>   语法:int object.unshift(value,…)</p>
<hr>
<p>   push()</p>
<p>   描述:在数组的未尾添加一个或多个成员,并返回数组的新长度</p>
<p>   语法:int object.push(value,…)</p>
<hr>
<p>   shift() </p>
<p>   描述:删除数组的第一个成员,并且返回该成员</p>
<p>   语法:mixed object.shift(void)  </p>
<hr>
<p>   pop()</p>
<p>   描述:删除数组的最后一个成员,并且返回该成员</p>
<p>   语法:mixed object.pop(void)     </p>
<hr>
<p>   join()</p>
<p>   描述:    将数组成员使用指定分隔符连接成字符串</p>
<p>   语法:string object.join(delimiter)</p>
<hr>
<p>   isArray()</p>
<p>   描述:判断是否为数组(静态方法) </p>
<p>   语法:bool Array.isArray(obj)</p>
<h4 id="数组遍历-–-forEach-语句"><a href="#数组遍历-–-forEach-语句" class="headerlink" title="数组遍历 – forEach()语句"></a>数组遍历 – forEach()语句</h4><pre><code>object.forEach(function(value[,index]){
        ...
        ...
});
</code></pre><h3 id="Regular-Expression对象-正则表达式对象"><a href="#Regular-Expression对象-正则表达式对象" class="headerlink" title="Regular Expression对象(正则表达式对象)"></a>Regular Expression对象(正则表达式对象)</h3><p>构建正则表达式对象</p>
<p>  直接量方式</p>
<p>  /正则表达式/修正符</p>
<p>  构造函数方式</p>
<p>  new RegExp(‘正则表达式’,’修正符’)</p>
<p>正则表达式</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>   \d,匹配数字,等价于[0-9]</p>
<p>   \D,匹配非数字,等价于[^0-9]</p>
<p>   \s,匹配任意的空白字符,等价于[\n\r\t\v\f]</p>
<p>   \S,匹配任意的非空白字符,等价于[^\n\r\t\v\f]</p>
<p>   \w,匹配任意的字母、数字及下划线,等价于[0-9a-zA-Z_]</p>
<p>   \W,匹配任意的非字母、数字及下划线,等价于[^0-9a-zA-Z_]</p>
<p>   ., 匹配除换行外的任意字符</p>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>   ?,出现零次或一次,等价于{0,1}</p>
<p>   *,至少出现零次,等价于{0,}</p>
<p>   +,至少出现一次,等价于{1,}</p>
<p>   {m},出现m次</p>
<p>   {m,},至少出现m次</p>
<p>   {m,n},至少出现m次,至多n次(m&lt;=x&lt;=n)</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>   |,或者</p>
<p>   ^,以指定字符开头</p>
<p>   $,以指定字符结尾</p>
<p>   […],表示在范围之内,如[0-9]</p>
<p>   [^…],表示不在范围之内,如[^3-5]</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>   \n,换行</p>
<p>   \r,回车</p>
<p>   \t,水平制表符</p>
<p>   \v,垂直制表符</p>
<p>   \f,换页(走纸)</p>
<p>   \,反斜线</p>
<p>   .,点</p>
<p>   |,竖线</p>
<p>   *,星号</p>
<p>   \?,问号</p>
<h4 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h4><p>   (…)</p>
<p>   (?:…)</p>
<h4 id="修正符"><a href="#修正符" class="headerlink" title="修正符"></a>修正符</h4><p>   g(global),全局</p>
<p>   i(ignore),忽略大小写</p>
<p><strong>方法</strong></p>
<p>  test()</p>
<p>  描述:检测字符串是否符合正则表达式规范</p>
<p>  语法:bool object.test(string)</p>
<h1 id="前端编程"><a href="#前端编程" class="headerlink" title="前端编程"></a>前端编程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><pre><code>DOM(Document Object Model),文档对象模型

JavaScript由ECMAScript(简称ES)、DOM和BOM组成;

ECMAScript:关键字、保留关键字、流程语句、数据类型、内置对象;

DOM:提供操作HTML/XML文档相关的API;

DOM由DOM Core、HTML DOM和XML DOM组成;

DOM Core:提供处理HTML和XML文档的API;

HTML DOM:提供处理HTML文档的API;

XML DOM:提供处理XML文档的API;
</code></pre><p><strong>在DOM树中一切皆节点;</strong></p>
<h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><pre><code>1,代表元素节点(指HTML标记)

2,代表属性节点(指HTML标记的属性)

3,代表文本节点(指纯文本)

8,代表注释节点(指HTML注释)

9,代表文档节点(指整个HTML文档)
</code></pre><h3 id="节点的关系"><a href="#节点的关系" class="headerlink" title="节点的关系"></a>节点的关系</h3><p>子节点:一个节点是另一个节点的直接下一级节点;</p>
<p>如</p>
<pre><code>&lt;i&gt;&lt;b&gt;...&lt;/b&gt;&lt;/i&gt;
</code></pre><p>父节点:一个节点是另一个节点的直接上一级节点;</p>
<p>兄弟节点:同一个父节点的所有子节点</p>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><p>  <strong>nodeName</strong></p>
<p>  描述:获取节点的名称</p>
<p>  语法:string node.nodeName<br><strong><br>  nodeValue</strong></p>
<p>  描述:获取节点值</p>
<p>  语法:string node.nodeValue</p>
<p>  <strong>nodeType</strong></p>
<p>  描述:获取节点的类型</p>
<p>  语法:int node.nodeType</p>
<p>  <strong>childNodes</strong></p>
<p>  描述:返回节点内所有的子节点形成的集合(数组)</p>
<p>  语法:NodeList node.childNodes</p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><p>  appendChild()</p>
<p>  描述:追加子节点</p>
<p>  语法:Node node.appendChild(node)                </p>
<p>  说明:返回的是新插入的子节点</p>
<hr>
<p>  removeChild()</p>
<p>  描述:删除子节点</p>
<p>  语法:Node node.removeChild(node)</p>
<h2 id="document对象-继承自Node"><a href="#document对象-继承自Node" class="headerlink" title="document对象(继承自Node)"></a>document对象(继承自Node)</h2><h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><p>  documentElement</p>
<p>  描述:返回文档的根元素</p>
<p>  语法:Element document.documentElement</p>
<h3 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h3><p>  getElementById()</p>
<p>  描述:根据对象ID来获取元素</p>
<p>  语法:Element document.getElementById(string id)</p>
<hr>
<p>  createElement()</p>
<p>  描述:创建元素节点</p>
<p>  语法:Element document.createElement(string tagName)</p>
<h2 id="Element对象-继承自Node"><a href="#Element对象-继承自Node" class="headerlink" title="Element对象(继承自Node)"></a>Element对象(继承自Node)</h2><h3 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h3><p>  getAttribute()</p>
<p>  描述:获取属性值</p>
<p>  语法:string Element.getAttribute(string name)</p>
<hr>
<p>  setAttribute()</p>
<p>  描述:设置属性</p>
<p>  语法:void Element.setAttribute(string name,string value)</p>
<hr>
<p>  removeAttribute()</p>
<p>  描述:删除属性</p>
<p>  语法:void Element.removeAttribute(string name)</p>
<hr>
<p>  hasAttribute()</p>
<p>  描述:返回是否存在指定属性</p>
<p>  语法:bool Element.hasAttribute(string name)</p>
<h2 id="HTML-与-DOM"><a href="#HTML-与-DOM" class="headerlink" title="HTML 与 DOM"></a>HTML 与 DOM</h2><p> HTML DOM提供针对处理HTML文档的API.</p>
<p><strong>1 选取对象</strong></p>
<pre><code>Element document.getElementById(string id)

NodeList document.getElementsByTagName(string tagName)

NodeList Element.getElementsByTagName(string tagName)
</code></pre><p><strong>2 属性控制</strong></p>
<pre><code>A.对于单个单词的HTML标记属性即HTML DOM对象属性;

B.对于合成词的HTML标记属性(如table标记的cellpading、cellspacing属性)在HTML DOM编程时,采用&quot;驼峰标记法&quot;命名(如cellPadding、cellSpacing)

C.对于HTML标记的class属性,在HTML DOM编程时使用className取代;
  (因为class是ECMAScript中的关键字)

D.对于HTML标记的布尔属性(如单/复选框的checked、列表项的selected属性)在HTML DOM编程时采用boolean类型表示;

E.在HTML DOM编程时,某些HTMLDOM对象有自己特有的属性/方法;

F.HTML标记的style属性在HTML DOM编程时形成CSSStyleDeclaration/CSS2Properties对象;
</code></pre><p><strong>3 HTMLDocument对象</strong></p>
<p>  getElementsByName()方法</p>
<p>  描述:获取文档中name属性相同的对象的组成的集合(数组)</p>
<p>  语法:NodeList document.getElementsByName(string name)</p>
<h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><h4 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h4><p><strong>title</strong></p>
<p>描述:获取/设置标题栏信息</p>
<p>语法: document.title = value 或 var 变量名称 = document.title</p>
<p><strong>head</strong></p>
<p>描述:获取文档的head对象</p>
<p>语法:Element document.head</p>
<p><strong>body</strong></p>
<p>描述:获取文档的body对象</p>
<p>语法:Element document.body</p>
<p><strong>images</strong></p>
<p>描述:返回文档中所有的图像组成的集合(数组)</p>
<p>语法:NodeList document.images</p>
<p><strong>forms</strong></p>
<p>描述:返回文档中所有的表单组成的集合(数组)</p>
<p>语法:NodeList document.forms</p>
<p><strong>links</strong></p>
<p>描述:返回文档中所有的<link>标记组成的集合(数组)</p>
<p>语法:NodeList document.links</p>
<p><strong>anchors</strong></p>
<pre><code>描述:返回文档中所有的&lt;a&gt;标记组成的集合(数组)

语法:NodeList document.anchors
</code></pre><hr>
<h4 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h4><p><strong>querySelectorAll()</strong></p>
<p>描述:返回由使用指定的CSS选择器的对象组成的集合(数组)</p>
<p>语法:NodeList document.querySelectorAll(selector)</p>
<p>说明:该方法支持所有CSS3选择器</p>
<p><strong>querySelector()</strong></p>
<p>描述:返回由使用指定的CSS选择器的对象的第一个元素</p>
<p>语法:Element document.querySelector(selector)</p>
<h3 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h3><p><strong>属性</strong></p>
<p>tagName</p>
<p>描述:获取元素的标记名称</p>
<p>语法:string Element.tagName</p>
<p><strong>方法</strong></p>
<p>querySelector()</p>
<p>描述:返回由使用指定的CSS选择器的对象的第一个元素</p>
<p>语法:Element  Element.querySelector(selector)</p>
<p>querySelectorAll()</p>
<p>描述:返回由使用指定的CSS选择器的对象组成的集合(数组)</p>
<p>语法:NodeList Element.querySelectorAll(selector)</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="BOM定义"><a href="#BOM定义" class="headerlink" title="BOM定义"></a>BOM定义</h3><p>BOM(Browser Object Model),浏览器对象模型,提供与浏览器相关的API.</p>
<p>  window对象是BOM的顶级对象,代表浏览器窗口或iframe或frame.</p>
<h3 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h3><p>  document 描述:返回HTMLDocument对象</p>
<p>  history  描述:返回History对象</p>
<p>  screen 描述:返回Screen对象</p>
<p>  navigator 描述:返回Navigator对象</p>
<p>  location 描述:返回Location对象</p>
<p>  Math 描述:返回Math对象</p>
<h3 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h3><p>  alert()方法</p>
<p>  描述:弹出警示对话框(只有一个确定按钮)</p>
<p>  语法:window.alert(string)</p>
<hr>
<p>  confirm()方法</p>
<p>  描述:弹出询问对话框(有确定和取消两个按钮)</p>
<p>  语法:bool window.confirm(string)</p>
<hr>
<p>  setInterval()</p>
<p>  描述:每间隔指定的时间执行相关的代码(重复执行)</p>
<p>  语法:int window.setInterval(function,milliseconds)</p>
<hr>
<p>  clearInterval()</p>
<p>  描述:清除由setInterval()设置的timeId</p>
<p>  语法:window.clearInterval(int timeId)</p>
<hr>
<p>  setTimeout()  </p>
<p>  描述:间隔指定的时间后执行相关的代码(执行一次)</p>
<p>  语法:int window.setTimeout(function,milliseconds)</p>
<hr>
<p>  clearTimeout()</p>
<p>  描述:清除由setTimeout()设置的timeId</p>
<p>  语法:window.clearTimeout(int timeId)</p>
<hr>
<p>  parseInt()</p>
<p>  描述:转换成整数</p>
<p>  语法:int parseInt(value)</p>
<hr>
<p>  parseFloat()</p>
<p>  描述:转换成浮点数</p>
<p>  语法:int parseFloat(value)</p>
<hr>
<p>  isNaN()</p>
<p>  描述:检测值是否为NaN(Not a Number)</p>
<p>  语法:bool isNaN(value)</p>
<h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><p>  href属性</p>
<p>  描述:获取/设置地址栏中的地址信息</p>
<p>  语法:</p>
<p>  location.href = string</p>
<p>  var 变量名称 = location.href</p>
<p>  search属性</p>
<p>  描述:获取地址栏”?”以后所有的参数</p>
<p>  语法:string location.search</p>
<p>  reload()</p>
<p>  描述:重新加载文档</p>
<p>  语法:location.reload(void)</p>
<h3 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h3><p>  width属性</p>
<p>  描述:获取显示分辨率宽度</p>
<p>  语法:number screen.width</p>
<p>  height</p>
<p>  描述:获取显示分辨率高度</p>
<p>  语法:number screen.height</p>
<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><p>  back()</p>
<p>  描述:后退一步</p>
<p>  语法:history.back(void)</p>
<p>  forward()</p>
<p>  描述:前进一步</p>
<p>  语法:history.forward(void)</p>
<p>  go()</p>
<p>  描述:前进/后退</p>
<p>  语法:history.go(number)</p>
<p>  说明:如果为负数,则后退;否则前进;</p>
<p>  history.back() 等价于 history.go(-1)</p>
<p>  history.forward() 等价于 history.go(1)  </p>
<h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><p>  userAgent属性(简称UA)</p>
<p>  描述:返回代理器信息</p>
<p>  语法:string navigator.userAgent</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON基础</p>
<p>  JSON(JavaScript Object Notation),是一种轻量级的数据交换格式;</p>
<p>  JSON的官网  <a href="http://www.json.org" target="_blank" rel="noopener">http://www.json.org</a></p>
<p>JSON支持的数据格式</p>
<p>  数组:[value,….]</p>
<p>  对象:{property:value,….}</p>
<h2 id="jQuery操作DOM"><a href="#jQuery操作DOM" class="headerlink" title="jQuery操作DOM"></a>jQuery操作DOM</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>语法：$(&quot;创建的完整标记&quot;);
ex:
    1、创建一对div元素
        var $div = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;);
        $div.html(&quot;&lt;h1&gt;...&lt;/h1&gt;&quot;);
        $div.attr(&quot;id&quot;,&quot;container&quot;);
    2、创建一个图像标记
        var $img = $(&quot;&lt;img&gt;&quot;);
        $img.attr(&quot;src&quot;,&quot;img/a.jpg&quot;);
</code></pre><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><pre><code>1、内部插入
    作为子元素插入到网页中
    1、$obj.append($new);
        将$new元素追加到$obj元素的尾部(最后一个子元素)
    2、$obj.prepend($new);
        将$new元素添加到$obj元素的头部(第一个子元素)
2、外部插入
    作为兄弟元素插入到网页中
    1、$obj.before($new)
        将$new作为$obj的上一个兄弟元素插入进来
    2、$obj.after($new)
        将$new作为$obj的下一个兄弟元素插入进来
</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code>1、remove()
    语法：$obj.remove();
    作用：删除 $obj 元素
2、remove(&quot;selector&quot;)
    语法：$obj.remove(&quot;selector&quot;);
    作用：将满足 selector 选择器的元素删除出去
3、empty()
    语法：$obj.empty()
    作用：清空$obj内的内容
</code></pre><h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><pre><code>1、children() / children(selector)
    作用：获取某对象中的子元素(只考虑元素节点)或满足selector选择器的子元素(只考虑元素节点)。
    注意：只能获取子元素，不能获取后代元素
2、next() / next(selector)
    作用：获取某对象的下一个兄弟元素 / 满足selector的下一个兄弟元素
3、prev() / prev(selector)
    作用：获取某对象的上一个兄弟元素 / 满足selector的上一个兄弟元素
4、siblings() / siblings(selector)
    作用：获取某对象的所有兄弟元素 / 满足selector的兄弟元素
5、find(selector)
    查找满足selector选择器的所有后代元素
6、parent()
    作用：获取某对象的父元素
</code></pre><h3 id="jQuery事件处理"><a href="#jQuery事件处理" class="headerlink" title="jQuery事件处理"></a>jQuery事件处理</h3><h4 id="页面加载后的执行"><a href="#页面加载后的执行" class="headerlink" title="页面加载后的执行"></a>页面加载后的执行</h4><pre><code>在DOM树加载完成后就要执行的操作
1、
    $(document).ready( function(){
        //页面的初始化操作
        //DOM树加载完毕后就开始运行
    } );

2、
    $().ready( function(){

    } );
3、
    $( function(){

    });
</code></pre><h4 id="jQuery的事件绑定"><a href="#jQuery的事件绑定" class="headerlink" title="jQuery的事件绑定"></a>jQuery的事件绑定</h4><pre><code>1、方式1
    $obj.bind(&quot;事件名称&quot;,事件处理函数);

    ex:
        $obj.bind(&quot;click&quot;,function(){
            alert(&quot;单击事件&quot;);
        });

2、方式2
    $obj.事件名称(事件处理函数);

    ex:
        $obj.click(function(){

        });

注意：
    在事件处理函数中，允许使用 this 来表示触发当前事件的DOM对象
</code></pre><h4 id="事件参数对象-事件对象"><a href="#事件参数对象-事件对象" class="headerlink" title="事件参数对象(事件对象):"></a>事件参数对象(事件对象):</h4><pre><code>1、获取事件对象
    1、
        &lt;button onclick=&quot;btnClick(event)&quot;&gt;&lt;/button&gt;

        function btnClick(event){

        }
    2、
        &lt;button id=&quot;btnTest&quot;&gt;&lt;/button&gt;

        var btn = document.getElementById(&quot;btnTest&quot;);
        btn.onclick = function(event){
            event : 表示当前事件的事件对象
        }


2、事件对象的属性
    1、offsetX
        获取鼠标所操作的点的 横坐标值
    2、offsetY
        获取鼠标所操作的点的 纵坐标值
    3、target
        获取事件源(事件所在的元素)
</code></pre><p><strong>this:</strong><br>1、this 在全局函数中，永远都表示的是 window 对象<br>2、this 在局部函数中，表示都是函数的所有者<br>    btn.onclick = function(){<br>        this:表示的就是函数的所有者 -&gt; btn </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/网络通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/网络通信/" itemprop="url">网络通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T18:53:02+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17,530 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  71 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络起源 （了解）</p>
<p>网络目的 ： 数据的传输</p>
<p>ISO ： 国际标准化组织</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>—-》 网络通信的标准化流程</p>
<p><strong>应用层 ： 提供用户服务，具体的内容由特定程序规定<br>表示层 ： 数据的压缩优化加密<br>会话层 ： 建立应用连接，选择传输层服务<br>传输层 ： 提供数据传输服务，流量控制<br>网络层 ： 路由选择，网络互连<br>链路层 ： 提供链路交换，具体的消息的发送<br>物理层 ： 物理硬件，接口 网卡的规定 </strong></p>
<p><strong>osi模型优点</strong> ：<br> 将功能分开，降低网络传输中的耦合度每一部分完成自己的功能，开发更加清晰专一</p>
<p><strong>四层模型</strong></p>
<ul>
<li>应用层 ：  应用层 表示层  会话层</li>
<li>传输层 ：  传输层</li>
<li>网络层 ：  网络层</li>
<li>物理链路层：   链路层  物理层</li>
</ul>
<p><strong>五层模型（tcp/ip模型）</strong></p>
<ul>
<li>应用层 ：  应用层 表示层  会话层</li>
<li>传输层 ：  传输层</li>
<li>网络层 ：  网络层</li>
<li>链路层 ：  链路层  </li>
<li>物理层 ：  物理层</li>
</ul>
<p><strong>要求 ： </strong></p>
<p>能够按顺序说出七层模型 五层和四层模型<br>知道每一层是什么作用<br>对网络消息传输流程有基本了解</p>
<p><strong>协议 ：</strong><br>网络通信中，各方必须遵守的规定。包括建立什么样的连接，消息结构等。</p>
<ul>
<li>应用层 ： TFTP  HTTP  DNS  SMTP</li>
<li>传输层 ： TCP  UDP</li>
<li>网络层 ： IP</li>
<li>物理层 ： IEEE</li>
</ul>
<p>网络相关概念</p>
<p><strong>主机 ：</strong> host  表示一台计算机</p>
<p>本地使用 ：  ‘localhost’<br> ‘’<br> ‘127.0.0.1’<br>网络使用 ： ‘0.0.0.0’<br> ‘172.60.50.60’  本机ip地址，自己的电脑可以ipconfig或者ifconfig查看</p>
<p><strong>获取计算机名：</strong><br>In [2]: socket.gethostname()<br>Out[2]: ‘godshion’</p>
<p>通过计算机名获取地址：<br>In [3]: socket.gethostbyname(‘godshion’)<br>Out[3]: ‘127.0.1.1’</p>
<p><strong>IP地址</strong></p>
<p>在网络上确定一台主机的地址<br>IPv4 ：点分十进制 比如 192.168.1.72  0–255<br>   32位二级制表示</p>
<p>IPv6 ： 128位二进制</p>
<p>查看本机Ip方法<br>windows    cmd.exe 窗口 –&gt; ipconfig<br>linux      查看本机地址 ifconfig</p>
<p><strong>网络连接测试</strong><br>ping  172.60.50.60</p>
<p>特殊IP<br>127.0.0.1   本地测试IP<br>0.0.0.0    使用局域网内可用的IP<br>192.168.1.0  表示当前网段<br>192.168.1.1  通常是网络节点设备的IP （网关）<br>192.168.1.255  广播地址</p>
<p>通过域名获取服务器信息<br> socket.gethostbyaddr(‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>)<br>(‘127.0.0.1’, [],    [‘119.75.213.61’])<br>   主机     主机别名   主机IP</p>
<p>将点分十进制IP转换为二进制<br>In [11]: socket.inet_aton(‘192.168.1.2’)<br>Out[11]: b’\xc0\xa8\x01\x02’<br>将二进制转换为点分十进制IP<br>In [12]: socket.inet_ntoa(b’\xc0\xa8\x01\x02’)<br>Out[12]: ‘192.168.1.2’</p>
<p>功能 ： 同上面两个完全相同。只是可以选择地址类型<br>inet_pton（socket.AF_INET,’192.168.1.2’）<br>inet_ntop（）</p>
<p>域名： 网络服务器地址的网络名称</p>
<p>端口号 ： 端口号是网络地址的一部分，在一个系统中 每个网络应用都会有一个端口号相对应。用来在接收消息时确定由谁来接收</p>
<p>范围 ： 1–65535<br>1–255 一些通用的众所周知程序占用<br>256-1023  系统应用端口<br>1024 — 65535   自用   &gt;10000 </p>
<p><strong>获取应用端口：</strong><br>In [16]: socket.getservbyname(‘mysql’)<br>Out[16]: 3306</p>
<p>字节序<br>数据在内存中的存储解析方式，不同操作系统可能不同</p>
<p>网络字节序 ： 不同的操作系统在消息收发时均按照该标准操作。</p>
<p>传输层服务</p>
<p>面向连接的传输服务  —-&gt; </p>
<h2 id="tcp协议-面向连接的传输服务"><a href="#tcp协议-面向连接的传输服务" class="headerlink" title="tcp协议   面向连接的传输服务"></a>tcp协议   面向连接的传输服务</h2><p><strong>传输特征：</strong></p>
<ul>
<li>可靠的数据传输</li>
<li>可靠性指数据传输中 无失序 无差错 无丢失  无重复</li>
<li>所有消息传输前一定会建立连接，传输后一定会断开连接</li>
</ul>
<p><strong>三次握手：</strong><br>在进行面向连接的数据传输前进行传输连接的过程</p>
<ol>
<li>客户端向服务器发送连接请求（问是否可以连接）</li>
<li>服务器接收到连接请求进行确认，返回报文</li>
<li>客户端收到回复，进行连接建立</li>
</ol>
<p><strong>四次挥手：</strong><br>在进行面向连接的数据传输时，断开连接的过程</p>
<ol>
<li>主动方发送报文 告知被动方要断开连接</li>
<li>被动方返回报文，告知收到请求，准备断开</li>
<li>被动方再次发送报文给主动方，告知准备完毕可以断开</li>
<li>主动方发送报文进行断开</li>
</ol>
<p>应用情况 ：适用于传输较大的内容或文件，网络情况良好，需要保证传输可靠性的情况<br>比如 ： 聊天信息，文件的上传下载，邮件传输 网页获取</p>
<h2 id="udp协议-面向无连接的传输服务"><a href="#udp协议-面向无连接的传输服务" class="headerlink" title="udp协议  面向无连接的传输服务"></a>udp协议  面向无连接的传输服务</h2><p><strong>传输特点：</strong></p>
<ul>
<li>不保证可靠的数据传输</li>
<li>没有连接过程</li>
<li>数据的收发都比较自由，不会受另一端制约</li>
</ul>
<p>适用情况： 网络情况较差，对传输可靠情形要求不高。需要提升传输效率的情况<br>比如 ： 网络视频，群聊，发送广播</p>
<p><strong>问题总结：</strong></p>
<ol>
<li>osi模型问题</li>
<li>三次握手四次挥手问题</li>
<li>tcp和udp的区别</li>
</ol>
<h2 id="socket套接字编程"><a href="#socket套接字编程" class="headerlink" title="socket套接字编程"></a>socket套接字编程</h2><p>目的 : 通过编程语言提供的函数接口进行组合，更简单的完成基于 tcp 或者udp通信的网路编程</p>
<p>套接字 ： 完成上述目标的一种编程方法</p>
<p>套接字分类</p>
<p>流式套接字（SOCK_STREAM）: 传输层基于tcp的协议进行通信</p>
<p>数据报套接字 （SOCK_DGRAM）：传输层基于udp协议进行通信</p>
<p>底层套接字 （SOCK_RAM）:访问底层协议的套接字</p>
<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><h3 id="1-创建套接字"><a href="#1-创建套接字" class="headerlink" title="1. 创建套接字"></a>1. 创建套接字</h3><pre><code>import  socket
socket.socket(socket_family = AF_INET，
              socket_type = SOCK_STREAM,
                            proto = 0)
</code></pre><p>功能 ： 创建一个套接字<br>参数 ： socket_family  : 选择地址族类型 AF_INET<br>socket_type ：套接字类型 SOCK_STREAM 流式 SOCK_DGRAM 数据报<br>proto ：子协议类型，没有子协议选择 0<br>返回值 ： 套接字对象</p>
<h3 id="2-绑定地址（IP-端口号）"><a href="#2-绑定地址（IP-端口号）" class="headerlink" title="2. 绑定地址（IP 端口号）"></a>2. 绑定地址（IP 端口号）</h3><pre><code>sockfd.bind()
</code></pre><p>功能 ： 绑定地址<br>参数 ：<br>一个元组包含两项<br>第一项为IP<br>第二项为端口号（’172.60.50.50’,8888）</p>
<h3 id="3-将套接字设置可监听"><a href="#3-将套接字设置可监听" class="headerlink" title="3. 将套接字设置可监听"></a>3. 将套接字设置可监听</h3><pre><code>sockfd.listen(n)
</code></pre><p>功能 ： 将套接字设置为监听套接字<br>参数 ： n是一个正整数 表示监听等待队列的大小</p>
<h3 id="4-等待接收连接请求"><a href="#4-等待接收连接请求" class="headerlink" title="4. 等待接收连接请求"></a>4. 等待接收连接请求</h3><pre><code>connfd,addr = sockfd.accept()
</code></pre><p>功能： 阻塞等待处理客户端连接<br>返回值 ：<br>第一个 ： 一个新的套接字用来和客户端通信<br>第二个 ： 连接的客户端的地址</p>
<p><strong>阻塞函数：</strong>程序运行到阻塞函数的位置，如果某种期待条件没有达成则暂停继续运行。当条件达成后会结束阻塞继续运行。</p>
<h3 id="5-收发消息"><a href="#5-收发消息" class="headerlink" title="5. 收发消息"></a>5. 收发消息</h3><pre><code>data = connfd.recv(buffersize)
</code></pre><p>功能 ： 流式套接字接收消息<br>参数 ： 一次最多接收多大的消息  字节<br>返回值 ： 返回接收到的内容</p>
<pre><code>n = connfd.send(data)
</code></pre><p>功能 ： 流式套接字发送消息<br>参数 ： 要发送的内容  要求bytes格式<br>返回值 ： 返回实际发送的字节数</p>
<h3 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6. 关闭套接字"></a>6. 关闭套接字</h3><pre><code>close（）
</code></pre><p>功能：关闭套接字 tcp套接字连接断开</p>
<h2 id="tcp-客户端"><a href="#tcp-客户端" class="headerlink" title="tcp 客户端"></a>tcp 客户端</h2><h3 id="1-创建套接字-1"><a href="#1-创建套接字-1" class="headerlink" title="1. 创建套接字"></a>1. 创建套接字</h3><pre><code>socket()
</code></pre><h3 id="2-请求连接"><a href="#2-请求连接" class="headerlink" title="2. 请求连接"></a>2. 请求连接</h3><pre><code>connect()
</code></pre><p>功能： 发起连接请求<br>参数： 是一个元组，表示服务器的地址</p>
<h3 id="3-消息收发"><a href="#3-消息收发" class="headerlink" title="3. 消息收发"></a>3. 消息收发</h3><pre><code>recv()  send()
</code></pre><h3 id="4-关闭套接字"><a href="#4-关闭套接字" class="headerlink" title="4. 关闭套接字"></a>4. 关闭套接字</h3><pre><code>close()
</code></pre><p>服务器端示例代码<br>        import socket</p>
<pre><code># from select_word import *

HOST  = &apos;127.0.0.1&apos;
PORT = 10889

# 创建套接字
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#param3: proto = 0
#这里设置端口重用，不然每次按ctrl+c取消程序的时候会出现端口被占用的错误
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
# socket_family = socket.AF_INET 选择地址族类型，AF_INET 是选择的ipv4
# socket_type = socket.SOCK_STREAM　套接字类型　　SOCK_STREAM是tcp协议
# proto 通常为０　子协议类型
# 返回一个套接字对象

# 绑定地址
s.bind((HOST,PORT))
# 参数只有一个，是二个元素的元组，分别为ip port

# 将套接字设置可监听
s.listen(1)
# 参数ｎ表示将听扽该队列的大小

# 等待接收请求
conn,addr = s.accept()
# 阻塞等待处理客户端连接，如果某种期待条件没有达成则暂停运行，条件达成继续运行
# 返回一个新的套接字用来和客户端通讯
# 连接的客户端的地址
print(&quot;client&apos;s Address:&quot;,addr)
# 收发消息
# while True:
    # 流式套接字接收消息，依次最多接收多大字节的消息，返回接收到的内容
while True:
    data = conn.recv(1024).decode(&quot;utf-8&quot;) 
    #recv函数在一方断开连接的情况下，会立即结束阻塞状态，并返回一个空字符串
    if not data :
        break
    print(&quot;Receive data: &quot;,data)
    # 流式套接字发送消息，参数是发送的内容，要求是bytes格式，返回发送的字节数量

    # result = searchword(data)
    # print(result)
    # conn.send(str(result).encode(&quot;utf-8&quot;)) 
    conn.send(data.encode(&quot;utf-8&quot;)) 
    #broken pipe　管道破裂．　
    #1,如果一端不存在，另一方还在企图发送消息时产生brokenpipeerrot
# 关闭套接字，连接断开
conn.close()
</code></pre><p>客户端代码：<br>        import socket<br>        HOST = “127.0.0.1”<br>        PORT = 10889</p>
<pre><code># 创建套接字
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#这里设置端口重用，不然每次按ctrl+c取消程序的时候会出现端口被占用的错误
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

# 创建连接
s.connect((HOST,PORT))
# 发起连接请求，参数是一个元组，表示服务器的地址　

data = &quot;hello&quot;
# s.send(&apos;aaa&apos;.encode(&quot;utf-8&quot;))
while data:
    # 消息收发
    s.send(data.encode(&quot;utf-8&quot;))
    data = s.recv(512)
    print(&apos;recv data is: &apos;,data)
    data = input(&apos;please input:  &apos;)


# 关闭套接字
s.close()
</code></pre><p>运行结果<br>        ~/桌面/web/tcp$ python3 server.py<br>        client’s Address: (‘127.0.0.1’, 52826)<br>        Receive data:  hello<br>        Receive data:  aaa<br>        Receive data:  bbb<br>        Receive data:  ccc<br>        Receive data:  ddd</p>
<pre><code>~/桌面/web/tcp$ python3 client.py 
recv data is:  b&apos;hello&apos;
please input:  aaa
recv data is:  b&apos;aaa&apos;
please input:  bbb
recv data is:  b&apos;bbb&apos;
please input:  ccc
recv data is:  b&apos;ccc&apos;
please input:  ddd
recv data is:  b&apos;ddd&apos;
please input:
</code></pre><p>作业 ： </p>
<ol>
<li>口述 什么是七层模型，tcp/ip模型<br>三次握手和四次挥手的过程<br>tcp协议的传输和udp协议的传输有何区别</li>
<li>将tcp程序改写为一个通过循环可连续收发消息的程序</li>
</ol>
<h3 id="recv-特性"><a href="#recv-特性" class="headerlink" title="recv() 特性"></a>recv() 特性</h3><ol>
<li>如果连接双方断开连接，则recv会立即结束阻塞返回空字符串</li>
<li>当接收缓冲区为空的时候会阻塞</li>
<li>如果recv一次接收不完缓存去内容，下一次会继续接收</li>
</ol>
<h3 id="send（）特性"><a href="#send（）特性" class="headerlink" title="send（）特性"></a>send（）特性</h3><ol>
<li>如果一段不存在，另一端还在试图send操作时会产生BrokenPipeError异常</li>
<li>当发送缓冲区慢的时候会阻塞</li>
</ol>
<h3 id="网络收发缓冲区"><a href="#网络收发缓冲区" class="headerlink" title="网络收发缓冲区"></a>网络收发缓冲区</h3><p>发送和接收消息均先放到缓冲区中，在进行处理<br>即 recv和send实际是从缓冲区接收内容，向缓冲区发送消息</p>
<h3 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h3><p><strong>产生原因：</strong><br>tcp传输中以字节流的方式发送内容，发送的消息之间没有明显的边界，此时如果发送和接收速度不匹配就会产生粘包</p>
<p>影响 ： 如果每次发送的内容表示一个独立的意思此时可能需要处理粘包。如果发送的内容本身就是连续的整体，此时不需要处理粘包</p>
<p><strong>如何处理：</strong></p>
<ol>
<li>每次发送后加一个结尾标志</li>
<li>发送一个数据结构</li>
<li>每次发送中间有一个短暂的延迟</li>
</ol>
<h2 id="基于udp的服务端"><a href="#基于udp的服务端" class="headerlink" title="基于udp的服务端"></a>基于udp的服务端</h2><ol>
<li>创建套接字 —》 数据报套接字<br> sockfd = socket(AF_INET,SOCK_DGRAM)</li>
<li>绑定服务端地址<br> sockfd.bind()</li>
<li><p>消息的收发<br> data，addr = recvfrom(buffersize)<br> 功能 ： 接收UDP消息<br> 参数 ： 每次最多接收消息的大小<br> 返回值 ： 接收到的内容 </p>
<pre><code>接收到的消息的发送者
</code></pre><p> recvfrom 一次接收一个数据包，如果数据包超出了一次能够接收的大小则会丢失没有收到的内容</p>
<p> sendto(data，addr)<br> 功能 ： udp发送消息<br> 参数 ： data  要发送的内容  bytes</p>
<pre><code>addr  消息要发送给谁
</code></pre><p> 返回值 ： 发送的字节</p>
</li>
<li><p>关闭套接字<br> sockfd.close()</p>
</li>
</ol>
<p><em>小贴士： </em><br><em>sys.argv<br>功能 ： 获取来自命令行的参数，形成一个列表<br>argv[0]是命令本身 其他内容默认以空格分割放到列表中</em></p>
<h3 id="tcp流式套接字和udp数据报套接字使用区别"><a href="#tcp流式套接字和udp数据报套接字使用区别" class="headerlink" title="tcp流式套接字和udp数据报套接字使用区别"></a>tcp流式套接字和udp数据报套接字使用区别</h3><ol>
<li>流式套接字采用字节流的方式传输，而数据报套接字以数据包形式传输</li>
<li>tcp会产生粘包现象，udp不会</li>
<li>tcp编程保证传输的可靠性，udp则不保证</li>
<li>tcp需要listren accept ，udp不需要</li>
<li>tcp使用recv  send进行消息收发，udp使用recvfrom和sendto</li>
</ol>
<p>补充：<br><strong>sendall（）</strong><br>功能参数： 同send<br>返回值 ： 发送成功返回None  发送失败返回异常</p>
<h2 id="套接字对象"><a href="#套接字对象" class="headerlink" title="套接字对象"></a>套接字对象</h2><p>(s表示一个套接字对象)</p>
<ul>
<li><p>s.fileno()<br>功能 ： 获取套接字的文件描述符<br>文件描述符 ：每一个IO 事件操作系统都会分配一个不同的正数与之匹配，该正数即为此IO操作的文件描述符<br>sys.stdin    0<br>sys.stdout   1<br>sys.stderr   2</p>
</li>
<li><p>s.type : 获取套接字类型</p>
</li>
<li><p>s.family: 地址类型</p>
</li>
<li><p>s.getsockname()<br>功能 ： 获取套接字绑定的地址</p>
</li>
<li><p>s.getpeername()<br>功能 ： 用户连接套接字，获取连接端的地址</p>
</li>
<li><p>s.setsockopt(level,optname,value)<br>功能 ： 设置套接字选项 丰富修改原有套接字功能<br>参数：<br>level ： 设置选项的类型 IPPROTP_TCP  IPPROTO_IP  SOL_SOCKET<br>optname： 选项类型中的子选项<br>value ： 为选定的选项设置值</p>
</li>
<li><p>s.getsockopt(level,optname)<br>功能 ： 获取套接字选项值<br>参数：  level ： 获取选项的类型 IPPROTP_TCP  IPPROTO_IP SOL_SOCKET<br>optname： 选项类型中的子选项<br>返回值 ： 获取到的值</p>
</li>
</ul>
<h2 id="udp套接字应用之广播"><a href="#udp套接字应用之广播" class="headerlink" title="udp套接字应用之广播"></a>udp套接字应用之广播</h2><p>特点：一点发送多点接收<br>目标地址 ：广播地址 一个网段内最大的地址<br>172.60.50.<strong>255</strong></p>
<p><em>小贴士：<br>format()<br>功能 ： 字符串属性函数 用来组合字符串</em></p>
<p><strong>广播风暴</strong>：占用大量的带宽造成网络拥塞</p>
<h2 id="tcp应用之-http传输"><a href="#tcp应用之-http传输" class="headerlink" title="tcp应用之 http传输"></a>tcp应用之 http传输</h2><p>HTTP协议 —&gt; 超文本传输协议</p>
<p>用途 ： 编写基于http协议的数据传输程序，网站中浏览器端获取网页的过程<br>将想要获取的内容，以http协议的格式发送给服务端，服务端根据格式进行解析获取到真实需求，将结果以http协议的格式回复给客户端</p>
<p><strong>特点 ：</strong> </p>
<ol>
<li>应用层协议 ，传输层使用tcp服务</li>
<li>简单，灵活，和多中语言对接方便</li>
<li>无状态的协议 即不记录用户使用过程中传递的内容</li>
<li>http1.1 支持持久连接</li>
</ol>
<h3 id="http请求-（Request）"><a href="#http请求-（Request）" class="headerlink" title="http请求 （Request）"></a>http请求 （Request）</h3><p>请求格式：</p>
<p>1 请求行    具体的请求类别<br>   GET           /         HTTP/1.1<br>   请求种类   请求内容    协议版本</p>
<p>   请求头    对请求新的的具体描述<br>   Accept: text/html<br>   以键值对的格式对信息进行具体描述</p>
<p>2 空行</p>
<p>3 请求体    具体的请求参数或者提交内容</p>
<p><strong>请求类型：</strong><br>GET        获取网络资源<br>POST       提交一定的附加数据，得到返回结果<br>HEAD       获取响应头<br>PUT        更新服务器资源<br>DELETE     删除服务器次元<br>CONNECT<br>TRACE      用于测试<br>OPTIONS    获取服务器性能</p>
<h3 id="HTTP响应-（Response）"><a href="#HTTP响应-（Response）" class="headerlink" title="HTTP响应 （Response）"></a>HTTP响应 （Response）</h3><p>响应格式：</p>
<p>1 响应行   反馈具体的响应情况<br> HTTP/1.1    200      OK<br> 版本       响应码   附加信息 </p>
<p>2 响应头   对响应的具体描述<br> Accept-Ranges: bytes<br> 以键值对方式给出响应信息的具体描述</p>
<p>3 空行<br> 响应体   将客户想要的内容进行返回</p>
<p><strong>响应码种类</strong><br>1xx    提示信息，表示请求已经接受<br>2xx    响应成功<br>3xx    响应需要重定向<br>4xx    客户端错误<br>5xx    服务端错误</p>
<p>200  成功<br>404  请求内容不存在<br>401  没有访问权限<br>500  服务器发生未知错误<br>503  服务器暂时不能执行</p>
<p>思考 ：<br>什么是http协议<br>请求格式和每部分的功能<br>响应格式和每部分功能<br>http请求和响应的流程</p>
<p>作业 ：<br>通过流式套接字完成一个文件的发送<br>将一个文件从客户端发送给服务端或者从服务端发送给客户端均可</p>
<h2 id="基础的http服务器"><a href="#基础的http服务器" class="headerlink" title="基础的http服务器"></a>基础的http服务器</h2><p>1.接收HTTP请求<br>2.给出一定的响应</p>
<p>IO  input   output</p>
<p>在内存中存在数据交换的操作都可以认为是输入输出<br>比如：<br>内存和磁盘交互  读写操作<br>内存和网络交互  recv  send</p>
<h3 id="IO密集型程序"><a href="#IO密集型程序" class="headerlink" title="IO密集型程序"></a>IO密集型程序</h3><p>程序执行中大量的IO操作，而较少的cpu运算。消耗cpu较少，运行时间长</p>
<p><strong>CPU密集型程序（计算密集型）</strong>：程序中大量的操作都需要cpu运算，IO操作较少。消耗cpu大，运行速度快</p>
<h4 id="IO-分类"><a href="#IO-分类" class="headerlink" title="IO 分类"></a>IO 分类</h4><p>阻塞IO  非阻塞IO  IO多路复用  事件IO   异步IO。。</p>
<p>1 阻塞IO ： 默认形态 效率很低的一种IO情形</p>
<p>阻塞情况 ：因为某种条件没有达成造成的阻塞<br>e.g.   accept   recv   input</p>
<p>处理IO事件的时候耗时比较长形成阻塞<br>e.g.  文件的读写过程，网络数据发送过程</p>
<p>2 非阻塞IO ： 通过修改IO事件的属性，使其变为非阻塞的状态。（改变了第一种阻塞的状况）</p>
<p>通常和循环搭配使用，不断检测阻塞条件是否已经满足。</p>
<p>s.setblocking()<br>功能： 将套接字设置为非阻塞状态<br>参数： bool   设置为False则表示设置为非阻塞</p>
<h3 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h3><p>将原本阻塞的函数，设置一个阻塞的最长时间，在规定时间内如果条件达到则正常执行，如果仍然阻塞则抛出异常</p>
<p>s.settimeout(sec)<br>功能 ： 设置套接字超时时间<br>参数 ： 设置的时间</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>定义 ： 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。以此形成，多个IO事件都可以操作，不必诸个等待执行的效果。</p>
<p>准备就绪：IO事件即将发生的临界状态</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>import select</p>
<p>select —-&gt; windows  linux  unix<br>poll —&gt; linux unix<br>epoll –&gt; linux  unix</p>
<p> r, w, x = select(rlist, wlist, xlist[, timeout])<br> 功能：监控IO事件，阻塞等待IO事件的发生<br> 参数：<br>   rlist  列表  存放我们监控等待处理的IO事件<br>   wlist  列表  存放我们要主动处理的IO事件<br>   xlist  列表  存放如果发生异常需要我们处理的<br>   timeout 数字  超时时间<br>   返回值：r  列表   rlist当中准备就绪的IO<br>   w  列表   wlist当中准备就绪的IO<br>   x  列表   xlist当中准备就绪的IO</p>
<p><em>注意事项 ： </em><br>1.在处理IO过程中不应该发生死循环（某个IO单独占有服务器）<br>2.IO多路复用行了一种并发的效果，效率较高</p>
<p>练习 ： 写一个select服务端  同时关注客户端端的连接，客户端的发送和终端的输入。将客户端发送的内容和终端输入的内容均写入到一个文件中</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>按照二进制位进行操作运算</p>
<p>&amp;(按位与)    |（按位或）    ^（按位异或）<br>&lt;&lt;（左移）    &gt;&gt;（右移） </p>
<p>11  1011<br>14  1110</p>
<p>&amp;   1010  一0则0<br>|   1111  一1则1<br>^   0101  相同为0不同为1<br>11 &lt;&lt; 2  ==&gt; 44   右侧补0<br>14 &gt;&gt; 2  ==&gt; 3    挤掉低位的数字</p>
<p>使用 ： </p>
<ol>
<li>在做底层硬件的寄存器操作</li>
<li>在做标志位过滤时</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><ul>
<li><p>创建poll对象<br>p = select.poll()</p>
</li>
<li><p>添加关注对象<br>p.register(s，POLLIN | POLLERR)<br>p.unregister(s)<br>poll IO事件类型分类<br>POLLIN POLLOUT  POLLERR POLLHUP  POLLPRI  POLLVAL<br>rlist   wlist   xlist    断开   紧急处理  无效数据</p>
</li>
<li><p>进行监控<br>events = p.poll()<br>功能： 阻塞等待register的事件发生<br>返回值 ： events 是一个列表，列表中每个元素表示准备就绪需要处理的IO<br>[(fileno,event),          (),()]<br>  描述符 具体什么就绪了<br>描述符地图｛s.fileno(): s｝</p>
</li>
<li><p>处理IO事件</p>
</li>
</ul>
<p>作业 ： </p>
<ol>
<li>熟练 写出 select server代码</li>
<li>能够描述IO多路复用的执行原理和内部机制</li>
<li>巩固HTTPserver的代码—》理解HTTP服务器执行流程</li>
</ol>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>使用方法 ： 代码基本与poll相同</p>
<ul>
<li>将生成对象的 poll() 函数 变为 epoll()</li>
<li>将register注册IO事件时 关注的事件类别改为epoll类别</li>
</ul>
<p>区别：<br>epoll 效率要高于 poll和select<br>epoll 的关注触发方式多一些</p>
<h2 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h2><p>linux下文件类型：<br>b（块设备文件） c（字符设备文件）   d（目录）<br>-（普通文件） l（链接文件） s（套接字文件） p（管道文件）</p>
<p>作用 ： 用于本地不同的程序间进行通信</p>
<p>本地套接字创建流程：</p>
<ul>
<li>创建套接字对象<br>sockfd = socket（AF_UNIX,SOCK_STREAM）</li>
<li>建立套接字文件<br>sockfd.bind(path) 绑定一个文件</li>
<li>监听</li>
<li>接收发送消息</li>
</ul>
<p>*小贴士<br>os.path.exists(path)<br>功能： 判断一个文件是否存在<br>参数： 文件位置<br>返回值： 存在返回True  否则返回False</p>
<p>os.unlink()   os.remove()<br>功能：删除一个文件<br>参数：要删除的文件</p>
<p>In [2]: os.path.exists(“./re”)<br>Out[2]: True</p>
<p>In [3]: os.unlink(“./re”)*</p>
<h1 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h1><p>意义 ： 充分的利用计算机资源提高程序的运行效率</p>
<p>定义 ： 通过应用程序利用计算机的多个核心达到同时执行多个任务的目的，以此来提升程序的执行效率</p>
<p>实施方案 ： 多进程    多线程</p>
<p>并行： 多个计算机核心在同时处理多个任务，这多个任务间是并行关系</p>
<p>并发：同时处理多个任务，内核在任务间不断的切换，达到好像都在处理运行的效果</p>
<p>进程：程序在计算机中的一次执行过程 </p>
<p>程序 ： 是一个可执行文件，是静态的，占有磁盘，不占计算机的运行资源<br>进程 ： 进程是一个动态的过程描述，占有计算机的资源，有一定的生命周期</p>
<ul>
<li>同一个程序的不同运行过程是不同的进程。因为分配的计算机资源不同，生命周期也不同</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的创建流程"><a href="#进程的创建流程" class="headerlink" title="进程的创建流程"></a>进程的创建流程</h3><ul>
<li>1.用户空间运行一个程序，发起进程的创建</li>
<li>2.操作系统接受用户申请开启进行创建</li>
<li>3.操作系统分配计算机资源，确定进程状态</li>
<li>4.将新创建的进程交给用户使用</li>
</ul>
<p><strong>cpu时间片</strong><br>如果一个进程占有计算机核心，我们称为该进程占有cpu时间片。多个任务实际会对cpu内核进行争夺，由操作系统分配cpu资源</p>
<p>进程信息<br><strong>PCB（进程控制块）</strong>：在*nix操作系统中，进程创建后会自动在内存中产生一个空间存放进程信息，称为PCB</p>
<p>进程信息：进程的ID 进程占有内存位置 创建时间  创建用户..</p>
<p><strong>查看命令：ps  -aux</strong></p>
<p><strong>PID</strong>(process ID) : 在操作系统中进程的唯一标志，大于0的整数，由系统自动分配</p>
<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul>
<li>进程是操作系统分配计算机资源的最小单位</li>
<li>每个进程有自己单独的虚拟内存空间</li>
<li>进程之间的执行上相互独立，互不影响</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>  <strong>三态</strong></p>
<pre><code>* 就绪态：进程具备执行条件，等待系统分配处理器资源
* 运行态：进程占有cpu处于运行的状态
* 等待态：进程暂时不具备运行条件，需要阻塞等待
</code></pre><p>  <strong>五态</strong> （在三态基础上增加新建态和终止态）</p>
<pre><code>* 新建态 ：创建一个新的进程，获取资源的过程
* 终止态 ：进程执行结束，资源释放回收的过程
</code></pre><p>ps -aux  —-&gt; STAT 表示进程状态</p>
<pre><code>D  等待态  （不可终端等待）
S  等待态   （可终端等待）
T  等待态   （暂停状态）
R  运行态   （包含就绪态）
Z  僵尸态  

\+  前台进程 在终端运行
&lt;  高优先级
N  低优先级
l  有进程链接
s  会话组
</code></pre><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>优先级决定了一个进程的执行权限和占有资源的优先程度</p>
<p><strong>查看优先级</strong> ：<br>    top ： 动态查看进程优先级    摁 &lt;  &gt; 翻页</p>
<p><strong>优先级取值范围</strong>  -20 — 19   -20最高</p>
<pre><code>nice ： 以指定的优先级运行一个程序
    e.g.  nice  -9   ./while.py
          nice  --9  ./while.py   -9的优先级运行
</code></pre><h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p>在系统中除了初始化进程每个进程都有一个父进程，可能有0个或者多个子进程。由此形成进程的父子关系。我们认为每个进程都是父进程创造的。</p>
<p>查看进程树 : pstree<br>查看父进程PID ： ps  -ajx</p>
<p>思考 ：<br>什么是进程，进程和程序的区别<br>了解进程的特征<br>清楚进程每种状态，及状态转换</p>
<p>需求 ： 编写一个程序能够同时做多件任务</p>
<p>方案 ： 写一个程序，根据需要在程序内不可以创建多个进程完成任务</p>
<p><strong>使用os.fork()方法实现</strong></p>
<p>import os </p>
<p>pid = os.fork()<br>功能 ： 创建一个新的进程<br>参数 ： 无<br>返回值 ：<br>失败返回一个负数   -1<br>成功 ： 在原有进程中返回新进程的PID号，在新进程中返回0</p>
<ul>
<li>子进程会复制父进程全部代码段，包括fork之前产生的内存空间</li>
<li>子进程从fork的下一句开始执行</li>
<li>父子进程通常会根据fork返回值的差异选择执行不同的代码</li>
<li>子进程虽然复制父进程的代码空间，但是有自己的特有属性 比如 PID号 PCB等</li>
<li>父子进程在执行上互补干扰，执行顺序不确定</li>
<li>父子进程空间独立，在本进程中对空间的操作不会影响到其他进程</li>
<li><strong>os.fork函数不能在Windows操作系统上面运行</strong></li>
</ul>
<p>进程相关函数使用</p>
<p>获取进程号<br>os.getpid()<br>功能 ：获取当前进程的进程号<br>返回值 ： 返回进程号</p>
<p>os.getppid()<br>功能：获取父进程的进程号<br>返回值 ： 返回进程号</p>
<p>进程的退出<br>os._exit(status)<br>功能 ： 退出进程<br>参数 ： 进程的退出状态 整数</p>
<p>sys.exit([status])<br>功能： 退出进程<br>参数： 不写默认为0<br>       传入一个整数表示退出状态<br>             传入一个字符串，则在进程退出时会打印该字符串</p>
<ul>
<li>sys.exit 可以通过捕获 SystemExit 异常阻止其退出</li>
</ul>
<p>代码示例：<br>    “””１，创建套接字<br>            ２，绑定<br>            ３，监听<br>            ４，接收客户端请求accept<br>            ５，创建子进程处理客户端请求，父进程继续接收其他客户端连接<br>            ６，客户端退出则子进程结束”””</p>
<pre><code>import socket
import os
import sys
import signal

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
s.bind((&quot;127.0.0.1&quot;,9527))
s.listen(100)

def client_handler(c):
    print(&quot;asfagg&quot;)
    print(&quot;cpid deal with client&quot;,c.getpeername())
    while True:
        data = c.recv(1024).decode()
        if not data:
            break
        print(data)
        c.send(b&quot;receive your msg&quot;)


signal.signal(signal.SIGCHLD,signal.SIG_IGN)
while True:
    try:
        conn,addr = s.accept()
    except KeyboardInterrupt:
        s.close()
        sys.exit(&quot;exit&quot;)
    except Exception as e:
        print(e)
        continue
    pid = os.fork()
    if pid &lt; 0:
        print(&quot;create failed&quot;)
    elif pid == 0:     
        s.close()#子进程不需要监听套接字
        print(os.getpid(),&quot;hello&quot;)
        client_handler(conn)
        # data = conn.recv(1024)
        # print(data.decode())
        #子进程处理完客户端请求一定要退出
        conn.close()
        sys.exit(0)
    else:
        conn.close() #关闭冗余的套接字
</code></pre><p>作业 ： </p>
<p>写一个聊天室</p>
<p>功能 ： 类似QQ群聊</p>
<ol>
<li>进入聊天室前需要输入用户名</li>
<li>有人进入聊天室会向其他用户发起通知<br>xxx  进入了聊天室</li>
<li>一个人发消息，其他人都能收到<br>xxx 说：xxxxxxxx</li>
<li>某个人退出聊天室 其他人也会收到通知<br>xxx 退出了聊天室</li>
</ol>
<p>思考 服务端    客户端</p>
<ul>
<li>使用什么技术</li>
<li>每个功能的实现方案</li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程先于子进程退出，此时子进程就会成为孤儿进程。</p>
<ul>
<li>孤儿进程会被系统指定的进程收养，即系统进程会成为孤儿进程新的父进程。当孤儿进程退出时“继父”，会处理孤儿进程退出状态，使其不会成为僵尸。</li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程 </p>
<ul>
<li>僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统资源，应该尽量避免僵尸进程的产生</li>
</ul>
<p><strong>如何避免僵尸进程</strong></p>
<ul>
<li>父进程先退出（不佳，因为不好控制）</li>
<li>父进程处理子进程的退出状态</li>
</ul>
<p>pid,status = <strong>os.wait()</strong><br>功能： 在父进程中阻塞等待子进程的退出<br>返回值 ：<br>一个两个元素的元组<br>pid : 退出的子进程的PID号<br>status ： 退出的子进程的退出状态</p>
<p>pid,status = <strong>os.waitpid(pid，option) </strong><br>功能 ： 处理子进程的退出状态<br>参数 ：<br>pid  -1 表示等待任意子进程退出</p>
<blockquote>
<p>0 整数 表示等待对应PID号的子进程退出<br>option ：  0 表示阻塞等待  WNOHONG  表示非阻塞<br>返回值  ： 同wait()</p>
</blockquote>
<p>waitpid（-1,0） ====  wait()</p>
<p><strong>创建二级子进程</strong></p>
<ul>
<li>父进程创建子进程等待子进程的退出</li>
<li>子进程创建二级子进程后马上退出</li>
<li>二级子进程成为孤儿，处理具体事件</li>
</ul>
<h3 id="聊天室项目"><a href="#聊天室项目" class="headerlink" title="聊天室项目"></a>聊天室项目</h3><p>功能 ： 类似QQ群聊</p>
<ol>
<li>进入聊天室前需要输入用户名</li>
<li>有人进入聊天室会向其他用户发起通知<br>xxx  进入了聊天室</li>
<li>一个人发消息，其他人都能收到<br>xxx 说：xxxxxxxx</li>
<li>某个人退出聊天室 其他人也会收到通知<br>xxx 退出了聊天室</li>
<li>管理员喊话功能 ：管理员发言所有客户端都能收到<br>管理员 说：xxxxxxx </li>
</ol>
<p>需要什么技术：</p>
<p>socket 通信</p>
<p>存储用户 ： 字典或列表 姓名 和 地址</p>
<p>用什么类型套接字 ： udp套接字</p>
<p>怎么发消息：</p>
<ul>
<li>转发  即客户端发给服务器然后服务器在发送给其他人</li>
<li>在客户端让发送和接收需要相互独立，各使用一个进程</li>
<li>服务端，管理员喊话和请求的接收需要独立，各使用一个进程</li>
</ul>
<p>注意点</p>
<ol>
<li>功能封装  将每个功能模块化</li>
<li>测试，每个功能进行测试</li>
</ol>
<p>代码编写流程</p>
<p>搭建网络连接—-&gt;多进程的创建—&gt;每个进程功能的编写—&gt;项目功能的诸个编写</p>
<p>客户端可能发送的请求</p>
<p>进入聊天室：  “L name”<br>服务端 ： 识别请求  判定是否可以进入<br>  回复客户端  保留用户<br>  告知其他人谁进入</p>
<p>聊天请求 ： “C name message”<br>服务端 ： 识别请求  转发给其他人</p>
<p>退出聊天室： “Q name”<br>服务端 ： 识别请求  告知其他人谁退出<br>   将其从用户中删除</p>
<p><strong> 这里只是写的一种最容易理解的编码方式，在udp协议中是需要在应用层进行加密处理，这里的加密处理明显不够，而且空格并不是很好的分割符，比如人名为Jason smith，发送了一条消息’hello’，在服务器会转发为’jason’说’smith hello’，而本身应该表示’jason smith’说’hello’，但是这里暂且先不处理，简化一下发送格式 </strong></p>
<h2 id="multiprocessing-模块创建进程"><a href="#multiprocessing-模块创建进程" class="headerlink" title="multiprocessing 模块创建进程"></a>multiprocessing 模块创建进程</h2><ul>
<li>1.需要将要做的事件进行封装成函数</li>
<li>2.使用multiprocessing提供的类Process创建进程对象</li>
<li>3.通过对象和Process的初始化函数对进程进行设置以    及绑定要执行的事件</li>
<li>4.启动进程，会自动的执行函数代表的事件</li>
<li>5.完成进程的回收</li>
</ul>
<h3 id="创建进程对象"><a href="#创建进程对象" class="headerlink" title="创建进程对象"></a>创建进程对象</h3><p>Process()<br>功能：创建进程对象<br>参数：name ： 给创建的进程对象起一个名字<br>              默认为Process-1<br>            target :  绑定的函数<br>            args ：元组 用来给 target函数传参按位置传参<br>      kwargs ： 字典  按照键值传参</p>
<p>p.start()<br>功能：启动进程 进程被创建，自动运行对应函数</p>
<p>p.join([timeout])<br>功能 ： 阻塞等待对应子进程的退出，回收子进程<br>参数 ： 超时时间</p>
<ul>
<li>如果不使用join 则子进程会成为僵尸进程</li>
<li>在使用multiprocessing创建进程中，一般父进程功能   就是创建子进程等待回收，不做过多其他事情</li>
<li>使用multiprocessing创建子进程，同样子进程复制父   进程空间，之后有自己独立的执行空间，互不干扰</li>
</ul>
<p>作业： 1. 将聊天室代码进行梳理</p>
<pre><code>  2.  复习fork创建进程的内容进行整理
3. multiprocessing 函数巩固
</code></pre><h3 id="进程对象属性"><a href="#进程对象属性" class="headerlink" title="进程对象属性"></a>进程对象属性</h3><p>p.join()  回收进程<br>p.start() 启动进程<br>p.is_alive()  判断进程是否在生命周期状态，在生命周期中返回True 否则返回False</p>
<p>p.name  进程名称 默认为Process-1 如果起名字则为自己取的名称</p>
<p>p.pid   进程的PID号</p>
<p>代码示例</p>
<pre><code>import multiprocessing as mp
import time

def worker(a,b,c,name):
    for i in range(3):
        # time.sleep(sec)
        print(a,b,c)
        print(&quot;I&apos;m &quot;,name)
        print(&quot;I&apos;m working ...&quot;)

p = mp.Process(&apos;k&apos;,worker,(2,3,4),{&quot;name&quot;:&quot;Jason&quot;})
p.start()
p.join(4)
print(&quot;after join&quot;)
</code></pre><p><strong>p.daemon</strong><br>默认为False  主进程退出不会影响子进程<br><strong>如果设置为 True 则主进程退出时会让所有子进程都退出</strong></p>
<p><strong> * 该属性的设置必须在start() 前</strong><br><strong> * 该属性一般不用和join同时出现</strong></p>
<h3 id="创建自定义进程类"><a href="#创建自定义进程类" class="headerlink" title="创建自定义进程类"></a>创建自定义进程类</h3><ul>
<li>1.继承Process类</li>
<li>2.运行Process类的<strong>init</strong> 以获取父类属性</li>
<li>3.<strong>重写run方法</strong>，在通过自定类生成对象后，调用start()会自动执行这个方法</li>
</ul>
<p>代码示例：</p>
<pre><code>import multiprocessing as mp
import time

class myProcess(mp.Process):
    def __init__(self,value):
        super().__init__()
        self.value = value

    #重写父类的run方法
    def run(self):
        print(time.ctime())
        time.sleep(self.value)
        print(time.ctime())

    def start(self):
        pass


myP = myProcess(2)
print(&quot;========&quot;)
#在启动的时候才会启动run方法，本质是在Process的start中调用的run 方法
myP.start()
time.sleep(1)
print(&quot;-------------&quot;)
&quot;&quot;&quot;
Tue Jun 12 10:15:55 2018
Tue Jun 12 10:15:57 2018
&quot;&quot;&quot;
</code></pre><h3 id="多进程优缺点"><a href="#多进程优缺点" class="headerlink" title="多进程优缺点"></a>多进程优缺点</h3><p><strong>优点 ： </strong><br>并行执行多个任务，提高效率<br>创建方便<br>运行独立，不受其他进程影响<br>数据安全<br><strong>缺点 ：</strong>在进程的创建和删除过程中消耗计算机资源较多</p>
<h3 id="进程池技术"><a href="#进程池技术" class="headerlink" title="进程池技术"></a>进程池技术</h3><p>产生原因 ：如果有大量的任务需要多进程完成，则可能需要频繁的创建和删除进程，给计算机带来较多的消耗。</p>
<p><strong>使用 ：大量可以短时间完成的任务需要多进程操作的时候比较适用于进程池</strong></p>
<p>使用方法：</p>
<ul>
<li><ol>
<li>创建进程池，在池内放入适当的进程</li>
</ol>
</li>
<li><ol start="2">
<li>将事件加入进程池队列</li>
</ol>
</li>
<li><ol start="3">
<li>事件不断运行，所有事件运行完成</li>
</ol>
</li>
<li><ol start="4">
<li>关闭进程池，回收进程</li>
</ol>
</li>
</ul>
<p>from multiprocessing import Pool </p>
<p>Pool(processes)<br>功能 ： 创建进程池对象<br>参数 ： processes  表示进程池中有多少进程<br>对象 ： 进程池对象</p>
<p>pool.apply_async(func,args,kwds)<br>功能 ： 将事件放入进程池等待执行<br>参数 ：<br>func   要放入进程池的事件函数<br>args   给func函数以元组传参<br>kwds   给func函数以字典传参<br>返回值 ：<br>返回一个事件对象<br>通过get()方法可以获取事件函数的返回值</p>
<p>pool.apply(func,args,kwds)<br>功能 ： 将事件放入进程池等待执行<br>参数 ：<br>func   要放入进程池的事件函数<br>args   给func函数以元组传参<br>kwds   给func函数以字典传参</p>
<p>pool.close()<br>功能 ： 关闭进程池 不能再添加新的事件</p>
<p>pool.join()<br>功能 ： 回收进程池</p>
<p>代码示例：</p>
<pre><code>from multiprocessing import Pool
import time

def fun(msg):
    time.sleep(2)
    print(&quot;msg is &quot;,msg)
    return time.ctime()

pool = Pool(processes = 5)
result = []
for i in range(5):
    msg = i
    # r = pool.apply_async(fun,args = (msg,))
    pool.apply(fun,args = (msg,))
    # result.append(r)

pool.close()

pool.join()
# for i in result:
#     print(i.get())
</code></pre><p><strong>这里的apply_async 和 apply的区别在于apply是阻塞的，所以进入子进程执行后，等待当前子进程执行完毕，在继续执行下一个进程。<br>apply_async 是异步非阻塞的，不用等待当前进程执行完毕，随时根据系统调度来进行进程切换</strong></p>
<p>pool.map(func,iter)<br>功能 ： 将要完成的事件放入到进程池<br>参数 ： func 要完成的事件函数，iter 要给func传递的参数的迭代器<br>返回值 ： 返回事件函数的返回值列表</p>
<p>练习 ： 使用multiprocessing 创建两个进程，分别复制一个文件的上半部分和下半部分到另外一个新的文件中<br><em>小贴士 :  os.path.getsize(path) 获取文件大小</em></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间由于空间独立，资源互相无法直接获取，此时在不同的进程间传递数据就需要专门的进程间通信方法。</p>
<p>和磁盘交互 ： 使用中间文件 但是不安全，速度慢</p>
<p><strong>进程间通信方法 （IPC）</strong><br>管道   消息队列  共享内存   信号  信号量  套接字</p>
<h3 id="管道通信-Pipe"><a href="#管道通信-Pipe" class="headerlink" title="管道通信 Pipe"></a>管道通信 Pipe</h3><p>在内存中开辟一块空间，形成管道结构，管道对多个进程可见，进程可以通过对管道的读写操作进行通信</p>
<p>multiprocessing —》 Pipe </p>
<p>fd1,fd2 = Pipe(duplex = True)<br>功能 ： 创建一个管道<br>参数 ： 默认表示管道为双向管道<br>        如果设置为False 则表示单向管道<br>返回值 : 返回两个管道流对象，表示管道两端<br>         如果是双向管道，则都可以读写<br>                 如果是单向管道，则fd1只读  fd2只写</p>
<p>fd1.recv()<br>功能 ： 从管道内读信息<br>返回值：读到的内容</p>
<ul>
<li>当管道内无内容时会阻塞</li>
</ul>
<p>fd2.send(data)<br>功能 ： 向管道写入内容<br>参数 ： 要写的内容</p>
<ul>
<li>可以发送几乎Python的任意数据类型</li>
</ul>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Pipe
import os,time

fd1,fd2 = Pipe(duplex=False)
ps = [] 

def fun(msg):
    time.sleep(2)
    print(&quot;msg is&quot;,msg)
    fd2.send(str(msg))

# ps = []
for i in range(5):
    p = Process(target=fun,args=(i,))
    p.start()
    ps.append(p)

for i in range(5):
    data = fd1.recv()
    print(&quot;data is &quot;,data)

for p in ps:
    p.join()
</code></pre><p>运行结果：</p>
<pre><code>msg is 0
data is  0
msg is 1
data is  1
msg is 2
data is  2
msg is 3
data is  3
msg is 4
data is  4
</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>队列 ： 先进先出<br>在内存中开辟队列结构空间，对多个进程可见。多个进程向队列中存入消息，取出消息，完成进程间通信。</p>
<p>创建队列<br>q = Queue(maxsize = 0)<br>功能 ： 创建队列<br>参数 ： maxsize 默认表示根据系统分配空间存储消息<br>        如果传入一个正整数则表示最多存入消息数量<br>返回值 ： 队列对象</p>
<p>q.put(data,[block,timeout])<br>功能 ： 向队列中存入消息<br>参数 ： data  存入的数据 （支持Python数据类型）<br>        block  默认为True表示 当队列满时阻塞<br>                       设置为False 表示非阻塞<br>                timeout  当block为Ture时表示超时时间</p>
<p>data = q.get([block,timeout])<br>功能 ： 从队列获取消息<br>参数 ： block  默认为True表示 当队列空时阻塞<br>                       设置为False 表示非阻塞<br>                timeout  当block为Ture时表示超时时间<br>返回值：返回获取到的消息</p>
<p>q.full()  判断队列是否为满<br>q.empty() 判断队列是否为空<br>q.qsize() 获取队列中消息数量<br>q.close() 关闭队列</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Queue
q = Queue()

def fun1():
    for x in range(10):
        q.put(x)
    q.put(&quot;fasfgsd&quot;)
    pass

def fun2():
    data = q.get()
    while True:
        if data is not None:
            print(data)
            data = q.get()
        else:
            break
        pass

def fun3():
    while q.qsize():
        try:
            data = q.get()
            print(&apos;queue data: &apos;,data)
        except Queue.Empty:
            pass
        except :
            pass
p1 = Process(target=fun1)
p2 = Process(target=fun3)
p1.start()
p2.start()
p1.join()
p2.join()
</code></pre><p>运行结果：<br>        queue data:  0<br>        queue data:  1<br>        queue data:  2<br>        queue data:  3<br>        queue data:  4<br>        queue data:  5<br>        queue data:  6<br>        queue data:  7<br>        queue data:  8<br>        queue data:  9<br>        queue data:  fasfgsd</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在内存中开辟一段空间，存储数据，对多个进程可见。每次写入共享内存的数据会覆盖之前的内容</p>
<p>from multiprocessing import  Value，Array</p>
<p>obj = Value(ctype,obj)<br>功能 ： 开辟共享内存空间<br>参数 ： ctype  字符串 要转变的c的类型code（对照ctype表）<br>        obj  共享内存初始值<br>返回共享内存对象</p>
<p>obj.value  表示共享内存中的值。对其修改或者使用即为使用共享内存中的值</p>
<p>obj = Array(ctype,obj)<br>功能 ： 开辟共享内存空间<br>参数 ：<br>ctype  要转换的类型<br>obj 要存入共享内存的数据<br>列表  将列表存入共享内存 要求类型一致<br>整数  在共享内存中开辟几个单元的空间<br>返回值：共享内存对象</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Array
import time

# shm = Array(&apos;i&apos;,[1,2,3,4,5,6])
#这里的i 指的是整型数据，C语言中整型数据默认值为0
shm = Array(&apos;i&apos;,6)

def fun1():
    for i in shm:
        print(i)
    shm[3] = 1000

def fun2():
    for i in shm:
        print(i)

p = Process(target= fun1)
p2 = Process(target= fun2)
p.start()

p.join()
p2.start()
p2.join()
</code></pre><p>运行结果：在fun1中修改的内容，func取出来是修改过的，通信成功<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        1000<br>        0<br>        0</p>
<table>
<thead>
<tr>
<th></th>
<th>管道</th>
<th>消息队列</th>
<th>共享内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>开辟空间</td>
<td>内存</td>
<td>内存</td>
<td>内存</td>
</tr>
<tr>
<td>读写方式</td>
<td>两端读写（双向/单向）</td>
<td>先进先出</td>
<td>操作覆盖内存            </td>
</tr>
<tr>
<td>效率</td>
<td>一般</td>
<td>一般</td>
<td>较快</td>
</tr>
<tr>
<td>应用</td>
<td>多用于父子进程</td>
<td>广泛灵活</td>
<td>复杂<br>需要互斥机制</td>
</tr>
</tbody>
</table>
<p>作业 ：<br>熟练掌握进程间通信方法<br>自己实现进程池的使用，知道进程池特性</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个进程向另一个进程通过信号传递某种讯息。接收方在接受到信号时进行相应的处理</p>
<p>kill  -l   查看信号<br>kill  -signame  PID   给PID的进程发送一个信号 </p>
<p>关于信号 </p>
<p>信号名称 ： 系统定义，  名字或者数字<br>信号含义 ： 系统定义，  信号的作用<br>默认处理方法：当一个进程接收到信号时默认产生的效果<br>               终止进程   暂停进程   忽略<br>e.g.<br>SIGHUP   连接断开<br>SIGINT   CTRL + C<br>SIGQUIT  CTRL + \<br>SIGTSTP  CTRL + Z<br>SIGKILL  终止进程且不能被处理<br>SIGSTOP  暂停进程且不能被处理<br>SIGALRM  时钟信号<br>SIGCHLD  子进程状态改变给父进程发送</p>
<p>Python进行信号处理</p>
<p>os.kill(pid,sig)<br>功能 ： 发送信号给某个进程<br>参数 ： pid   给哪个进程发送信号<br>        sig   要发送什么信号</p>
<p>signal.alarm(sec)<br>功能 ： 一定时间后向自身发送 一个SIGALRM信号<br>参数 ： 定时时间</p>
<ul>
<li>在一个进程中只允许有一个时钟，设置第二个的时候时   间就会重置</li>
</ul>
<p>程序执行的异步和同步</p>
<p>同步：按照步骤一步一步往下顺序执行<br>异步：在程序执行中利用内核，不想应用层的持续执行</p>
<ul>
<li>信号是唯一的异步通信方式</li>
</ul>
<p>signal.pause()<br>功能 ： 阻塞等待进程收到一个信号</p>
<p>signal.signal(signum，handler)<br>功能 ： 处理信号<br>参数 ： signum  ： 要处理的信号<br>handler ： 信号的处理方法<br><strong>可选值 ：<br>SIG_DFL  表示使用默认方法处理<br>SIG_IGN  表示忽略这个信号<br>func     自定义函数</strong></p>
<p>自定义函数格式：<br>def func(sig,frame)<br>sig：接收到的信号<br>frame：信号结构对象</p>
<ul>
<li>signal函数是一个异步处理函数</li>
<li>signal函数不能处理SIGKILL，SIGSTOP信号</li>
<li>在父进程中加上signal(SIGCHLD,SIG_IGN)，当子进程退   出时会自动交由系统处理</li>
</ul>
<p>示例代码：<br>        from signal import *<br>        import time<br>        import os</p>
<pre><code>#信号处理函数
def handler(sig,frame):
    if sig == SIGALRM:
        print(&quot;接收到时钟信号&quot;)
        exit()
    elif sig == SIGINT:
        print(&quot;就不结束&quot;)

alarm(5)

#当接收到SIGALRM信号 用handler函数处理
signal(SIGALRM,handler)
signal(SIGINT,handler)

while True:
    print(&quot;Waiting for a signal&quot;)
    time.sleep(2)
</code></pre><p>运行结果：<br>        Waiting for a signal<br>        ^C就不结束<br>        Waiting for a signal<br>        ^C就不结束<br>        ^C就不结束<br>        Waiting for a signal<br>        接收到时钟信号</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>给定一定的数量，对多个进程可见，并且多个进程根据信号的数量多少确定不同的行为</p>
<p>multiprocessing —》 Semaphore() </p>
<p>sem = Semaphore(num)<br>功能 ： 生成信号量对象<br>参数 ： 信号量的初始值<br>返回值 ： 信号量对象</p>
<p>sem.acquire()  将信号量数量减一  信号量为0会阻塞<br>sem.release()  将信号量数量加一<br>sem.get_value() 获取当前信号量的值</p>
<p>示例代码：</p>
<pre><code>import multiprocessing as mp
import time
import os
sem = mp.Semaphore(3)

def fun():
    print(&quot;process %d wait semaphore&quot;%os.getpid())
    sem.acquire()
    print(&quot;process %d use semaphore&quot;%os.getpid())
    time.sleep(1)
    sem.release()
    print(&quot;process %d add semaphore&quot;%os.getpid())

jobs = []
for i in range(4):
    p = mp.Process(target=fun)
    jobs.append(p)
    p.start()
for i in jobs:
    i.join()
</code></pre><p>运行结果：</p>
<pre><code>process 8441 wait semaphore
process 8441 use semaphore
process 8442 wait semaphore
process 8442 use semaphore
process 8443 wait semaphore
process 8443 use semaphore
process 8444 wait semaphore
process 8441 add semaphore
process 8444 use semaphore
process 8442 add semaphore
process 8443 add semaphore
process 8444 add semaphore
</code></pre><h2 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a>同步互斥机制</h2><p>目的 ： 解决对共有资源操作产生的争夺</p>
<p>临界资源 ： 多个进程或者线程都能够操作的资源<br>临界区   ： 操作临界资源的代码段</p>
<p>同步 ： 同步是一种合作关系，为完成某个任务多进程或者多线程之间形成一种协调，按照约定或条件一次执行操作临界资源，相互告知资源使用         情况。</p>
<p>互斥 ： 互斥是一种制约关系，当一个进程或者线程进入临界区会进行加锁的操作。此时其他进程（线程）再企图使用临界资源时就会阻塞，直到         资源被释放才能使用</p>
<h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event  事件"></a>Event  事件</h3><p>multiprocessing Event<br>创建事件对象<br>e = Event()</p>
<p>事件阻塞<br>e.wait([timeout])</p>
<p>事件设置  e处于设置状态，e.wait()不再阻塞<br>e.set()</p>
<p>事件清除  e处于未设置状态，e.wait()阻塞<br>e.clear() </p>
<p>事件判断  判断e的当前状态<br>e.is_set()</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Event
import time

e = Event()
def wait_event():
    print(&quot;waiting for event set&quot;)
    e.wait()
    print(&quot;it&apos;s my turn&quot;,e.is_set())

def wait_event_timeout():
    print(&quot;I just wait for 2s &quot;)
    e.wait(2)
    print(&quot;after 2s,it&apos;s my turn&quot;)

p1 = Process(target = wait_event)
p2 = Process(target = wait_event_timeout)

p1.start()
p2.start()

print(&quot;main process is operating resource&quot;)
time.sleep(3)
e.set()
print(&quot;open resoure&quot;)

p1.join()
p2.join()
</code></pre><p>运行结果：</p>
<pre><code>main process is operating resource
waiting for event set
I just wait for 2s 
after 2s,it&apos;s my turn
open resoure
it&apos;s my turn True
</code></pre><h3 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁  Lock"></a>锁  Lock</h3><p>multiprocessing —&gt; Lock</p>
<p>创建对象<br>lock = Lock()</p>
<p>lock.acquire()  上锁<br>lock.release()  解锁</p>
<p>上锁状态 ： 此时执行acquire（）操作会阻塞<br>解锁状态 ： 执行acquire（）操作为非阻塞</p>
<p>with  lock：  —-》 上锁<br>….<br>….<br>—-&gt; with代码段结束后自动解锁 </p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Lock 
import sys 
from time import sleep 

#sys.stdout标准输出流作为所有进程的临界资源

def writer1():
    lock.acquire()  #上锁
    for i in range(5):
        sleep(1)
        sys.stdout.write(&quot;writer1输出\n&quot;)
    lock.release()  #解锁

def writer2():
    #with方式上锁
    with lock:
        for i in range(5):
            sleep(1)
            sys.stdout.write(&quot;writer2输出\n&quot;)

#创建锁
lock = Lock()

w1 = Process(target = writer1)
w2 = Process(target = writer2)

w1.start()
w2.start()

w1.join()
w2.join()
</code></pre><p>运行结果：</p>
<pre><code>writer1输出
writer1输出
writer1输出
writer1输出
writer1输出
writer2输出
writer2输出
writer2输出
writer2输出
writer2输出
</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>这里不得不说死锁的概念<br>出自： <a href="https://www.cnblogs.com/Simon-xm/p/4072986.html" target="_blank" rel="noopener">https://www.cnblogs.com/Simon-xm/p/4072986.html</a><br>Python——网络编程，如何避免死锁？<br>问题描述：什么是死锁？</p>
<p>死锁发生在当一个服务器和客户端同时试图往一个连接上写东西或同时从一个连接上读的时候。在这种情况下，没有进程可以得到任何数据（如果它们都正在读），因此，如果它们正在写，向外的buffer会被充满，结果他们就好象被骗了，什么都做不了。</p>
<p>示例服务器代码：</p>
<pre><code>import socket,traceback

host=&quot;&quot;
port=51423

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
sock.bind((host,port))
sock.listen(1)

while True:
    try:
        clientsock,clientaddr= sock.accept()
    except KeyboardInterrupt:
        raise
    except:
        traceback.print_exc()
        continue

    try:
        print(&quot;Got connection from &quot;,clientsock.getpeername)
        while True:
            data = clientsock.recv(4096)
            if not len(data):
                break
            clientsock.sendall(data)
    except (KeyboardInterrupt,SystemExit):
            raise
    except:
            traceback.print_exc()

    try:
        clientsock.close()
    except KeyboardInterrupt:
        raise
    except:
        traceback.print_exc()
</code></pre><p>示例客户端代码：</p>
<pre><code>import socket
import sys

port=51423
host=&quot;localhost&quot;

data=b&quot;x&quot;*10485760
sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((host,port))

byteswritten=0
while byteswritten&lt;len(data):
    startpos = byteswritten
    endpos = min(byteswritten+1024,len(data))
    byteswritten+=sock.send(data[startpos:endpos])
    sys.stdout.write(&quot;wrote %d bytes\r&quot;% byteswritten)
    sys.stdout.flush()

sock.shutdown(1)

print(&quot;All data sent.&quot;)
while True:
    buf = sock.recv(1024).decode()
    if not len(buf):
        break
    sys.stdout.write(buf)
</code></pre><p>在运行上述服务器代码的情况下运行客户端代码，得到如下结果：</p>
<p>服务器：<br>(ev1)[root@Simonxu bin]# python testserver.py<br>Got connection from  <built-in method="" getpeername="" of="" socket="" object="" at="" 0x7f5e18d2b460=""><br>客户端：<br>(ev1)[root@Simonxu bin]# python test.py<br>wrote 164864 bytes<br>可以看出，上述服务器和客户端卡在的wrote 164864 bytes。</built-in></p>
<p><strong>分析：</strong></p>
<p>已知客户端程序试图发送一个10MB的数据，每次传输1KB，同时显示发送数据动态，并在所有数据发送完成后，从服务器每次1KB读取并写数据。</p>
<p>而服务器在建立套接口连接后，从客户端每次读取4KB数据，在接收到数据后，直接把数据发回客户端。</p>
<p>而矛盾的是，由于客户端在发送一个10MB大小的数据，这要发送较长时间，在发送的过程中没有办法读取数据，因此服务器返回的数据就堆积在客户端的接收缓冲区。</p>
<p>当接收缓冲区满了之后，服务器的sendall（）函数发生错误，循环死锁，服务器不再接收客户端发来的数据。客户端也无法继续发送数据。就形成了上面的情况。</p>
<p><strong>如何避免死锁？</strong></p>
<ul>
<li><p>1、可以在客户端每次执行完send（）后，进行一次recv（）以接收服务器发来的数据，避免buffer充满。</p>
</li>
<li><p>2、可以让客户端发送的数据较少，这样在buffer充满之前就可以从缓冲区读取服务器发回的数据。</p>
</li>
<li><p>3、采用多线程或其他一些方法，使客户端可以同时发送和接收。</p>
</li>
</ul>
<p><strong>知识补充</strong></p>
<p>缓冲区：</p>
<ol>
<li><p>tcp 收发缓冲区默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/ipv4/tcp_rmem<br>　　4096    87380   4161536<br>　　87380  ：tcp接收缓冲区的默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/ipv4/tcp_wmem<br>　　4096    16384   4161536<br>　　16384  ： tcp 发送缓冲区的默认值</p>
</li>
<li><p>tcp 或udp收发缓冲区最大值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/rmem_max<br>　　131071<br>　　131071：tcp 或 udp 接收缓冲区最大可设置值的一半。<br>　　也就是说调用 setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;rcv_size, &amp;optlen);  时rcv_size 如果超过 131071，那么<br>　　getsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;rcv_size, &amp;optlen); 去到的值就等于 131071 * 2 = 262142<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/wmem_max<br>　　131071<br>　　131071：tcp 或 udp 发送缓冲区最大可设置值得一半。<br>　　跟上面同一个道理</p>
</li>
<li><p>udp收发缓冲区默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/rmem_default<br>　　111616：udp接收缓冲区的默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/wmem_default<br>　　111616<br>　　111616：udp发送缓冲区的默认值</p>
</li>
<li><p>tcp 或udp收发缓冲区最小值<br>　　tcp 或udp接收缓冲区的最小值为 256 bytes，由内核的宏决定；<br>　　tcp 或udp发送缓冲区的最小值为 2048 bytes，由内核的宏决定</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>什么是线程 </p>
<p>线程也是一种多任务编程方式，可以使用计算机的多核资源。线程被称为轻量级的进程。</p>
<h3 id="线程的特征"><a href="#线程的特征" class="headerlink" title="线程的特征"></a>线程的特征</h3><ul>
<li>线程是计算机多核分配的最小单位</li>
<li>一个进程可以包含多个线程</li>
<li>线程也是一个运行过程，也要消耗计算机资源。多个   线程共享进程的资源和空间</li>
<li>线程也拥有自己特有的资源属性，比如指令集，TID等</li>
<li>线程无论是创建删除还是运行消耗的资源都小于进程</li>
<li>多个线程之间并行执行，执行上互不干扰</li>
</ul>
<h3 id="threading-模块创建线程"><a href="#threading-模块创建线程" class="headerlink" title="threading 模块创建线程"></a>threading 模块创建线程</h3><p>threading.Thread()<br>功能 : 创建线程对象<br>参数 ：name  线程名称  默认为Thread-1<br>       target  线程函数<br>             args   元组  给线程函数位置传参<br>             kwargs 字典  给线程函数键值传参<br>返回 ： 线程对象</p>
<p>t.start()   启动线程<br>t.join([timeout])   回收线程</p>
<p>线程对象的属性<br>t.is_alive() 查看线程的状态<br>t.name  线程名称<br>t.setName()  设置线程名称<br>threading.currentThread()  获取当前线程对象</p>
<p><strong>t.daemon 属性<br>默认情况下主线的结束不会影响到分支线程的执行<br>如果设置为True 则主线程退出分支线程也会退出</strong></p>
<p>设置方法：<br>t.daemon = True<br>t.setDaemon(True)</p>
<p>判断daemon属性:<br>t.isDaemon()</p>
<ul>
<li>线程daemon属性的设置在start前</li>
<li>一般设置daemon后不会再使用join</li>
</ul>
<p>示例代码：</p>
<pre><code>import threading
import time
import os

a = 1
def music():
    # while True:
    global a
    a = 100
    for i in range(3):
        time.sleep(2)
        print(&quot;play music&quot;,os.getpid())

# for i in range(3):
#     time.sleep(2)
#     print(&quot;play game&quot;) 

t = threading.Thread(target = music)
t.start()
for i in range(5):
    time.sleep(2)
    print(&quot;play game&quot;,os.getpid()) 
t.join()

print(a)
</code></pre><p>运行结果:</p>
<pre><code>play game 8687
play music 8687
play game 8687
play music 8687
play game 8687
play music 8687
play game 8687
play game 8687
100
</code></pre><h3 id="创建自己的线程类"><a href="#创建自己的线程类" class="headerlink" title="创建自己的线程类"></a>创建自己的线程类</h3><p>步骤：<br>1.继承 Thread类<br>2.运行Thread类中的<strong>init</strong>方法以获取父类原有属性<br>3.重写run方法</p>
<p>示例代码：</p>
<pre><code>from threading import Thread
from time import ctime,sleep

class Mythread(Thread):
    def __init__(self,name=&quot;HMoon&quot;,target=None,args=(),kwargs={}):
        super().__init__()
        self.name = name
        self.target = target
        self.args = args
        self.kwargs = kwargs

    def fun(self):
        print(&quot;fdsggsdggh&quot;)
        self.target(*self.args)

def aaa(msg):
    print(&quot;aaaaa&quot;)
    print(msg)

t = Mythread(name= &quot;aaa&quot;,target=aaa,args=(&quot;fsaff&quot;,))
t.start()
t.join()
</code></pre><p>运行结果：</p>
<pre><code>fdsggsdggh
aaaaa
fsaff
</code></pre><p>作业 ： </p>
<ol>
<li>复习网络编程</li>
<li>司机和售票员<ul>
<li>创建父子进程 分别表示司机和售票员</li>
<li>当售票员捕捉到SIGINT信号，给司机发送SIGUSER1信   号，此时司机打印“老司机开车了”<br>当售票员捕捉到SIGQUIT信号，给司机发送SIGUSER2信号，此时司机打印：”车速有点快，系好安全带”<br>当司机捕捉到SIGTSTP信号，给售票员发送SIGUSER1,此时售票员打印“到站了请下车”</li>
</ul>
</li>
</ol>
<ul>
<li>到站后，售票员先下车（子进程先退出），然后司机   下车</li>
</ul>
<p>作业代码：<br>        import multiprocessing as mp<br>        from signal import *<br>        import sys,os<br>        import time</p>
<pre><code>def driver_handle(sig,frame):
    if sig == SIGUSR1:
        print(&quot;老司机开车了&quot;)
    elif sig  == SIGUSR2:
        print(&quot;车速有点快，系好安全带&quot;)
    elif sig == SIGTSTP:
        os.kill(p.pid,SIGUSR1)

def saler_handle(sig,frame):
    if sig == SIGINT:
        os.kill(os.getppid(),SIGUSR1)
    elif sig == SIGQUIT:
        os.kill(os.getppid(),SIGUSR2)
    elif sig == SIGUSR1:
        print(&quot;到站了,请下车&quot;)
        sys.exit(&quot;售票员下车&quot;)

def saler():
    signal(SIGINT,saler_handle)
    signal(SIGQUIT,saler_handle)
    signal(SIGUSR1,saler_handle)
    signal(SIGTSTP,SIG_IGN)
    while True:
        time.sleep(3)
        print(&quot;Python带你去远方&quot;)

p = mp.Process(target = saler)
p.start()

signal(SIGUSR1,driver_handle)
signal(SIGUSR2,driver_handle)
signal(SIGTSTP,driver_handle)
signal(SIGINT,SIG_IGN)
signal(SIGQUIT,SIG_IGN)

p.join()
</code></pre><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>  通信方法 : 多个线程共用进程空间，所以进程的全局量对进程内的线程均可见。因此线程间没有特有的通信方式往往使用全局变量通信</p>
<p>  注意事项 ：线程间使用全局变量通信往往需要同步互斥机制做为通信的安全保证</p>
<p>线程的同步互斥</p>
<h3 id="线程event对象"><a href="#线程event对象" class="headerlink" title="线程event对象"></a>线程event对象</h3><p>创建对象 ：<br>  e = threading.Event()<br>  e.wait([timeout])  如果e为设置状态则不会阻塞，未设置则阻塞<br>  e.set()   将e变为设置状态<br>  e.clear() 将e的设置去除</p>
<p>示例代码：</p>
<pre><code>import threading 
from time import sleep 

msg = None 

#创建事件对象
e = threading.Event()

def bar():
    print(&quot;呼叫foo&quot;)
    global msg 
    msg = &quot;天王盖地虎&quot;

def foo():
    print(&quot;等待口令&quot;)
    sleep(2)
    if msg == &quot;天王盖地虎&quot;:
        print(&quot;宝塔镇河妖,自己人,哈哈哈&quot;)
    else:
        print(&quot;口令错误,打死他&quot;)
    e.set()

def fun(): 
    print(&quot;呵呵....内奸出现&quot;)
    sleep(1)
    e.wait()
    global msg
    msg = &quot;小鸡炖蘑菇&quot; 

t1 = threading.Thread(target = bar)
t2 = threading.Thread(target = foo)
t3 = threading.Thread(target = fun)
t1.start()
t2.start()
t3.start()
t1.join()
t2.join()
t3.join()
</code></pre><p>运行结果：</p>
<pre><code>call foo
wait keyword
hehe...内奸出现
宝塔镇河妖，自己人，哈哈哈
</code></pre><h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>  lock = threading.Lock() 创建锁对象<br>  lock.acquire()  上锁<br>  lock.release()  解锁</p>
<pre><code>**在一个进程中对一个线程锁重复上锁则会阻塞
</code></pre><p>示例代码：</p>
<pre><code>import threading as th
import time
a = b = 0

lock = th.Lock()
def value():
    while True:
        lock.acquire()
        if a != b:
            print(&quot;a = %d  b = %d&quot;%(a,b))
        else:
            print(a,b)
        lock.release()

t = th.Thread(target= value)
t.start()

while True:
    lock.acquire()
    a += 1
    b += 1
    lock.release()
t.join()
</code></pre><p>运行结果片段：（需要ctrl+c结束死循环运行）<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937</p>
<h3 id="Python线程的GIL问题-（全局解释器锁）"><a href="#Python线程的GIL问题-（全局解释器锁）" class="headerlink" title="Python线程的GIL问题 （全局解释器锁）"></a>Python线程的GIL问题 （全局解释器锁）</h3><p>python —》 支持多线程 –》同步互斥 –》加锁 —》超级锁，给解释器加锁</p>
<p>后果 ： 一个解释器，同一时刻只能解释一个线程。因此大大降低了Python线程的执行效率</p>
<p><strong>Python 的GIL问题 解决方法</strong></p>
<ul>
<li>尽量使用进程方式并行</li>
<li>不适用c作为解释器，可以采用 c# java</li>
<li>Python线程适用于高延迟的IO操作，网络操作。不适合用cpu密集型程序。线程在遇到IO阻塞时会让出解释器和cpu</li>
</ul>
<p>效率测试 </p>
<p>分别测试 在 IO密集型程序和CPU密集型程序下，多进程，多线程，单进程执行效率</p>
<p>Line cpu: 8.061699390411377<br>Line IO: 5.261598348617554</p>
<p>Thread cpu: 8.920610427856445<br>Thread io: 5.60230565071106</p>
<p>process cpu: 4.07219386100769<br>Process io: 3.383375406265259</p>
<p>测试代码：</p>
<pre><code>import threading as th
import multiprocessing as mp
from time import ctime,sleep,time
&quot;&quot;&quot;
效率测试
分别测试在ＩＯ密集型和ＣＰＵ密集型下，多进程　多线程　单线程执行效率
&quot;&quot;&quot;

def count(x,y):
    # print(time())
    c = 0 
    while c &lt; 7000000:
        c += 1
        x += 1
        y += 1
    # print(time())

def mywrite():
    # print(ctime())
    f = open(&quot;test.txt&quot;,&quot;w&quot;)
    for x in range(1000000):
        f.write(&quot;hehehehehehehe&quot;)
    f.close()
    # print(ctime())

def myread():
    # print(ctime())
    f = open(&quot;test.txt&quot;,&quot;r&quot;)
    lines = f.readlines()
    # print(ctime())

def myio():
    mywrite()
    myread()
start = time()
jobs = []
for i in range(10):
    t = th.Thread(target = myio)
    jobs.append(t)
    t.start()
for i in jobs:
    i.join()
end = time()
print(end - start)
</code></pre><p><strong>进程和线程的区别和联系</strong></p>
<ul>
<li>1.两者都是多任务编程的方式，都能够使用计算机多核</li>
<li>2.进程的创建和删除要比线程消耗更多计算机资源</li>
<li>3.进程空间独立，数据安全性好，有专门的进程间通信方法</li>
<li>4.线程使用全局变量通信，更加简单，但是往往要与同步互斥机制公用</li>
<li>5.一个进程可以包含多个线程，线程共享进程的资源空间</li>
<li>6.进线程都有自己特有的资源，如命令，属性 id等</li>
</ul>
<p><strong>使用场景 : </strong></p>
<ul>
<li>需要创建较多的并发，任务比较简单时，线程比较合适</li>
<li>如果程序数据资源比较复杂，特别是共享资源较多时，   需要考虑到线程锁的复杂性</li>
<li>如果多个任务无必要的关联性，不易将其强行融入到一   个进程中</li>
<li>Python线程不适合cpu密集型程序</li>
</ul>
<p><strong>总结 ： </strong></p>
<ol>
<li>进程线程的区别和关系</li>
<li>进程间以什么方式通信，有什么特点</li>
<li>同步互斥的意义，有什么方法实现同步互斥</li>
<li>僵尸进程，进程状态，线程GIL的概念</li>
<li>给一个情景，问选择进程还是线程，怎么做为什么</li>
</ol>
<h1 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h1><p>硬件服务器 ： 主机  集群<br>厂商 ： IBM  HP  联想  浪潮</p>
<p>软件服务器 ： 编写的服务端程序，依托于硬件服务器运行，提供给用户一定的软件服务</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>webserver   —-》 网络后端程序提供网络请 求的后端处理和数据交互<br>httpserver  —-》 处理HTTP请求，回复http响应<br>邮箱服务器 —–》 提供邮箱服务<br>文件服务器 —–》 提供文件的上传下载</p>
<p>功能： 网络连接，逻辑处理，数据的交互，数据的传输 协议的实现</p>
<h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p> c/s  (客户端服务器模型)<br> b/s  (浏览器服务器模型)</p>
<p>服务器目标：处理速度快，数据更安全，并发量大 </p>
<p>硬件 ： 更高的配置，集成分布的技术，更好的网络速度，更多的主机，网络安全</p>
<p>软件 ： 程序占有更少的计算机资源，更稳定的运行效果，更流畅的运行速度，采用更合理的技术。处理更高的并发</p>
<h2 id="服务器模型-1"><a href="#服务器模型-1" class="headerlink" title="服务器模型"></a>服务器模型</h2><ul>
<li><p>循环服务器 ：单进程程序，循环的接收客户端的请求，处理请求，每处理完一个请求后再去接收处理下一个请求 </p>
<p> 优点 ： 实现简单，占用系统资源少<br> 缺点 ： 无法同时连接多个客户端，当一个客户端长期占有服务器时会形成其他客户端无法访问的情况<br> 使用情况：任务比较短暂，udp套接字更适合循环</p>
</li>
</ul>
<ul>
<li><p>并发服务器 ： 同时能够处理多个客户端的任务请求。并发可分为IO并发或者多进程多线程并发。</p>
<p>  IO并发 ： IO多路复用    协程</p>
<p>  优点：资源消耗少，适用于IO类型服务器<br>  缺点：不能监控CPU密集的情况，单线程，不能长期阻塞的消息的收发</p>
<p>  进程/线程并发：为每个客户端单独提供一个进程线程，处理客户端请求</p>
<p>  优点： 客户端可以长期占用服务器<br>  缺点： 消耗系统资源较多</p>
</li>
</ul>
<h2 id="多进程并发模型"><a href="#多进程并发模型" class="headerlink" title="多进程并发模型"></a>多进程并发模型</h2><p>使用fork完成并发</p>
<ul>
<li>1.创建套接字  绑定  监听</li>
<li>2.等待接收客户端请求 accept</li>
<li>3.创建子进程处理客户端请求，<br>父进程继续准备接收其他客户端连接</li>
<li>4.客户端退出则子进程结束</li>
</ul>
<h2 id="tftp文件服务器"><a href="#tftp文件服务器" class="headerlink" title="tftp文件服务器"></a>tftp文件服务器</h2><p>项目功能 ： </p>
<ul>
<li>客户端有简单的页面命令提示</li>
<li><p>功能包含</p>
<ol>
<li>查看服务端文件库文件列表</li>
<li>下载其中的某个文件到本地</li>
<li>将本地文件上传到服务器文件库中</li>
<li>退出</li>
</ol>
</li>
<li><p>服务端需要：<br> 1.处理客户端的各种请求<br> 2.允许多个客户端同时进行操作</p>
</li>
</ul>
<p>技术分析 ：<br>        tcp套接字<br>        并发 —》 多进程<br>        对文件的读写发送操作<br>        查看文件列表时需要考虑到粘包问题</p>
<p>整体结构 ：功能封装在类中（上传，下载，查看列表）</p>
<pre><code>流程控制使用main（）
          创建套接字，创建连接创建进程，接收请求
</code></pre><p>作业 ： 完成 get  和 put功能</p>
<p>服务器端代码：</p>
<pre><code>&apos;&apos;&apos;
tftp 文件服务器程序
&apos;&apos;&apos;
from socket import * 
import os 
import signal 
import sys 
import time 

#文件库路径
FILE_PATH = &quot;/home/tarena/&quot;

#实现服务器功能模块
class TftpServer(object):
    def __init__(self,connfd):
        self.connfd = connfd
    def do_list(self):
        #获取列表
        file_list = os.listdir(FILE_PATH)
        if not file_list:
            self.connfd.send(&apos;文件库为空&apos;.encode())
            return 
        else:
            self.connfd.send(b&apos;OK&apos;)
            time.sleep(0.1)

        files = &quot;&quot;
        for file in file_list:
            if file[0] != &apos;.&apos; and \
            os.path.isfile(FILE_PATH + file):
                files = files + file + &apos;#&apos;
        self.connfd.send(files.encode())     


    def do_get(self,filename):
        try:
            fd = open(FILE_PATH + filename,&apos;rb&apos;)
        except:
            self.connfd.send(&quot;文件不存在&quot;.encode())
            return
        self.connfd.send(b&quot;OK&quot;)
        time.sleep(0.1) 
        #发送文件
        try:
            for line in fd:
                self.connfd.send(line)
            fd.close()
        except Exception as e:
            print(e)
        time.sleep(0.1)
        self.connfd.send(b&apos;##&apos;)
        print(&quot;文件发送完毕&quot;)


    def do_put(self,filename):
        try:
            fd = open(FILE_PATH + filename,&apos;w&apos;)
        except:
            self.connfd.send(&quot;无法完成上传&quot;)
        self.connfd.send(b&apos;OK&apos;)
        while True:
            data = self.connfd.recv(1024).decode()
            if data == &quot;##&quot;:
                break
            fd.write(data)
        fd.close()
        print(&quot;上传完毕&quot;)

#流程控制,创建套接字连接,接收请求
def main():
    HOST = &apos;0.0.0.0&apos;
    PORT = 8888
    ADDR = (HOST,PORT)

    sockfd = socket()
    sockfd.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
    sockfd.bind(ADDR)
    sockfd.listen(5)

    signal.signal(signal.SIGCHLD,signal.SIG_IGN)
    print(&quot;Listen to port 8888....&quot;)

    while True:
        try: 
            connfd,addr = sockfd.accept()
        except KeyboardInterrupt:
            sockfd.close()
            sys.exit(&quot;服务器退出&quot;)
        except Exception as e:
            print(e)
            continue
        print(&quot;客户端登录:&quot;,addr)
        #创建父子进程
        pid = os.fork()
        if pid &lt; 0:
            print(&quot;创建子进程失败&quot;)
            continue
        elif pid == 0:
            sockfd.close()
            tftp = TftpServer(connfd)
            #接收客户端请求
            while True:
                data = connfd.recv(1024).decode()
                if not data:
                    continue
                elif data[0] == &apos;L&apos;:
                    tftp.do_list()
                #data ==&gt; G filename
                elif data[0] == &apos;G&apos;:
                    filename = data.split(&apos; &apos;)[-1]
                    tftp.do_get(filename)
                elif data[0] == &apos;P&apos;:
                    filename = data.split(&apos; &apos;)[-1]
                    tftp.do_put(filename)
                elif data[0] == &apos;Q&apos;:
                    print(&quot;客户端退出&quot;)
                    sys.exit(0)

        else:
            connfd.close()
            continue

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>客户端代码：</p>
<pre><code>from socket import * 
import sys 
import time 

#实现基本的请求功能
class TftpServer(object):
    def __init__(self,sockfd):
        self.sockfd = sockfd

    def do_list(self):
        self.sockfd.send(b&quot;L&quot;) #发送请求类型
        #等待接收服务器端确认
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            data = self.sockfd.recv(4096).decode()
            files = data.split(&apos;#&apos;)
            for file in files:
                print(file)
            print(&quot;%%%%%文件列表展示完毕%%%%%\n&quot;)
        else:
            #失败的原因由服务器发送过来
            print(data)


    def do_get(self,filename):
        self.sockfd.send((&apos;G &apos;+filename).encode())
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            fd = open(filename,&apos;w&apos;)
            while True:
                data = self.sockfd.recv(1024).decode()
                if data == &quot;##&quot;:
                    break
                fd.write(data)
            fd.close()
            print(&quot;%s 下载完成\n&quot;%filename)
        else:
            print(data)

    def do_put(self,filename):
        try:
            fd = open(filename,&apos;rb&apos;)
        except:
            print(&quot;上传的文件不存在&quot;)
            return
        self.sockfd.send((&quot;P &quot; + filename).encode())
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            for line in fd:
                self.sockfd.send(line)
            fd.close()
            time.sleep(0.1)
            self.sockfd.send(b&apos;##&apos;)
            print(&quot;%s 文件上传完毕&quot;%filename)
        else:
            print(data)


    def do_quit(self):
        self.sockfd.send(b&apos;Q&apos;)


#套接字连接
def main():
    if len(sys.argv) &lt; 3:
        print(&quot;argv is error&quot;)
        return 
    HOST = sys.argv[1]
    PORT = int(sys.argv[2])
    ADDR = (HOST,PORT)

    sockfd = socket()
    sockfd.connect(ADDR)

    tftp = TftpServer(sockfd) #tftp对象调用请求方法

    while True:
        print(&quot;=======命令选项========&quot;)
        print(&quot;******* list *********&quot;)
        print(&quot;*******get file ******&quot;)
        print(&quot;*******put file ******&quot;)
        print(&quot;******* quit *********&quot;)
        print(&quot;======================&quot;)

        cmd = input(&quot;请输入命令&gt;&gt;&quot;)

        if cmd.strip() == &apos;list&apos;:
            tftp.do_list()
        elif cmd[:3] == &quot;get&quot;:
            filename = cmd.split(&apos; &apos;)[-1]
            tftp.do_get(filename)
        elif cmd[:3] == &quot;put&quot;:
            filename = cmd.split(&apos; &apos;)[-1]
            tftp.do_put(filename)
        elif cmd.strip() == &quot;quit&quot;:
            tftp.do_quit()
            sockfd.close()
            sys.exit(&quot;欢迎使用&quot;) 
        else:
            print(&quot;请输入正确的命令!!!&quot;)
            continue

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><hr>
<p>*小贴士：</p>
<p>文件处理函数</p>
<p>os.listdir(PATH) : 获取一个目录内文件列表<br>os.path.isfile() :判断一个文件的类型是否为普通文件<br>os.path.isdir() ：判断一个文件的类型是否为目录*</p>
<hr>
<h2 id="threading-的多线程并发"><a href="#threading-的多线程并发" class="headerlink" title="threading 的多线程并发"></a>threading 的多线程并发</h2><p>对比多进程并发：<br>优点 ： 资源消耗少<br>缺点 ： 需要注意共享资源的争夺<br>        Python多线程收到GIL的影响</p>
<p>实现步骤：</p>
<ul>
<li>1 创建套接字，绑定，监听</li>
<li>2 接收客户端连接请求，创建新的线程</li>
<li>3 主线程继续等待其他客户端连接，分支线程执行客户    端请求</li>
<li>4 处理完客户端请求后，分支线程退出，关闭客户端套    接字</li>
</ul>
<p>socket服务器集成模块</p>
<p>python2  SocketServer<br>python3  socketserver</p>
<p>功能 ： 通过模块的接口完成基于多进程/多线程的tcp/udp 的socket并发程序</p>
<p>模块类</p>
<p>DatagramRequestHandler  处理udp请求<br>StreamRequestHandler    处理tcp请求</p>
<p>UDPServer   提供udp服务端类<br>TCPServer   提供tcp服务端类</p>
<p>ForkingMixIn   提供进程创建<br>ForkingTCPServer   ==》ForkingMixIn + TCPServer<br>ForkingUDPServer   ==》ForkingMixIn + UDPServer</p>
<p>ThreadingMixIn  提供线程创建<br>ThreadingTCPServer  ==》ThreadingMixIn + TCPServer<br>ThreadingUDPServer  ==》ThreadingMixIn + TCPServer</p>
<p>基于多线程并发的 HTTPServer</p>
<p>HTTPServer的作用 </p>
<ul>
<li>1.就收浏览器发送的http请求</li>
<li>2.对http请求进行解析</li>
<li>3.组织响应内容进行回发</li>
</ul>
<p>升级</p>
<ul>
<li>使用多线程的并发可以同时处理多个客户端请求</li>
<li>增加简单的应用程序，使浏览器不仅可以访问静态网页也可以访问后台程序</li>
<li>使用类对服务器功能模块进行封装</li>
</ul>
<p>技术点 ： threading 并发<br>          tcp socket 套接字<br>                    http协议响应内容进行字符串拼接</p>
<p>代码示例：<br>        ‘’’<br>        http server 第二版<br>        ‘’’<br>        from socket import *<br>        from threading import Thread<br>        import time </p>
<pre><code>ADDR = (&apos;0.0.0.0&apos;,8000)
#存放静态页面的目录
STATIC_DIR = &quot;./static&quot;

#httpserver类 封装服务器功能
class HTTPServer(object):
    def __init__(self,addr): 
        #套接字创建
        self.sockfd = socket()
        self.sockfd.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
        self.sockfd.bind(addr)
        self.sockfd.listen(5)
        #为对象添加一些属性
        self.name = &quot;HttpServer&quot;
        self.port = 8000
        self.address = addr

    # 监听客户端的链接请求,创建新的线程处理
    def serve_forever(self):
        print(&quot;Listen to port 8000.....&quot;)
        while True:
            connfd,addr = self.sockfd.accept()
            #创建新的线程处理具体请求
            clientThread = Thread(target = self.handleRequest,args = (connfd,))

            clientThread.setDaemon(True)
            clientThread.start()

    def handleRequest(self,connfd):
        #接收客户端请求
        request = connfd.recv(4096)
        requestHeadlers = request.splitlines()
        #请求行
        print(connfd.getpeername(),&quot;:&quot;,requestHeadlers[0])
        #获取具体请求
        getRequest = str(requestHeadlers[0]).split(&apos; &apos;)[1]

        #访问静态网页
        if getRequest[-3:] != &quot;.py&quot;:
            if getRequest == &apos;/&apos;:
                getFilename = STATIC_DIR + &quot;/index.html&quot;
            else:
                getFilename = STATIC_DIR + getRequest

            try:
                f = open(getFilename)
            except Exception:
                #没有找到页面
                responseHeaders = &quot;HTTP/1.1 404 not found\r\n&quot;
                responseHeaders += &quot;\r\n&quot;
                responseBody = &quot;===Sorry,the page not found===&quot;
            else:
                responseHeaders = &quot;HTTP/1.1 200 OK\r\n&quot;
                responseHeaders += &quot;\r\n&quot;
                responseBody = f.read()
            finally:
                response = responseHeaders + responseBody
                connfd.send(response.encode())
        #访问后台程序
        else:
            #通过函数得到响应体
            responseBody = self.application()

            responseHeaders = &quot;HTTP/1.1 200 OK\r\n&quot;
            responseHeaders += &quot;\r\n&quot;
            response = responseHeaders + responseBody

            connfd.send(response.encode())

        connfd.close()

    #获取去你要使用的外部函数,变为属性
    def setApp(self,application):
        self.application = application 


#后台程序
def app():
    return &quot;\n===假设这是一个很复杂的程序,你得到了一个很牛逼的内容===\n%s&quot;%time.ctime()


if __name__ == &quot;__main__&quot;:
    httpd = HTTPServer(ADDR)
    httpd.setApp(app)
    #启动服务器
    httpd.serve_forever()
</code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>定义： 纤程 微线程 ，协程本质只有一个线程在运行</p>
<p>功能原理 ： 通过应用层程序，记录上下文栈区，实现在程序执行过程中的跳跃，选择可以不阻塞的部分执行，从而提高IO的执行效率</p>
<p><strong>优点 ： </strong><br>资源消耗很少<br>无需多线程那样来回切换的开销<br>无需进行同步互斥操作<br>IO并发性好</p>
<p><strong>缺点 ： </strong><br>无法利用计算机的多核资源<br>程序不能够一个客户端单独长时间占有服务端</p>
<p>yield–&gt; 协程的基本实现关键字</p>
<pre><code>sudo pip3 install  greenlet
sudo pip3 install  gevent

greenlet 
greenlet.greenlet()
gr.switch()
</code></pre><p>示例代码：</p>
<pre><code>from greenlet import greenlet

def test1():
    print(12)
    gr2.switch()
    s =  input(&quot;t1 input: &quot;)
    print(&quot;s= &quot;,s)
    print(34)
    gr2.switch()

def test2():
    print(56)
    gr1.switch()
    print(78)

gr1 = greenlet(test1)
gr2 = greenlet(test2)

gr1.switch()
</code></pre><p>gevent</p>
<ul>
<li>将协程事件封装为函数</li>
</ul>
<p>gevent.spawn(func,argv)<br>功能 ： 将事件变为协程事件并启动<br>参数 ： func  传入一个函数变为协程<br>        argv  给func函数传参<br>返回值 ： 协程对象</p>
<p>gevent.joinall()<br>功能：回收协程</p>
<p>gevent.sleep(n)<br>功能 ； 模拟IO阻塞的情况</p>
<pre><code>from gevent import  monkey
monkey.patch_all()
</code></pre><p>功能 ： 在导入socket模块之前使用，修改socket的IO设置行为</p>
<p>示例代码：</p>
<pre><code>import gevent
from gevent import monkey

def foo():
    print(&quot;run in foo&quot;)
    gevent.sleep(2)
    print(&quot;switch to foo again&quot;)

def bar():
    print(&quot;run in bar&quot;)
    gevent.sleep(3)
    print(&quot;switch to bar again&quot;)

f = gevent.spawn(foo)
b = gevent.spawn(bar)

gevent.joinall([b,f])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/图/" itemprop="url">图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T09:07:51+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,248 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>python数据结构之图的实现，官方有一篇文章介绍，<br><a href="https://www.python.org/doc/essays/graphs/" target="_blank" rel="noopener">https://www.python.org/doc/essays/graphs/</a></p>
<p><strong>图</strong>是由边或弧连接的节点组成的网络。<br>在<strong>有向图</strong>中，节点之间的连接有一个方向，称为弧;在<strong>无向图</strong>中，连接没有方向，称为边。<br>我们主要讨论<strong>有向图</strong>。图中的算法包括找到两个节点之间的路径，找到两个节点之间的最短路径，确定图中的周期（周期是从节点到自身的非空路径），找到到达所有节点的路径（着名的“旅行商问题”），等等。有时图形的节点或弧具有与它们相关的权重或成本，我们有兴趣找到最便宜的路径。<br>关于图算法的文献很多，它们是离散数学的重要组成部分。图形在计算机算法中也有很多实际用途。在网络管理中可以找到明显的例子，但许多其他领域的例子比比皆是。例如，计算机程序中的调用者 - 被调用者关系可以被视为图形（其中周期指示递归，并且不可达的节点表示死节点）。</p>
<h2 id="列表和词典构建法"><a href="#列表和词典构建法" class="headerlink" title="列表和词典构建法"></a>列表和词典构建法</h2><p>很少有编程语言直接支持图形作为数据类型，Python也不例外。但是，图表很容易从列表和词典中构建。例如，这是一个简单的图形（我不能在这些列中使用图纸，所以我写下图形的弧形）：</p>
<pre><code>A -&gt; B
A -&gt; C
B -&gt; C
B -&gt; D
C -&gt; D
D -&gt; C
E -&gt; F
F -&gt; C
</code></pre><p>该图有六个节点（A-F）和八个弧。它可以由以下Python数据结构表示：</p>
<pre><code>graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
         &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
         &apos;C&apos;: [&apos;D&apos;],
         &apos;D&apos;: [&apos;C&apos;],
         &apos;E&apos;: [&apos;F&apos;],
         &apos;F&apos;: [&apos;C&apos;]}
</code></pre><p>这是一个字典，其键是图的节点。对于每个键，相应的值是一个列表，其中包含通过此节点的直接弧连接的节点。这很简单（更简单的是，节点可以用数字而不是名字来表示，但名称更方便，可以很容易地携带更多信息，例如城市名称）。<br>让我们编写一个简单的函数来确定两个节点之间的路径。它需要一个图形，并将起始和结束节点作为参数。它将返回包含路径的节点列表（包括开始和结束节点）。如果找不到路径，则返回None。同一节点在返回的路径上不会出现多次（即它不包含循环）。该算法使用一种称为回溯的重要技术：它依次尝试每种可能性，直到找到解决方案。</p>
<pre><code>def find_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if not graph.has_key(start):
        return None
    for node in graph[start]:
        if node not in path:
            newpath = find_path(graph, node, end, path)
            if newpath: return newpath
    return None
</code></pre><p>A sample run (using the graph above):<br>    &gt;&gt;&gt; find_path(graph, ‘A’, ‘D’)<br>    [‘A’, ‘B’, ‘C’, ‘D’]<br>    &gt;&gt;&gt;<br>第二个“if”语句仅在存在被列为弧的终点但没有外部弧的节点的情况下才是必需的，并且根本没有在图中列出。这样的节点也可以包含在图中，带有一个空的传出弧列表，但有时候更方便的是不要求它。<br>请注意，当用户使用三个参数调用find_graph（）时，它会使用第四个参数调用自身：已遍历的路径。此参数的默认值是空列表’[]’，表示尚未遍历任何节点。该参数用于避免循环（’for’循环内的第一个’if’）。 ‘path’参数未被修改：赋值“path = path + [start]”创建一个新列表。如果我们改写了“path.append（start）”，我们就会在调用者中修改变量’path’，结果是灾难性的。 （使用元组，我们可以肯定这不会发生，代价是必须编写“path = path +（start，）”，因为“（start）”不是单例元组 - 它只是一个括号表达。）</p>
<p>我们能轻易的更改此函数以返回所有路径（没有循环）的列表，而不是它找到的第一个路径：</p>
<pre><code>def find_all_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    if not graph.has_key(start):
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            newpaths = find_all_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths
</code></pre><p>运行示例:</p>
<pre><code>&gt;&gt;&gt; find_all_paths(graph, &apos;A&apos;, &apos;D&apos;)
[[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;], [&apos;A&apos;, &apos;B&apos;, &apos;D&apos;], [&apos;A&apos;, &apos;C&apos;, &apos;D&apos;]]
&gt;&gt;&gt; 
</code></pre><p>另一个方法找到最短路径：</p>
<pre><code>def find_shortest_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if not graph.has_key(start):
        return None
    shortest = None
    for node in graph[start]:
        if node not in path:
            newpath = find_shortest_path(graph, node, end, path)
            if newpath:
                if not shortest or len(newpath) &lt; len(shortest):
                    shortest = newpath
    return shortest
</code></pre><p>运行示例:<br>    &gt;&gt;&gt; find_shortest_path(graph, ‘A’, ‘D’)<br>    [‘A’, ‘C’, ‘D’]<br>    &gt;&gt;&gt; </p>
<p>这些功能非常简单。 然而，它们几乎是最优的（对于用Python编写的代码）。 在另一个Python Patterns专栏中，我将尝试分析其运行速度并提高其性能，代价是更多代码。<br>另一种变化是添加更多数据抽象：创建一个表示图的类，其方法实现各种算法。 虽然这吸引了对结构化编程的渴望，但它并没有使代码更有效（相反）。 它确实可以更容易地向节点或弧添加各种标签，并添加将这些标签考虑在内的算法（例如，找到地图上两个城市之间的最短路径）。 这也是另一个专栏的主题。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>会将每个结点可能的邻居位置排成一行（也就是一个数组，用于对应图中每一个结点），然后用某种值（如True或False）来表示相关结点是否为当前结点的邻居。为了让矩阵具有更好的可读性，我们将会用1和0来充当所谓的真值（也可用True和False）。</p>
<pre><code>v0,v1,v2,v3,v4,v5=range(6)
N=[[0,1,0,0,0,1],#v0
   [0,0,1,0,0,0],#v1
   [0,0,0,1,0,0],#v2
   [0,0,0,0,1,1],#v3
   [1,0,0,0,0,0],#v4 
   [0,0,1,0,1,0]]#v5 

   &gt;&gt;&gt; N[v0][v1]
1
&gt;&gt;&gt; sum(N[v0])
2
</code></pre><p>将邻接矩阵扩展成允许对边进行加权处理：在原来存储真值的地方直接存储相关的权值即可。例如，对于边（u,v）来说，我们只需要将N[u][v]处的True替换成w(u,v)即可，我们通常会将一些不存在的边的权值设置为无穷大。<br>对角线上的值依旧应该全为0，任何节点到自身的距离都应该始终为0。</p>
<p>把上面的代码改为：</p>
<pre><code>v0,v1,v2,v3,v4,v5=range(6)  
inf=float(&apos;inf&apos;)  
w=N=[[0,5,inf,inf,inf,2],#v0  
   [inf,0,4,inf,inf,inf],#v1
   [inf,inf,0,9,inf,inf],#v2
   [inf,inf,inf,0,7,3],#v3
   [1,inf,inf,inf,0,inf],#v4
   [inf,inf,1,inf,8,0]]#v5 
&gt;&gt;&gt;w[v0][v1]
Out[6]: 
5
&gt;&gt;&gt;w[v2][v1]
Out[7]: 
inf
</code></pre><h2 id="图的创建和广度深度遍历"><a href="#图的创建和广度深度遍历" class="headerlink" title="图的创建和广度深度遍历"></a>图的创建和广度深度遍历</h2><pre><code>class Graph(object):
    def __init__(self, maps):
        self.maps = maps
        self.nodenum = self.get_nodenum()
        self.edgenum = self.get_edgenum()

    def get_nodenum(self):
        return len(self.maps)

    def get_edgenum(self):
        count = 0
        for i in range(self.nodenum):
            for j in range(i):
                if self.maps[i][j] &gt; 0:
                    count += 1
        return count

    def insert_node(self):
        for i in range(len(self.maps)):
            self.maps[i].append(-1)
        self.maps.append([-1]*(self.nodenum) + [0])
        self.nodenum += 1

    def insert_edge(self, x, y, weight):
        if x &lt; 0 or x &gt;= self.nodenum or y &lt; 0 or y &gt; self.nodenum or weight &lt;= 0 or x == y:
            return
        else:
            self.maps[x][y] = self.maps[y][x] = weight
            self.edgenum += 1

    def breath_first_search(self):
        queue = []
        visited = [False]*self.nodenum
        res = []
        def bfs():
            while len(queue) &gt; 0:
                i = queue.pop(0)
                for j in range(self.nodenum):
                    if self.maps[i][j] &gt; 0 and visited[j] == False:
                        res.append(j)
                        visited[j] = True
                        queue.append(j)

        if self.nodenum &lt;= 0:
            return res
        else:
            queue.append(0)#index, value
            visited[0] = True
            res.append(0)
            bfs()

        for i in range(self.nodenum):
            if visited[i] == False:
                res.append(i)
                visited[i] = True
                queue.append(i)
                bfs()

        return res

    def depth_first_search(self):
        res = []
        visited = [False]*self.nodenum
        def dfs(i):
            res.append(i)
            visited[i] = True
            for j in range(self.nodenum):
                if self.maps[i][j] &gt; 0 and visited[j] == False:
                    dfs(j)
        if self.nodenum &gt; 0:
            dfs(0)
        for i in range(self.nodenum):
            if visited[i] == False:
                dfs(i)
</code></pre><p><strong>测试用例</strong><br>    maps = [[0,3,9,-1], [3,0,-1,5], [9,-1,0,-1], [-1,5,-1,0]]<br>    graph = Graph(maps)<br>    print(‘邻接矩阵为\n%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    graph.insert_node()<br>    print(‘——-插入一个节点——–’)<br>    print(‘邻接矩阵为%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    graph.insert_edge(0, 4, 7)<br>    print(‘——-插入一个边——–’)<br>    print(‘邻接矩阵为%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    print(‘——-广度优先遍历——–’)<br>    print(graph.breath_first_search())<br>    print(‘——-深度优先遍历——–’)<br>    print(graph.depth_first_search())</p>
<p><strong>测试结果</strong><br>    邻接矩阵为<br>    [[0, 3, 9, -1], [3, 0, -1, 5], [9, -1, 0, -1], [-1, 5, -1, 0]]<br>    节点数据为4，边数为3</p>
<pre><code>-------插入一个节点--------
邻接矩阵为[[0, 3, 9, -1, -1], [3, 0, -1, 5, -1], [9, -1, 0, -1, -1], [-1, 5, -1, 0, -1], [-1, -1, -1, -1, 0]]
节点数据为5，边数为3

-------插入一个边--------
邻接矩阵为[[0, 3, 9, -1, 7], [3, 0, -1, 5, -1], [9, -1, 0, -1, -1], [-1, 5, -1, 0, -1], [7, -1, -1, -1, 0]]
节点数据为5，边数为4

-------广度优先遍历--------
[0, 1, 2, 4, 3]
-------深度优先遍历--------
[0, 1, 3, 2, 4]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/树的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/树的实现/" itemprop="url">树的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T20:08:00+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,988 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="普通树的实现"><a href="#普通树的实现" class="headerlink" title="普通树的实现"></a>普通树的实现</h1><pre><code>class TreeNode(object):
    &quot;&quot;&quot;The basic node of tree structure&quot;&quot;&quot;

    def __init__(self, name, parent=None):
        super(TreeNode, self).__init__()
        self.name = name
        self.parent = parent
        self.child = {}

    def __repr__(self) :
        return &apos;TreeNode(%s)&apos; % self.name


    def __contains__(self, item):
        return item in self.child


    def __len__(self):
        &quot;&quot;&quot;return number of children node&quot;&quot;&quot;
        return len(self.child)

    def __bool__(self, item):
        &quot;&quot;&quot;always return True for exist node&quot;&quot;&quot;
        return True

    @property
    def path(self):
        &quot;&quot;&quot;return path string (from root to current node)&quot;&quot;&quot;
        if self.parent:
            return &apos;%s %s&apos; % (self.parent.path.strip(), self.name)
        else:
            return self.name

    def get_child(self, name, defval=None):
        &quot;&quot;&quot;get a child node of current node&quot;&quot;&quot;
        return self.child.get(name, defval)

    def add_child(self, name, obj=None):
        &quot;&quot;&quot;add a child node to current node&quot;&quot;&quot;
        if obj and not isinstance(obj, TreeNode):
            raise ValueError(&apos;TreeNode only add another TreeNode obj as child&apos;)
        if obj is None:
            obj = TreeNode(name)
        obj.parent = self
        self.child[name] = obj
        return obj

    def del_child(self, name):
        &quot;&quot;&quot;remove a child node from current node&quot;&quot;&quot;
        if name in self.child:
            del self.child[name]

    def find_child(self, path, create=False):
        &quot;&quot;&quot;find child node by path/name, return None if not found&quot;&quot;&quot;
        # convert path to a list if input is a string
        path = path if isinstance(path, list) else path.split()
        cur = self
        for sub in path:
            # search
            obj = cur.get_child(sub)
            if obj is None and create:
                # create new node if need
                obj = cur.add_child(sub)
            # check if search done
            if obj is None:
                break
            cur = obj
        return obj

    def items(self):
        return self.child.items()

    def dump(self, indent=0):
        &quot;&quot;&quot;dump tree to string&quot;&quot;&quot;
        tab = &apos;    &apos;*(indent-1) + &apos; |- &apos; if indent &gt; 0 else &apos;&apos;
        print(&apos;%s%s&apos; % (tab, self.name))
        for name, obj in self.items():
            obj.dump(indent+1)
</code></pre><h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><pre><code>class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None

    def insertLeft(self, newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild
            self.leftChild = t

    def insertRight(self, newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self, obj):
        self.key = obj

    def getRootVal(self):
        return self.key
</code></pre><h1 id="哈夫曼树及python实现"><a href="#哈夫曼树及python实现" class="headerlink" title="哈夫曼树及python实现"></a>哈夫曼树及python实现</h1><p>哈夫曼（huffman）树<br>基本概念<br>路径和路径长度：树中一个结点到另一个结点之间的分支构成这两个结点之间的路径；路径上的分枝数目称作路径长度，它等于路径上的结点数减1.<br>结点的权和带权路径长度：在许多应用中，常常将树中的结点赋予一个有着某种意义的实数，我们称此实数为该结点的权；结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积.<br>树的带权路径长度：为树中所有叶子结点的带权路径长度之和，公式为：<br>WPL=∑i=1nwili<br>其中，n表示叶子结点的数目，wi和li分别表示叶子结点ki的权值和树根结点到ki之间的路径长度。<br>如下图中树的带权路径长度 WPL = 9 x 2 + 12 x 2 + 15 x 2 + 6 x 3 + 3 x 4 + 5 x 4 = 122</p>
<p>哈夫曼树：哈夫曼树又称最优二叉树。它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度 WPL 最小的二叉树。</p>
<p>构造方法： 将最小的2个数，小的放左边，合并在一起，然后得到一个新数，将所有数再取最小的2个，左小右大，再次合并，以此类推直到最后一个数的时候结束 </p>
<p>构建哈夫曼树<br>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>
<p>将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；<br>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>从森林中删除选取的两棵树，并将新树加入森林；<br>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p>
<img src="/2018/08/09/树的实现/2018/08/09/树的实现/aa.jpg" title="这是一个新的博客的图片的说明">
<p>注意：</p>
<p>为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。<br>如果还是不清楚过程，可以参考<br><a href="https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html，过程介绍的更清晰。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html，过程介绍的更清晰。</a></p>
<p>哈夫曼编码<br>等长编码：这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）。假设字符集只含有4个字符A，B，C，D，用二进制两位表示的编码分别为00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为14位。当接收方接收到这段电文后，将按两位一段进行译码。这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</p>
<p>不等长编码：在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编码。例如，可以为A，B，C，D四个字符分别分配0，00，1，01，并可将上述电文用二进制序列：000011010发送，其长度只有9个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面4个0是4个A，1个B、2个A，还是2个B，即译码不唯一，因此这种编码方法不可使用。<br>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀，这宗编码称为前缀编码（prefix code）。</p>
<ol>
<li>利用字符集中每个字符的使用频率作为权值构造一个哈夫曼树； </li>
<li>从根结点开始，为到每个叶子结点路径上的左分支赋予0，右分支赋予1，并从根到叶子方向形成该叶子结点的编码.</li>
</ol>
<p>假设一个文本文件TFile中只包含7个字符{a，b，c，d，e，f}，这7个字符在文本中出现的次数为{9，12，6，3，5，15}<br>通过哈夫曼树来构造的编码称为哈弗曼编码（huffman code） </p>
<p>9 12 6 3 5 15<br>9 12 6 8 15<br>9 12 14 15<br>21 29<br>50<br>0表示左 1表示右<br>9-00<br>12 - 01<br>6 - 100<br>3 - 1010<br>5 - 1011<br>15 - 11</p>
<p>a 的编码为：00<br>b 的编码为：01<br>c 的编码为：100<br>d 的编码为：1010<br>e 的编码为：1011<br>f 的编码为：11</p>
<p>Python实现<br>若带编码字符的个数，即树中叶结点的最大个数为n时，哈夫曼树的总节点数为2n-1<br><strong>节点类</strong></p>
<pre><code>class Node(object):
    def __init__(self,name=None,value=None):
        self._name=name
        self._value=value
        self._left=None
        self._right=None
</code></pre><p><strong>哈夫曼树类</strong></p>
<p>class HuffmanTree(object):</p>
<pre><code>#根据Huffman树的思想：以叶子节点为基础，反向建立Huffman树
def __init__(self,char_weights):
    self.a=[Node(part[0],part[1]) for part in char_weights]  #根据输入的字符及其频数生成叶子节点
    while len(self.a)!=1:    
        self.a.sort(key=lambda node:node._value,reverse=True)
        c=Node(value=(self.a[-1]._value+self.a[-2]._value))
        c._left=self.a.pop(-1)
        c._right=self.a.pop(-1)
        self.a.append(c)
    self.root=self.a[0]
    self.b=range(10)          #self.b用于保存每个叶子节点的Haffuman编码,range的值只需要不小于树的深度就行

#用递归的思想生成编码
def pre(self,tree,length):
    node=tree
    if (not node):
        return
    elif node._name:
        print node._name + &apos;的编码为:&apos;,
        for i in range(length):
            print self.b[i],
        print &apos;\n&apos;
        return
    self.b[length]=0
    self.pre(node._left,length+1)
    self.b[length]=1
    self.pre(node._right,length+1)

 #生成哈夫曼编码   
def get_code(self):
    self.pre(self.root,0)

if __name__==&apos;__main__&apos;:
    #输入的是字符及其频数
    char_weights=[(&apos;a&apos;,5),(&apos;b&apos;,4),(&apos;c&apos;,10),(&apos;d&apos;,8),(&apos;f&apos;,15),(&apos;g&apos;,2)]
    tree=HuffmanTree(char_weights)
    tree.get_code()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/排序算法/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T19:23:55+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,553 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python实现一些常用排序算法"><a href="#Python实现一些常用排序算法" class="headerlink" title="Python实现一些常用排序算法"></a>Python实现一些常用排序算法</h1><h2 id="系统内置排序算法"><a href="#系统内置排序算法" class="headerlink" title="系统内置排序算法"></a>系统内置排序算法</h2><p>list.sort()</p>
<p>heapq模块</p>
<pre><code>def sys_heap_sort(list):
    import heapq
    heap = []
    for i in range(len(list)):
        heapq.heappush(heap,list[i])
    for i in range(len(heap)):
        list[i] = heapq.heappop(heap)
</code></pre><p>python操作列表的方法，它们的<strong>时间复杂度</strong></p>
<pre><code>insert() ---&gt;  O(n)

remove()  ---&gt; O(n)

append()  -----&gt; O(1)

in 　　　------&gt;  0(n)
</code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>规定无序列表元素要求有范围<br>统计每个元素出现次数，最后修改列表<br>对于年龄列表做大规模排序非常实用</p>
<pre><code>def count_sort(list,maxNum):
    print(&quot;\ncount_sort:&quot;)
    counter = [0 for i in range(maxNum+1)]
    for i in list:
        counter[i] += 1
    i = 0
    for num,c in enumerate(counter):
        for j in range(c):
            list[i] = num
            i += 1
</code></pre><h3 id="找前n个大数"><a href="#找前n个大数" class="headerlink" title="找前n个大数"></a>找前n个大数</h3><ul>
<li><p>方法一：<br>时间复杂度O(n^2)<br>将无序列表使用排序算法排序，取最后n个互异的数</p>
</li>
<li><p>方法二：<br>时间复杂度O(kn)<br>构造一个n个大小的列表，对这个列表使用插入排序，每次从无序列表获取一个元素，插入构造列表，淘汰构造列表最小数，直到无序列表取完</p>
</li>
<li><p>方法三：<br>时间复杂度O(nlogk)<br>将前n个数构造一个小根堆，每次从无序列表取一个元素和堆顶元素比较，小则淘汰，大则替换，然后调整堆，直至无序列表取完</p>
</li>
<li><p>方法四：<br>与方法三原理相同，只不过是使用系统heapq模块</p>
</li>
</ul>
<p><strong>方法二代码</strong></p>
<pre><code>def topk_search(list,k):
    ltmp = list[0: k + 1]
    insert_sort(ltmp)
    ltmp.reverse()
    print(&quot;get_topk:&quot;)
    for i in range(k + 1,len(list)):
        j = k - 1
        while j &gt;= 0 and ltmp[j] &lt; list[i]:
            ltmp[j + 1] = ltmp[j]
            j -= 1
        ltmp[j + 1] = list[i]
    return ltmp[0: k]
</code></pre><p><strong>方法三代码：</strong></p>
<pre><code>def sift_small(list,low,high):
    i = low
    j = 2 * i + 1
    temp = list[i]
    while j &lt;= high:
        if j &lt; high and list[j] &gt; list[j+1]:
            j += 1
        if temp &gt; list[j]:
            list[i] = list[j]
            i = j
            j = 2 * i + 1
        else:
            break
    list[i] = temp
    list[low],list[high] = list[low],list[high]

def topn_search(list,n):
    print(&quot;\nget_topn:&quot;)
    heap = list[0:n]
    for i in range(n//2-1,-1,-1):
        sift_small(heap, i, n - 1)
    for i in range(n,len(list)):
        if heap[0] &lt; list[i]:
            heap[0] = list[i]
            sift_small(heap, 0, n - 1)
    for i in range(n-1, -1, -1):
        heap[0],heap[i] = heap[i],heap[0]
        sift_small(heap, 0, i - 1)
    return heap
</code></pre><p><strong>方法四代码：</strong></p>
<pre><code>def sys_topn_search(list,n):
    import heapq
    return heapq.nlargest(n,list)
</code></pre><h2 id="全部排序算法汇总"><a href="#全部排序算法汇总" class="headerlink" title="全部排序算法汇总"></a>全部排序算法汇总</h2><pre><code>import time
import random
import sys
import copy

def time_cost(func):
    def wrapper(*args,**kwargs):
        sTime = time.time()
        func(*args,**kwargs)
        print(&quot;Time cost:%s&quot;%(time.time()-sTime))
        print(args[0])
    return wrapper

#-------------------系统自带排序-----------------------#
@time_cost
def sys_sort(list):
    list.sort()


#-------------------冒泡排序-----------------------#
@time_cost
def bubble_sort(list):
    print(&quot;\nbubble_sort:&quot;)
    for i in range(len(list)-1):
        tag = 0
        for j in range(len(list)-i-1):
            if list[j] &gt; list[j+1]:
                list[j],list[j+1] = list[j+1],list[j]
                tag = 1
        if not tag:
            return

#-------------------插入排序-----------------------#
@time_cost
def insert_sort(list):
    print(&quot;\ninsert_sort:&quot;)
    for i in range(len(list)):
        tag = 0
        for j in range(i,0,-1):
            if list[j] &lt; list[j-1]:
                list[j],list[j-1] = list[j-1],list[j]
                tag = 1
            if not tag:
                break

#-------------------选择排序-----------------------#
@time_cost
def select_sort(list):
    print(&quot;\nselect_sort:&quot;)
    for i in range(len(list)-1):
        min = i
        for j in range(i+1,len(list)):
            if list[min] &gt; list[j]:
                min = j
        if min != i:
            list[i],list[min] = list[min],list[i]

#-------------------快速排序-----------------------#
def part_sort(list,left,right):
    temp = list[left]
    while left &lt; right:
        while left &lt; right and temp &lt;= list[right]:
            right -= 1
        list[left] = list[right]
        while left &lt; right and temp &gt;= list[left]:
            left += 1
        list[right] = list[left]
    list[left] = temp
    return left


def _quckly_sort(list,left,right):
    if left &lt; right:
        mid = part_sort(list,left,right)
        _quckly_sort(list,left,mid-1)
        _quckly_sort(list,mid+1,right)

@time_cost
def quckly_sort(list):
    print(&quot;\nquckly_sort:&quot;)
    return _quckly_sort(list,0,len(list)-1)

#-------------------堆排序-----------------------#
def sift(list,low,high):
    i = low
    j = 2 * i + 1
    temp = list[i]
    while j &lt;= high:
        if j &lt; high and list[j] &lt; list[j+1]:
            j += 1
        if temp &lt; list[j]:
            list[i] = list[j]
            i = j
            j = 2 * i + 1
        else:
            break
    list[i] = temp
    list[low],list[high] = list[low],list[high]



@time_cost
def heap_sort(list):
    print(&quot;\nheap_sort:&quot;)
    n = len(list)
    for i in range(n // 2 - 1, -1, -1):
        sift(list, i, n - 1)
    for i in range(n-1, -1, -1):
        list[0],list[i] = list[i],list[0]
        sift(list, 0, i - 1)


#-------------------系统自带堆排序------------------#
@time_cost
def sys_heap_sort(list):
    import heapq
    heap = []
    for i in range(len(list)):
        heapq.heappush(heap,list[i])
    for i in range(len(heap)):
        list[i] = heapq.heappop(heap)



#-------------------归并排序-----------------------#
def ont_megre_sort(list,low,mid,high):
    i = low
    j = mid + 1
    ltmp = []
    while i &lt;= mid and j &lt;= high:
        if list[i] &lt; list[j]:
            ltmp.append(list[i])
            i += 1
        else:
            ltmp.append(list[j])
            j += 1
    while i &lt;= mid:
        ltmp.append(list[i])
        i += 1
    while j &lt;= high:
        ltmp.append(list[j])
        j += 1
    list[low:high+1] = ltmp


def _megre_sort(list,low,high):
    if low &lt; high:
        mid = (low+high)//2
        _megre_sort(list,low,mid)
        _megre_sort(list,mid+1,high)
        ont_megre_sort(list,low,mid,high)

@time_cost
def megre_sort(list):
    print(&quot;\nmegre_sort:&quot;)
    return _megre_sort(list,0,len(list)-1)


#-------------------希尔排序-----------------------#
@time_cost
def shell_sort(list):
    print(&quot;\nshell_sort:&quot;)
    gap = len(list) // 2
    while gap &gt; 0:
        for i in range(gap,len(list)):
            temp = list[i]
            j = i - gap
            while j &gt;= 0 and temp &lt; list[j]:
                list[j + gap] = list[j]
                j -= gap
            list[j + gap] = temp
        gap //= 2


#-------------------统计排序-----------------------#
@time_cost
def count_sort(list,maxNum):
    print(&quot;\ncount_sort:&quot;)
    counter = [0 for i in range(maxNum+1)]
    for i in list:
        counter[i] += 1
    i = 0
    for num,c in enumerate(counter):
        for j in range(c):
            list[i] = num
            i += 1



#-------------------插入排序获取Top前n的数-----------------------#
def topk_search(list,k):
    ltmp = list[0: k + 1]
    insert_sort(ltmp)
    ltmp.reverse()
    print(&quot;get_topk:&quot;)
    for i in range(k + 1,len(list)):
        j = k - 1
        while j &gt;= 0 and ltmp[j] &lt; list[i]:
            ltmp[j + 1] = ltmp[j]
            j -= 1
        ltmp[j + 1] = list[i]
    return ltmp[0: k]

#-------------------堆排序获取Top前n的数-----------------------#

def sift_small(list,low,high):
    i = low
    j = 2 * i + 1
    temp = list[i]
    while j &lt;= high:
        if j &lt; high and list[j] &gt; list[j+1]:
            j += 1
        if temp &gt; list[j]:
            list[i] = list[j]
            i = j
            j = 2 * i + 1
        else:
            break
    list[i] = temp
    list[low],list[high] = list[low],list[high]

def topn_search(list,n):
    print(&quot;\nget_topn:&quot;)
    heap = list[0:n]
    for i in range(n//2-1,-1,-1):
        sift_small(heap, i, n - 1)
    for i in range(n,len(list)):
        if heap[0] &lt; list[i]:
            heap[0] = list[i]
            sift_small(heap, 0, n - 1)
    for i in range(n-1, -1, -1):
        heap[0],heap[i] = heap[i],heap[0]
        sift_small(heap, 0, i - 1)
    return heap

#-------------------系统堆排序获取Top前n的数-----------------------#
# @time_cost
def sys_topn_search(list,n):
    import heapq
    return heapq.nlargest(n,list)


def main():
    #生成列表
    list0 = list(range(100))
    first_name = [&quot;陈&quot;,&quot;张&quot;,&quot;李&quot;,&quot;王&quot;,&quot;赵&quot;]
    second_name = [&quot;冰&quot;,&quot;鑫&quot;,&quot;程&quot;,&quot;爱&quot;,&quot;暖&quot;]
    third_name = [&quot;强&quot;,&quot;国&quot;,&quot;明&quot;,&quot;风&quot;,&quot;芬&quot;]
    listname = [
        {&quot;id&quot;:&quot;1000&quot;+str(i),
         &quot;name&quot;:random.choice(first_name)+
                random.choice(second_name)+
                random.choice(third_name),
         &quot;age&quot;:random.randint(16,60)
        } for i in range(10)
    ]
    random.shuffle(list0)
    random.shuffle(listname)

    #copy四份打乱后的列表
    list1 = copy.deepcopy(list0)
    list2 = copy.deepcopy(list0)
    list3 = copy.deepcopy(list0)
    list4 = copy.deepcopy(list0)
    list5 = copy.deepcopy(list0)
    list6 = copy.deepcopy(list0)
    list7 = copy.deepcopy(list0)
    list8 = copy.deepcopy(list0)
    list9 = copy.deepcopy(list0)
    list10 = copy.deepcopy(list0)
    list11 = copy.deepcopy(list0)
    list12 = copy.deepcopy(list0)

    #设置递归深度
    sys.setrecursionlimit(10000)


    print(&quot;sort_list:&quot;)
    print(list0)

    # 排序算法
    sys_sort(list0)
    bubble_sort(list1)
    select_sort(list2)
    insert_sort(list3)
    quckly_sort(list4)
    heap_sort(list5)
    sys_heap_sort(list11)
    megre_sort(list6)
    shell_sort(list7)
    count_sort(list8,1000)
    print(topk_search(list9,10))
    print(topn_search(list10,10))
    print(sys_topn_search(list12,10))


if &quot;__main__&quot; == __name__:
    main()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/算法和数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/算法和数据结构/" itemprop="url">算法和数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T19:01:17+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,041 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  5 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python中的数据结构"><a href="#Python中的数据结构" class="headerlink" title="Python中的数据结构"></a>Python中的数据结构</h1><p>巧用Python列表特性实现特定数据结构</p>
<h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><pre><code>stack = []
stack.push(x)
stack.pop()
stack[-1]
</code></pre><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><pre><code>from collections import deque
queue = deque()
</code></pre><h3 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h3><pre><code>queue.append(x)
queue.popleft()
</code></pre><h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><pre><code>queue.append(x)
queue.popleft()
queue.appendleft(x)
queue.pop()
</code></pre><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p><strong>初始</strong></p>
<pre><code>dqueue = []
rear = 0
front = 0
</code></pre><p><strong>添加一个数据</strong></p>
<pre><code>front = (front + 1 ) % MaxSize
</code></pre><p><strong>一个数据出队</strong></p>
<pre><code>rear = (rear + 1 ) % MaxSize
</code></pre><p><strong>空队条件</strong></p>
<pre><code>rear == front 
</code></pre><p><strong>满队条件</strong></p>
<pre><code>(rear + 1 ) % MaxSize == front
</code></pre><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><pre><code>class Node(object):
    def __init__(self,item=None):
    　　self.item = item
    　　self.next = None

    def main():
    　　head = Node(1)
    　　b = Node(2)
    　　head.next = b

head -&gt; b -&gt; None

head为链表首部,有无数据都可以
</code></pre><p><strong>遍历链表</strong></p>
<pre><code>def traversal(head):
　　currNode = head
　　while currNode is not None:
　　　　print(currNode.item)
　　　　currNode = currNode.next
</code></pre><p><strong>插入</strong></p>
<pre><code>p.next = currNode.next
currNode.next = p
</code></pre><p><strong>删除</strong></p>
<pre><code>currNode.next = p
currNode.next = currNode.next.next
del p
</code></pre><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><pre><code>class Node(object):
    def __init__(self,item=None):
    　　self.item = itme
    　　self.next = None
    　　self.prev = None
</code></pre><p><strong>插入</strong></p>
<pre><code>p.next = currNode.next
currNode.next.prev = p 
p.prev = currNode
currNode.next = p
</code></pre><p><strong>删除</strong></p>
<pre><code>p = currNode.next
currNode.next = p.next
p.next.prev = currNode
del p
</code></pre><p><strong>链表和列表的效率分析</strong></p>
<p>按元素查找时间复杂度都为O(n)<br>按下标查找链表时间复杂度为O(n),列表为O(1)<br>在某元素后插入数据链表时间复杂度为O(1),列表的时间复杂度为O(n)<br>删除某元素链表时间复杂度为O(n),列表时间复杂度为O(1)</p>
<h2 id="散列表（Hash表）实现"><a href="#散列表（Hash表）实现" class="headerlink" title="散列表（Hash表）实现"></a>散列表（Hash表）实现</h2><p>它是一种线性存储的表结构<br>首先根据关键字k，进过某Hash函数，获得一个索引值<br>然后将该关键字存储到索引值所在的位置</p>
<p>这也是集合的存储原理</p>
<p>对于字典也是类似的<br>字典是对每一个key求索引值，索引值对应的位置存放相应的value</p>
<p>问题一：<br>索引值重复<br>解决一：线性表每个位置采用链表存储，相同索引值得关键字，依次链接起来（拉链法<br>解决二：通过哈希冲突函数得到新的地址（开放地址法）</p>
<h2 id="利用栈解决迷宫问题"><a href="#利用栈解决迷宫问题" class="headerlink" title="利用栈解决迷宫问题"></a>利用栈解决迷宫问题</h2><p><strong>代码:</strong></p>
<pre><code>maze = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,0,0,0,1,0,1],
    [1,0,0,1,0,0,0,1,0,1],
    [1,0,0,0,0,1,1,0,0,1],
    [1,0,1,1,1,0,0,0,0,1],
    [1,0,0,0,1,0,0,0,0,1],
    [1,0,1,0,0,0,1,0,0,1],
    [1,0,1,1,1,0,1,1,0,1],
    [1,1,0,0,0,0,0,1,0,1],
    [1,1,1,1,1,1,1,1,1,1]
]

dirs = [lambda x, y: (x + 1, y),
        lambda x, y: (x - 1, y),
        lambda x, y: (x, y - 1),
        lambda x, y: (x, y + 1)]

def mpath(x1, y1, x2, y2):
    stack = []
    stack.append((x1, y1))
    while len(stack) &gt; 0:
        curNode = stack[-1]
        if curNode[0] == x2 and curNode[1] == y2:
            #到达终点
            for p in stack:
                print(p)
            return True
        for dir in dirs:
            nextNode = dir(curNode[0], curNode[1])
            if maze[nextNode[0]][nextNode[1]] == 0:
                #找到了下一个
                stack.append(nextNode)
                maze[nextNode[0]][nextNode[1]] = -1  # 标记为已经走过，防止死循环
                break
        else:#四个方向都没找到
            maze[curNode[0]][curNode[1]] = -1  # 死路一条,下次别走了
            stack.pop() #回溯
    print(&quot;没有路&quot;)
    return False

mpath(1,1,8,8)
</code></pre><h2 id="利用队列解决迷宫问题"><a href="#利用队列解决迷宫问题" class="headerlink" title="利用队列解决迷宫问题"></a>利用队列解决迷宫问题</h2><p>代码:</p>
<pre><code>from collections import  deque

mg = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,0,0,0,1,0,1],
    [1,0,0,1,0,0,0,1,0,1],
    [1,0,0,0,0,1,1,0,0,1],
    [1,0,1,1,1,0,0,0,0,1],
    [1,0,0,0,1,0,0,0,0,1],
    [1,0,1,0,0,0,1,0,0,1],
    [1,0,1,1,1,0,1,1,0,1],
    [1,1,0,0,0,0,0,1,0,1],
    [1,1,1,1,1,1,1,1,1,1]
]

dirs = [lambda x, y: (x + 1, y),
        lambda x, y: (x - 1, y),
        lambda x, y: (x, y - 1),
        lambda x, y: (x, y + 1)]

def print_p(path):
    curNode = path[-1]
    realpath = []
    print(&apos;迷宫路径为：&apos;)
    while curNode[2] != -1:
        realpath.append(curNode[0:2])
        curNode = path[curNode[2]]
    realpath.append(curNode[0:2])
    realpath.reverse()
    print(realpath)

def mgpath(x1, y1, x2, y2):
    queue = deque()
    path = []
    queue.append((x1, y1, -1))
    while len(queue) &gt; 0:
        curNode = queue.popleft()
        path.append(curNode)
        if curNode[0] == x2 and curNode[1] == y2:
            #到达终点
            print_p(path)
            return True
        for dir in dirs:
            nextNode = dir(curNode[0], curNode[1])
            if mg[nextNode[0]][nextNode[1]] == 0:  # 找到下一个方块
                queue.append((*nextNode, len(path) - 1))
                mg[nextNode[0]][nextNode[1]] = -1  # 标记为已经走过
    return False


mgpath(1,1,8,8)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/爬虫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/爬虫/" itemprop="url">爬虫</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T15:06:10+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/爬虫/" itemprop="url" rel="index">
                    <span itemprop="name">爬虫</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,338 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  62 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内容简介<br>第一章：爬虫简介，简单介绍了什么是爬虫，爬虫的作用，及如何实现一个爬虫，爬虫所需要的先决知识及关键核心技术等等，分级别的告诉大家初级爬虫工程师，中级爬虫工程师及高级爬虫工程师所需要的知识体系及技能。<br>第二章：介绍了关于爬虫的一些基本常识，包括爬虫的法律风险等，之后介绍了怎么对需要爬取的网站进行背景调研：网站的Robots协议，Sitemap，怎么估算网站的大小，怎么识别网站用了什么技术架构，怎么寻找网站的所有者等等，这些都是在抓取一个网站之前所需要做的背景调研，以便我们更好的能够抓取到网站的信息。<br>第三章：通过实例给大家展示在Python中一个简单的爬虫应该怎么写，同时简单复习一下爬虫的相关网络知识，主要是HTTP, HTTPS协议，最后介绍了爬虫爬取数据两种常用算法策略：广度优先和深度优先的策略，及实际项目如何选择策略。<br>第四章：介绍了怎么对爬取到的内容进行提取，对结构化的数据与非结构化的数据分别怎么进行提取，常见的文件格式JSON，XML，HTML等，及Beautiful Soup，lxml，正则表达式等等提取数据的方法，并对各种数据，数据解析方法及使用场景进行了总结。<br>第五章：介绍了针对动态网页数据的抓取，可以采用的策略：模拟网络数据包的过程及使用内置浏览器的方案Selenium + PhantomJS的策略，分别用示例说明了这种方法各自的优缺点。<br>第六章：简单介绍下讲述怎么登录，提交表单，怎么使用Cookie记录管理登录状态，怎么使用图像识别技术来尝试破解验证码。<br>第七章：讲述了怎么存储爬取到的数据，怎么做持久化，如何选择及使用MySQL, MongoDB，HBase等数据库进行存储，简单介绍一下怎么对数据进行压缩存储，以节省存储空间。<br>第八章：高效爬虫之路，怎么使用多线程，多进程来提升爬虫爬取数据的效率，简单介绍下怎么来调度并行爬虫，怎么设置代理服务器，来防止爬虫在告诉爬取数据时尽可能不被反爬程序发现。<br>第九章：简单介绍下怎么去重，怎么使用Redis数据库进行去重，大数据量时怎么使用HASH算法Bloom Filter减少空间消耗。<br>第十章：介绍Scrapy框架，如何快速使用Scrapy搭建一个网站的爬虫，如何使用Scrapy-Redis快速搭建一个分布式爬虫的框架。<br>第十一章：介绍下常用的反爬策略, 怎么解决HTTPS对爬虫的阻碍行为。<br>第十二章：其他，简单介绍下如果使用机器学习的方法优化爬虫爬取数据的策略，以及如果使用爬虫爬取的数据，对于爬虫的时效性问题，怎么设计其更新的频率，怎么尝试使用机器学习的方法调节其自动更新的频率。</p>
<h1 id="第一章-爬虫简介"><a href="#第一章-爬虫简介" class="headerlink" title="第一章 爬虫简介"></a>第一章 爬虫简介</h1><h2 id="1-1-什么是网络爬虫"><a href="#1-1-什么是网络爬虫" class="headerlink" title="1.1 什么是网络爬虫"></a>1.1 什么是网络爬虫</h2><h3 id="1-1-1-爬虫的简单定义"><a href="#1-1-1-爬虫的简单定义" class="headerlink" title="1.1.1 爬虫的简单定义"></a>1.1.1 爬虫的简单定义</h3><p>网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。<br>简单来说：使用事先写好的程序去抓取网络上所需要的数据，这样的程序就叫网络爬虫。</p>
<h3 id="1-1-2-爬虫的分类"><a href="#1-1-2-爬虫的分类" class="headerlink" title="1.1.2 爬虫的分类"></a>1.1.2 爬虫的分类</h3><p>网络爬虫可以分为通用网络爬虫(如搜索引擎的爬虫，根据几个URL的种子不断的去抓取数据)和聚焦网络爬虫(有选择性的抓取预先定义好的主题和相关页面的网络爬虫)。</p>
<ul>
<li>A.通用网络爬虫：<br>搜索引擎中第一步就是爬虫。但是搜索引擎中的爬虫是一种广泛获取各种网页的信息的程序；除了HTML文件外，搜索引擎通常还会抓取和索引文字为基础的多种文件类型，如TXT，WORD，PDF等； 但是对于图片，视频，等非文字的内容则一般不会处理；但是对于脚本和一些网页中的程序是不会处理的；</li>
</ul>
<ul>
<li>B.聚焦网络爬虫：<br>针对某一特定领域的数据进行抓取的程序。比如旅游网站，金融网站，招聘网站等等；特定领域的聚集爬虫会使用各种技术去处理我们需要的信息，所以对于网站中动态的一些程序，脚本仍会执行，以保证确定能抓取到网站中的数据；</li>
</ul>
<h2 id="1-2-为什么需要爬虫"><a href="#1-2-为什么需要爬虫" class="headerlink" title="1.2 为什么需要爬虫"></a>1.2 为什么需要爬虫</h2><h3 id="1-2-1-爬虫的用途"><a href="#1-2-1-爬虫的用途" class="headerlink" title="1.2.1 爬虫的用途"></a>1.2.1 爬虫的用途</h3><ul>
<li><p>A.解决冷启动问题：对于很多社交类的网站，冷启动是很困难的。对于新注册的用户而言，要留住他们，需要先注入一批假用户，已构造社区的氛围。一般这些假的用户可以通过网络爬虫从微博或其他APP中抓取而来；今日头条等互联网媒体最早也就是使用了爬虫+网页排序的技术，所以它们解决冷启动的方式也是需要爬虫；</p>
</li>
<li><p>B.搜索引擎的根基：做搜索引擎少不了爬虫程序；</p>
</li>
<li><p>C.建立起知识图谱，帮助建立机器学习的训练集：</p>
</li>
<li><p>D.可以制作各种商品的比价，趋势分析等：</p>
</li>
</ul>
<ul>
<li>E.其他：比如分析淘宝上竞争对手的数据；分析微博的数据传递影响力，政府的舆情分析，分析人与人之间的关系等等；</li>
</ul>
<p>总之一句话：在当今的大数据时代，做任何价值分析的前提是数据，而爬虫则是获得这个前提的一个低成本高收益手段；而程序员而言，另一个重要的价值是解决就业问题。Python爬虫工程师的招聘情况见：</p>
<p><a href="https://www.lagou.com/jobs/list_python%20%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88city=%E5%85%A8%E5%9B%BD&amp;cl=false&amp;fromSearch=true&amp;labelWords=&amp;suginput" title="https://www.lagou.com/jobs/list_python%20%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88city=%E5%85%A8%E5%9B%BD&amp;cl=false&amp;fromSearch=true&amp;labelWords=&amp;suginput" target="_blank" rel="noopener">https://www.lagou.com/jobs/list_python%20%E7%88%AC%E8%99%AB%E5%B7%A5%E7%A8%8B%E5%B8%88city=%E5%85%A8%E5%9B%BD&amp;cl=false&amp;fromSearch=true&amp;labelWords=&amp;suginput</a></p>
<h3 id="1-2-2怎么做爬虫"><a href="#1-2-2怎么做爬虫" class="headerlink" title="1.2.2怎么做爬虫"></a>1.2.2怎么做爬虫</h3><p>用Python做爬虫非常的简单，在交互式环境中简单的两行代码即可</p>
<p>做一个爬虫如此简单吗？<br>当然不是。让我们来看下要做一个爬虫工程师需要哪些知识和技能：</p>
<p><strong> 爬虫工程师的晋级之路，网络爬虫涉及哪些技术： </strong></p>
<p><strong>初级爬虫工程师：</strong></p>
<ol>
<li>Web前端的知识：HTML, CSS, JavaScript, DOM, HTML, Ajax, jQuery,json等；</li>
<li>正则表达式，能提取正常一般网页中想要的信息，比如某些特殊的文字，链接信息，知道什么是懒惰，什么是贪婪型的正则；</li>
<li>会使用re, BeautifulSoup，XPath等获取一些DOM结构中的节点信息；</li>
<li>知道什么是深度优先，广度优先的抓取算法，及实践中的使用规则；</li>
<li>能分析简单网站的结构，会使用urllib或requests库进行简单的数据抓取；</li>
</ol>
<p><strong>中级爬虫工程师：</strong></p>
<ol>
<li>了解什么是Hash，会使用简单的MD5,SHA1等算法对数据进行Hash以便存储；</li>
<li>熟悉HTTP,HTTPS协议的基础知识,了解GET，POST方法,了解HTTP头中的信息，包括返回状态码，编码，user-agent，cookie，session等；</li>
<li>能设置User-Agent进行数据爬取，设置代理等； </li>
<li>知道什么是Request，什么是Response，会使用Fiddler, Wireshark等工具抓取及分析简单的网络数据包；对于动态爬虫，要学会分析Ajax请求，模拟制造Post数据包请求，抓取客户端session等信息，对于一些简单的网站，能够通过模拟数据包进行自动登录；</li>
<li>对于比较难搞定的网站，学会使用浏览器+selenium抓取一些动态网页信息；</li>
<li>并发下载，通过并行下载加速数据抓取；多线程的使用；</li>
</ol>
<p><strong>高级爬虫工程师：</strong></p>
<ol>
<li>能使用Tesseract，百度AI, HOG+SVM,CNN等库进行验证码识别；</li>
<li>能使用数据挖掘的技术，分类算法等避免死链等；</li>
<li>会使用常用的数据库进行数据存储，查询，如Mongodb，Redis(大数据量的缓存)等；下载缓存，学习如何通过缓存避免重复下载的问题；Bloom Filter的使用；</li>
<li>能使用机器学习的技术动态调整爬虫的爬取策略，从而避免被禁IP封号等；</li>
<li>能使用一些开源框架Scrapy, Scarpy-Redis，Celery等分布式爬虫，能部署掌控分布式爬虫进行大规模的数据抓取；</li>
</ol>
<h1 id="第二章-爬虫的基本常识"><a href="#第二章-爬虫的基本常识" class="headerlink" title="第二章 爬虫的基本常识"></a>第二章 爬虫的基本常识</h1><h2 id="2-1-爬虫的合法性问题"><a href="#2-1-爬虫的合法性问题" class="headerlink" title="2.1 爬虫的合法性问题"></a>2.1 爬虫的合法性问题</h2><p>目前还处于不明确的蛮荒阶段，“允许哪些行为”这种基本秩序还处于建设中。<br>至少目前来看，如果抓取的数据为个人所用，则不存在问题；如果数据用于转载，那么<br>抓取数据的类型就很重要了：一般来说，当抓取的数据是实现生活中的真实数据（比如，营业地址，电话清单）时，是允许转载的，但是，如果是原创数据（比如，意见或评论），通常就会受到版权限制，而不能转载。<br>讨论：百度爬虫抓取数据行为的合法性问题。<br>**注意：不管怎么样，作为一个访客，应当约束自己的抓取行为，这就是说要求下载请求的速度需要限定在一个合理值之内，并且还需要设定一个专属的用户代理来标识自己。</p>
<h2 id="2-2-爬虫的准备工作：网站的背景调研"><a href="#2-2-爬虫的准备工作：网站的背景调研" class="headerlink" title="2.2 爬虫的准备工作：网站的背景调研"></a>2.2 爬虫的准备工作：网站的背景调研</h2><p>网站的背景调研对聚焦的网络爬虫而言至关重要，正所谓：知己知彼，百战不殆。</p>
<h3 id="2-2-1-robots协议"><a href="#2-2-1-robots协议" class="headerlink" title="2.2.1 robots协议"></a>2.2.1 robots协议</h3><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br>       比如：<br>淘宝网：<a href="https://www.taobao.com/robots.txt" target="_blank" rel="noopener">https://www.taobao.com/robots.txt</a><br>腾讯网：<a href="http://www.qq.com/robots.txt" target="_blank" rel="noopener">http://www.qq.com/robots.txt</a><br>         再比如：<br><a href="https://www.douban.com/robots.txt" target="_blank" rel="noopener">https://www.douban.com/robots.txt</a><br><a href="http://www.mafengwo.cn/robots.txt" target="_blank" rel="noopener">http://www.mafengwo.cn/robots.txt</a><br>搜索引擎和DNS解析服务商(如DNSPod等）合作，新网站域名将被迅速抓取。但是搜索引擎蜘蛛的爬行是被输入了一定的规则的，它需要遵从一些命令或文件的内容，如标注为nofollow的链接，或者是Robots协议。另外一种则是，通过网站的站长主动对搜索引擎提交网站的网址，搜索引擎则会在接下来派出“蜘蛛”，对该网站进行爬取。 </p>
<h3 id="2-2-2-网站地图sitemap"><a href="#2-2-2-网站地图sitemap" class="headerlink" title="2.2.2 网站地图sitemap"></a>2.2.2 网站地图sitemap</h3><p>sitemap是一个网站所有链接的容器。很多网站的连接层次比较深，蜘蛛很难抓取到，网站地图可以方便搜索引擎蜘蛛抓取网站页面，通过抓取网站页面，清晰了解网站的架构，网站地图一般存放在根目录下并命名为sitemap，为搜索引擎蜘蛛指路，增加网站重要内容页面的收录。网站地图就是根据网站的结构、框架、内容，生成的导航网页文件。大多数人都知道网站地图对于提高用户体验有好处：它们为网站访问者指明方向，并帮助迷失的访问者找到他们想看的页面。<br>例子：<a href="http://www.mafengwo.cn/sitemapIndex.xml" target="_blank" rel="noopener">http://www.mafengwo.cn/sitemapIndex.xml</a></p>
<p>网站地图sitemap有两种形式：</p>
<ul>
<li>A.HTML：称为HTML版本的网站地图，英文是sitemap,特质HTML版网站地图，这个版本的网站地图就是用户可以在网站上看到的，列出网站上所有主要页面的链接的页面。对小网站来说，甚至可以列出整个网站的所有页面，对于具有规模的网站来说，一个网站地图不可能罗列所有的页面链接，可以采取两种办法，一种办法是网站地图只列出网站最主要的链接，如一级分类，二级分类，第二种办法是将网站地图分成几个文件，主网站地图列出通往次级网站的链接，次级网站地图在列出一部分页面链接。</li>
<li>B.XML：XML版本的网站地图是由Google首先提出的，怎么区分了，上面所说的HTML版本的s是小写的，而XML版本的S则是大写的，XML版本的网站地图是由XML标签组成的，文件本身必须是utf8编码，网站地图文件实际上就是列出网站需要被收录的页面的URL，最简单的网站地图可以是一个纯文本件，文件只要列出页面的URL，一行列一个URL，搜索引擎就能抓取并理解文件内容。<br>可以使用这个网站工具来生成某网站的sitemap： <a href="http://www.sitemap-xml.org" target="_blank" rel="noopener">www.sitemap-xml.org</a></li>
</ul>
<h3 id="2-2-3-估算网站的大小"><a href="#2-2-3-估算网站的大小" class="headerlink" title="2.2.3 估算网站的大小"></a>2.2.3 估算网站的大小</h3><p>可以使用搜索引擎来做，比如在百度中使用site:</p>
<p>说明：这里只是通过百度搜索引擎大致来估算网站的大小，受到网站本身对搜索引擎爬虫的限制，及搜索引擎本身爬取数据技术的限制，所以这只是一个经验值，可以作为估算网站体量量级的一个经验值。</p>
<h3 id="2-2-4-识别网站用了何种技术"><a href="#2-2-4-识别网站用了何种技术" class="headerlink" title="2.2.4 识别网站用了何种技术"></a>2.2.4 识别网站用了何种技术</h3><p>为了更好的了解网站，抓取该网站的信息，我们可以先了解一下该网站大致所使用的技术架构。<br>安装builtwith :<br>Windows： pip install bulitwith<br>Linux:     sudo pip install builtwith<br>使用：在Python交互环境下，输入：<br>import builtwith<br>builtwith.parse(“<a href="http://www.sina.com.cn&quot;" target="_blank" rel="noopener">http://www.sina.com.cn&quot;</a>)</p>
<h3 id="2-2-5-寻找网站的所有者"><a href="#2-2-5-寻找网站的所有者" class="headerlink" title="2.2.5 寻找网站的所有者"></a>2.2.5 寻找网站的所有者</h3><p>有时候，我们需要知道网站的所有者是谁，这里在技术上有个简单的方法可以参考。<br>安装python-whois :<br>Windows： pip install python-whois<br>使用：在Python交互环境下，输入：<br>import whois<br>whois.whois(“<a href="http://www.sina.com.cn&quot;" target="_blank" rel="noopener">http://www.sina.com.cn&quot;</a>) </p>
<h1 id="第三章-简单爬虫的实现"><a href="#第三章-简单爬虫的实现" class="headerlink" title="第三章 简单爬虫的实现"></a>第三章 简单爬虫的实现</h1><h2 id="3-1-可能是史上最简单的爬虫Demo"><a href="#3-1-可能是史上最简单的爬虫Demo" class="headerlink" title="3.1 可能是史上最简单的爬虫Demo"></a>3.1 可能是史上最简单的爬虫Demo</h2><p>最简单的爬虫Demo：<br>第一个爬虫程序，两行代码写一个爬虫：</p>
<pre><code>import urllib2  #Python2
print(urllib2.urlopen(&quot;http://example.webscraping.com&quot;).read())
</code></pre><p>这两行代码在Python2.7下可以正常运行，获取<a href="http://example.webscraping.com" target="_blank" rel="noopener">http://example.webscraping.com</a><br>这个页面的内容；<br>备注：如果是Python3 ,则使用如下两行代码：</p>
<pre><code>import requests #Python3
print(requests.get(&apos;http://example.webscraping.com&apos;).text)
</code></pre><p>如果没有requests 库，则需要使用命令pip install requests 安装一下；<br>说明：本讲义结合了Python2和Python3两种不同的环境。当看见#Python2 或者有些以p2结尾的文件，时说明此代码需要在Python2.7的环境下运行；看见#Python3或者有些以p3结尾的文件时说明此代码需要在Python3.5及以上的环境中运行。之所以会有这种情况出现是历史原因导致：Python3当然是大势所趋，但是目前有很多库还没有完全移植到Python3上，同时有些公司还在使用Python2进行开发。大家不用过于担心，在本讲义的附录A中会将Python2和Python3在爬虫这块最主要几个库的对照表收录进来，按照这张表就可以方便的实现Python2与Python3在爬虫这块代码的移植。</p>
<h2 id="3-2-回顾一下HTTP，HTTPS协议"><a href="#3-2-回顾一下HTTP，HTTPS协议" class="headerlink" title="3.2    回顾一下HTTP，HTTPS协议"></a>3.2    回顾一下HTTP，HTTPS协议</h2><h3 id="3-2-1-关于URL："><a href="#3-2-1-关于URL：" class="headerlink" title="3.2.1.    关于URL："></a>3.2.1.    关于URL：</h3><p>URL（Uniform / Universal Resource Locator的缩写）：统一资源定位符，是用于完整地描述Internet上网页和其他资源的地址的一种标识方法。<br>基本格式：scheme://host[:port#]/path/…/[?query-string][#anchor]<br>scheme：协议(例如：http, https, ftp)<br>host：服务器的IP地址或者域名<br>port#：服务器的端口（如果是走协议默认端口，缺省端口80）<br>path：访问资源的路径<br>query-string：参数，发送给http服务器的数据<br>anchor：锚（跳转到网页的指定锚点位置）<br>例如：<br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br><a href="http://item.jd.com/11963485.html#product-detail" target="_blank" rel="noopener">http://item.jd.com/11963485.html#product-detail</a><br><a href="ftp://192.168.1.118:8081/index" target="_blank" rel="noopener">ftp://192.168.1.118:8081/index</a><br>URL是爬虫的入口，非常的重要。</p>
<h3 id="3-2-2-HTTP协议，HTTPS协议："><a href="#3-2-2-HTTP协议，HTTPS协议：" class="headerlink" title="3.2.2.    HTTP协议，HTTPS协议："></a>3.2.2.    HTTP协议，HTTPS协议：</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML页面的方法。HTTP协议是一个应用层的协议，无连接（每次连接只处理一个请求），无状态（每次连接，传输都是独立的）<br>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）协议简单讲是HTTP的安全版，在HTTP下加入SSL层。HTTPS = HTTP+SSL（Secure Sockets Layer 安全套接层）主要用于Web的安全传输协议，在传输层对网络连接进行加密，保障在Internet上数据传输的安全<br>HTTP的端口号为80；HTTPS的端口号为443；</p>
<h3 id="3-2-3-HTTP-Request请求常用的两种方法："><a href="#3-2-3-HTTP-Request请求常用的两种方法：" class="headerlink" title="3.2.3.    HTTP Request请求常用的两种方法："></a>3.2.3.    HTTP Request请求常用的两种方法：</h3><p>Get：是为了从服务器上获取信息，传输给服务器的数据的过程不够安全，数据大小有限制；<br>Post：向服务器传递数据，传输数据的过程是安全的，大小理论上没有限制；</p>
<h3 id="3-2-4-关于-User-Agent"><a href="#3-2-4-关于-User-Agent" class="headerlink" title="3.2.4.    关于**User-Agent"></a>3.2.4.    关于<em>**</em>User-Agent</h3><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p>
<p>我们来看下我们最简单的爬虫跑起来时告诉服务器的User-Agent是什么？</p>
<p>通过这个例子，我们发现Python爬虫有个默认的带有版本号的User-Agent，由此很容易能识别出来这是一个Python写的爬虫程序。所以如果用默认的User-Agent，那些反爬虫的程序一眼就能识别出来我们是个Python爬虫，这对Python爬虫是不利的。<br>那么，我们如何修改这个User-Agent，来伪装我们的爬虫程序呢？<br>user_agent = “Mozilla/5.0 (Windows NT 10.0; WOW64; rv:58.0) Gecko/20100101 Firefox/58.0”<br>headers = {‘User-agent’: user_agent}<br>request = urllib2.Request(url, headers=headers)<br>SpiderCodes\ simplestSpiderp2.py<br>SpiderCodes\ simplestSpiderp3.py</p>
<h3 id="3-2-5-HTTP-Response响应的状态码："><a href="#3-2-5-HTTP-Response响应的状态码：" class="headerlink" title="3.2.5.    HTTP Response响应的状态码："></a>3.2.5.    HTTP Response响应的状态码：</h3><p>200为成功，300是跳转；<br>400，500意味着有错误：</p>
<p>说明：服务器返回给爬虫的信息可以用来判断我们爬虫当前是否正常在运行；<br>当出现异常错误时：一般来说如果是500的错误那么爬虫会进入休眠状态，说明服务器已经宕机；如果是400的错误，则需要考虑爬虫的抓取策略的修改，可能是网站更新了，或者是爬虫被禁了。如果在一个分布式的爬虫系统中，更容易发现和调整爬虫的策略。</p>
<h3 id="3-2-6-HTTP-响应体是我们爬虫需要关心的协议部分的内容："><a href="#3-2-6-HTTP-响应体是我们爬虫需要关心的协议部分的内容：" class="headerlink" title="3.2.6.    HTTP 响应体是我们爬虫需要关心的协议部分的内容："></a>3.2.6.    HTTP 响应体是我们爬虫需要关心的协议部分的内容：</h3><p>通过Python的交互是环境，我们可以直观的方便的看到请求响应的信息，这也看出了Python瑞士军刀般的作用。</p>
<pre><code>&gt;&gt;&gt; import requests  #Python3
&gt;&gt;&gt; html = requests.get(&apos;http://example.webscraping.com&apos;)
&gt;&gt;&gt; print(html.status_code)
200
&gt;&gt;&gt; print(html.elapsed)
0:00:00.818880
&gt;&gt;&gt; print(html.encoding)
utf-8
&gt;&gt;&gt; print(html.headers)
{&apos;Server&apos;: &apos;nginx&apos;, &apos;Date&apos;: &apos;Thu, 01 Feb 2018 09:23:30 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Vary&apos;: &apos;Accept-Encoding&apos;, &apos;X-Powered-By&apos;: &apos;web2py&apos;, &apos;Set-Cookie&apos;: &apos;session_id_places=True; httponly; Path=/, session_data_places=&quot;6853de2931bf0e3a629e019a5c352fca:1Ekg3FlJ7obeqV0rcDDmjBm3y4P4ykVgQojt-qrS33TLNlpfFzO2OuXnY4nyl5sDvdq7p78_wiPyNNUPSdT2ApePNAQdS4pr-gvGc0VvnXo3TazWF8EPT7DXoXIgHLJbcXoHpfleGTwrWJaHq1WuUk4yjHzYtpOhAbnrdBF9_Hw0OFm6-aDK_J25J_asQ0f7&quot;; Path=/&apos;, &apos;Expires&apos;: &apos;Thu, 01 Feb 2018 09:23:30 GMT&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Cache-Control&apos;: &apos;no-store, no-cache, must-revalidate, post-check=0, pre-check=0&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;}
&gt;&gt;&gt; print(html.content)
略，内容太多了
</code></pre><p>在复习完HTTP协议之后，我们再来看看我们的爬虫程序：<br><em>**</em> \SpiderCodes\httpSpidersp2.py<br>练习：将httpSpidersp2.py中的代码用Python3重新实现一次；</p>
<h2 id="3-3关于爬虫抓取的策略"><a href="#3-3关于爬虫抓取的策略" class="headerlink" title="3.3关于爬虫抓取的策略"></a>3.3关于爬虫抓取的策略</h2><p>一般在抓取爬虫数据时，我们不会只抓取一个入口的URL数据就停止了。当有多个URL链接需要抓取时，我们怎么办？</p>
<h3 id="3-3-1-深度优先算法"><a href="#3-3-1-深度优先算法" class="headerlink" title="3.3.1 深度优先算法"></a>3.3.1 深度优先算法</h3><p>深度优先是指搜索引擎先从网站页面上的某个链接进行抓取，进入到这个链接的页面之后，抓取页面上的内容，然后继续顺着当前页面上的这个链接进行抓取下去，直到顺着这个页面上的链接全部抓取完，最深的页面上没有链接了，爬虫再回过头来顺着第一个网站页面上的另外一个链接进行抓取；如下图所示。</p>
<h3 id="3-3-2-广度-宽度优先算法"><a href="#3-3-2-广度-宽度优先算法" class="headerlink" title="3.3.2 广度/宽度优先算法"></a>3.3.2 广度/宽度优先算法</h3><p>广度优先则是另一个过程，它先把该层次的都遍历完，再继续往下走。<br>如下图所示：</p>
<p>练习： 构造一个完全二叉树，实现其深度优先和广度优先遍历算法。<br>一棵二叉树至多只有最下面的一层上的结点的度数可以小2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。</p>
<p>完全二叉树如下：</p>
<p>深度优先遍历的结果：[1, 3, 5, 7, 9, 4, 12, 11, 2, 6, 14, 13, 8, 10]<br>广度优先遍历的结果：[1, 3, 2, 5, 4, 6, 8, 7, 9, 12, 11, 14, 13, 10]</p>
<h3 id="3-3-3-实践中怎么来组合抓取策略"><a href="#3-3-3-实践中怎么来组合抓取策略" class="headerlink" title="3.3.3 实践中怎么来组合抓取策略"></a>3.3.3 实践中怎么来组合抓取策略</h3><ul>
<li>1.一般来说，重要的网页距离入口站点的距离很近；</li>
<li>2.宽度优先有利于多爬虫并行进行合作；</li>
<li>3.可以考虑将深度与广度相结合的方式来实现抓取的策略：优先考虑广度优先，<br>对深度进行限制最大深度；</li>
</ul>
<p>总结：一个通用爬虫的流程如下：</p>
<h1 id="第四章-提取网页中的信息"><a href="#第四章-提取网页中的信息" class="headerlink" title="第四章 提取网页中的信息"></a>第四章 提取网页中的信息</h1><h2 id="4-1-数据的类型"><a href="#4-1-数据的类型" class="headerlink" title="4.1 数据的类型"></a>4.1 数据的类型</h2><p>网页中数据的类型简单来说可以分成以下三类：</p>
<h3 id="4-1-1结构化数据"><a href="#4-1-1结构化数据" class="headerlink" title="4.1.1结构化数据"></a>4.1.1结构化数据</h3><p>可以用统一的结构加以表示的数据。可以使用关系型数据库表示和存储，表现为二维形式的数据。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。<br>比如MySQL数据库表中的数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>gender</th>
</tr>
</thead>
<tbody>
<tr>
<td>aid1</td>
<td>马化腾</td>
<td>46</td>
<td>male</td>
</tr>
<tr>
<td>aid2</td>
<td>马云</td>
<td>53</td>
<td>male</td>
</tr>
<tr>
<td>aid3</td>
<td>李彦宏</td>
<td>49</td>
<td>male</td>
</tr>
</tbody>
</table>
<h3 id="4-1-2半结构化数据"><a href="#4-1-2半结构化数据" class="headerlink" title="4.1.2半结构化数据"></a>4.1.2半结构化数据</h3><p>是结构化数据的一种形式，并不符合关系型数据库或其他数据表的形式关联起来的数据模型结构，但包含相关标记，用来分隔语义元素以及对记录和字段进行分层。因此，它也被称为自描述的结构。常见的半结构数据有HTML，XML和JSON等，实际上是以树或者图的结构来存储的。<br>比如，一个简单的XML表示：</p>
<pre><code>&lt;person&gt;
    &lt;name&gt;A&lt;/name&gt;
&lt;age&gt;13&lt;/age&gt;
&lt;class&gt;aid1710&lt;/class&gt;
    &lt;gender&gt;female&lt;/gender&gt;
&lt;/person&gt;
</code></pre><p>或者</p>
<pre><code>&lt;person&gt;
    &lt;name&gt;B&lt;/name&gt;
    &lt;gender&gt;male&lt;/gender&gt;
&lt;/person&gt;
</code></pre><p>结点中属性的顺序是不重要的，不同的半结构化数据的属性的个数是不一定一样的。这样的数据格式，可以自由地表达很多有用的信息，包括自描述信息（元数据）。所以，半结构化数据的扩展性很好，特别适合于在互联网中大规模传播。</p>
<h3 id="4-1-3非结构化数据"><a href="#4-1-3非结构化数据" class="headerlink" title="4.1.3非结构化数据"></a>4.1.3非结构化数据</h3><p>就是没有固定结构的数据。各种文档、图片、视频/音频等都属于非结构化数据。对于这类数据，我们一般直接整体进行存储，而且一般存储为二进制的数据格式；<br>除了结构化和半结构数据之外的数据都是非结构化数据。</p>
<h2 id="4-2-关于XML-HTML-DOM和JSON文件"><a href="#4-2-关于XML-HTML-DOM和JSON文件" class="headerlink" title="4.2 关于XML,HTML,DOM和JSON文件"></a>4.2 关于XML,HTML,DOM和JSON文件</h2><h3 id="4-2-1-XML-HTML-DOM"><a href="#4-2-1-XML-HTML-DOM" class="headerlink" title="4.2.1 XML, HTML, DOM"></a>4.2.1 XML, HTML, DOM</h3><p>XML即Extentsible Markup Language(可扩展标记语言)，是用来定义其它语言的一种元语言，其前身是SGML(标准通用标记语言)。它没有标签集(tagset)，也没有语法规则(grammatical rule)，但是它有句法规则(syntax rule)。任何XML文档对任何类型的应用以及正确的解析都必须是良构的(well-formed)，即每一个打开的标签都必须有匹配的结束标签，不得含有次序颠倒的标签，并且在语句构成上应符合技术规范的要求。XML文档可以是有效的(valid)，但并非一定要求有效。所谓有效文档是指其符合其文档类型定义(DTD)的文档。如果一个文档符合一个模式(schema)的规定，那么这个文档是模式有效的(schema valid)。<br>HTML(Hyper Text Mark-up Language)即超文本标记语言，是WWW的描述语言。HTML与XML的区别与联系：<br>  XML和HTML都是用于操作数据或数据结构，在结构上大致是相同的，但它们在本质上却存在着明显的区别。综合网上的各种资料总结如下。</p>
<p><strong> 一.语法要求不同：</strong></p>
<ul>
<li>1.在HTML中不区分大小写，在XML中严格区分。</li>
<li>2.在HTML中，有时不严格，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略<p></p>或者</li>之类的结束标记。在XML中，是严格的树状结构，绝对不能省略掉结束标记。
<li>3.在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个/ 字符作为结尾。这样分析器就知道不用查找结束标记了。</li>
<li>4.在XML中，属性值必须分装在引号中。在HTML中,引号是可用可不用的。 </li>
<li>5.在HTML中，可以拥有不带值的属性名。在XML中,所有的属性都必须带有相应的值。 </li>
<li>6.在XML文档中，空白部分不会被解析器自动删除; 但是html是过滤掉空格的。<br>XML的语法要求比HTML严格。</li>
</ul>
<p><strong> 二.标记不同：</strong></p>
<ul>
<li>1.HTML使用固有的标记; 而XML没有固有的标记。</li>
<li>2.HTML标签是预定义的; XML标签是免费的、自定义的、可扩展的。</li>
</ul>
<p><strong> 三.作用不同：</strong></p>
<ul>
<li>1.HTML是用来显示数据的; XML是用来描述数据、存放数据的，所以可以作为持久化的介质。HTML将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。 XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。</li>
<li>2.XML不是HTML的替代品，XML和HTML是两种不同用途的语言。 XML 不是要替换 HTML；实际上XML 可以视作对 HTML 的补充。XML 和HTML 的目标不同HTML 的设计目标是显示数据并集中于数据外观，而XML的设计目标是描述数据并集中于数据的内容。</li>
<li>3.没有任何行为的XML, 与HTML 相似, XML不进行任何操作（共同点）。</li>
<li>4.对于XML最好的形容可能是: XML是一种跨平台的，与软、硬件无关的，处理与传输信息的工具。</li>
<li>5.XML未来将会无所不在，XML将成为最普遍的数据处理和数据传输的工具。</li>
</ul>
<p><strong>关于DOM：</strong></p>
<p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有VBScript、ActiveX、以及微软自家的DHTML格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。<br>DOM= Document Object Model，文档对象模型，DOM可以以一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的常用方法。DOM很重要，DOM的设计是以对象管理组织（OMG）的规约为基础的，因此可以用于任何编程语言。最初人们把它认为是一种让JavaScript在浏览器间可移植的方法，不过DOM的应用已经远远超出这个范围。DOM技术使得用户页面可以动态地变化，如可以动态地显示或隐藏一个元素，改变它们的属性，增加一个元素等，DOM技术使得页面的交互性大大地增强。<br>DOM实际上是以面向对象方式描述的文档模型。DOM定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。可以把DOM认为是页面上数据和结构的一个树形表示，不过页面当然可能并不是以这种树的方式具体实现。</p>
<p>通过 JavaScript，您可以重构整个 HTML 文档。您可以添加、移除、改变或重排页面上的项目。要改变页面的某个东西，JavaScript 就需要获得对 HTML 文档中所有元素进行访问的入口。这个入口，连同对 HTML 元素进行添加、移动、改变或移除的方法和属性，都是通过文档对象模型来获得的（DOM）。</p>
<h3 id="4-2-2-JSON文件"><a href="#4-2-2-JSON文件" class="headerlink" title="4.2.2 JSON文件"></a>4.2.2 JSON文件</h3><p>JSON(JavaScript Object Notation, JS对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的JS规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<p><strong>JSON 语法规则：</strong><br>在JS 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。<br>但是对象和数组是比较特殊且常用的两种类型：</p>
<ul>
<li>1.对象表示为键值对</li>
<li>2.数据由逗号分隔</li>
<li>3.花括号保存对象</li>
<li>4.方括号保存数组</li>
</ul>
<p>JSON键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，<br>键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值<br>{“firstName”: “Json”,”class”:”aid1710”}<br>这很容易理解，等价于这条 JavaScript 语句：<br>{firstName : “Json”,”class”:”aid1710”}</p>
<p><strong>JSON与JS对象的关系：</strong></p>
<p>很多人搞不清楚 JSON 和JS对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：JSON是 JS对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。<br>如var obj = {a: ‘Hello’, b: ‘World’}; //这是一个对象，注意键名也是可以使用引号包裹的<br>var json = ‘{“a”: “Hello”, “b”: “World”}’; //这是一个 JSON 字符串，本质是一个字符串。<br>Python中关于JSON的操作简单演示：<br>SpiderCodes\ josnTest.py</p>
<p><strong>JSON和XML的比较:</strong></p>
<ul>
<li>1.可读性：<br>JSON和XML的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。</li>
<li>2.可扩展性：<br>XML天生有很好的扩展性，JSON当然也有，没有什么是XML可以扩展而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着xml不可比拟的优势。</li>
<li>3.编码难度：<br>XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有提供的工具。无工具的情况下，相信熟练的开发人员一样能很快的写出想要的xml文档和JSON字符串，不过，xml文档要多很多结构上的字符。</li>
<li>4.解码难度</li>
</ul>
<p><strong>XML的解析方式有两种：</strong></p>
<ul>
<li><p>一是通过文档模型解析，也就是通过父标签索引出一组标记。例如：xmlData.getElementsByTagName(“tagName”)，但是这样是要在预先知道文档结构的情况下使用，无法进行通用的封装。</p>
</li>
<li><p>另外一种方法是遍历节点（document 以及 childNodes）。这个可以通过递归来实现，不过解析出来的数据仍旧是形式各异，往往也不能满足预先的要求。凡是这样可扩展的结构数据解析起来一定都很困难。JSON也同样如此。如果预先知道JSON结构的情况下，使用JSON进行数据传递简直是太美妙了，可以写出很实用美观可读性强的代码。</p>
</li>
</ul>
<p>如果你是纯粹的前台开发人员，一定会非常喜欢JSON。但是如果你是一个应用开发人员，就不是那么喜欢了，毕竟xml才是真正的结构化标记语言，用于进行数据传递。而如果不知道JSON的结构而去解析JSON的话，那简直是噩梦。费时费力不说，代码也会变得冗余拖沓，得到的结果也不尽人意。<br>但是这样也不影响众多前台开发人员选择JSON。因为json.js中的toJSONString()就可以看到JSON的字符串结构。当然不是使用这个字符串，这样仍旧是噩梦。常用JSON的人看到这个字符串之后，就对JSON的结构很明了了，就更容易的操作JSON。以上是在Javascript中仅对于数据传递的xml与</p>
<p><strong>JSON的解析。</strong><br>在Javascript地盘内，JSON毕竟是主场作战，其优势当然要远远优越于xml。<br>如果JSON中存储Javascript复合对象，而且不知道其结构的话，相信很多程序员也一样是哭着解析JSON的。除了上述之外，JSON和XML还有另外一个很大的区别在于有效数据率。JSON作为数据包格式传输的时候具有更高的效率，这是因为JSON不像XML那样需要有严格的闭合标签，这就让有效数据量与总数据包比大大提升，从而减少同等数据流量的情况下，网络的传输压力。</p>
<p><strong>实例比较：</strong></p>
<p>XML和JSON都使用结构化方法来标记数据，下面来做一个简单的比较。<br>用XML表示中国部分省市数据如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;country&gt;
    &lt;name&gt;中国&lt;/name&gt;
    &lt;province&gt;
        &lt;name&gt;黑龙江&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;哈尔滨&lt;/city&gt;
            &lt;city&gt;大庆&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;广东&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;广州&lt;/city&gt;
            &lt;city&gt;深圳&lt;/city&gt;
            &lt;city&gt;珠海&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;台湾&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;台北&lt;/city&gt;
            &lt;city&gt;高雄&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
    &lt;province&gt;
        &lt;name&gt;新疆&lt;/name&gt;
        &lt;cities&gt;
            &lt;city&gt;乌鲁木齐&lt;/city&gt;
        &lt;/cities&gt;
    &lt;/province&gt;
&lt;/country&gt;
</code></pre><p>用JSON表示如下：</p>
<pre><code>{
    &quot;name&quot;: &quot;中国&quot;,
    &quot;province&quot;: [{
        &quot;name&quot;: &quot;黑龙江&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;哈尔滨&quot;, &quot;大庆&quot;]
        }
    }, {
        &quot;name&quot;: &quot;广东&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;广州&quot;, &quot;深圳&quot;, &quot;珠海&quot;]
        }
    }, {
        &quot;name&quot;: &quot;台湾&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;台北&quot;, &quot;高雄&quot;]
        }
    }, {
        &quot;name&quot;: &quot;新疆&quot;,
        &quot;cities&quot;: {
            &quot;city&quot;: [&quot;乌鲁木齐&quot;]
        }
    }]
}
</code></pre><p>可以看到：JSON简单的语法格式和清晰的层次结构明显要比XML容易阅读，并且在数据交换方面，由于JSON所使用的字符要比XML少得多，可以大大得节约传输数据所占用得带宽。</p>
<h2 id="4-3-怎么提取网页中的信息"><a href="#4-3-怎么提取网页中的信息" class="headerlink" title="4.3 怎么提取网页中的信息"></a>4.3 怎么提取网页中的信息</h2><h3 id="4-3-1-XPath与lxml"><a href="#4-3-1-XPath与lxml" class="headerlink" title="4.3.1 XPath与lxml"></a>4.3.1 XPath与lxml</h3><p>XPath是一门在XML文档中查找信息的语言，对XPath的理解是很多高级XML应用的基础，XPath在XML中通过元素和属性进行导航。<br>lxml是一个用来处理XML的第三方 Python 库，它在底层封装了用 C 语言编写的 libxml2和libxslt，并以简单强大的Python API，兼容并加强了著名的Element Tree API。<br>安装：pip install lxml<br>使用：from lxml import etree</p>
<p><strong> 1.XPath术语：</strong><br>在XPath语境中，XML 文档被视作节点树，节点树的根节点也被称作文档节点。 XPath 将节点树中的节点（Node）分为七类：元素（Element），属性（Attribute），文本（Text），命名空间（Namespace），处理指令（Processing-instruction），注释（Comment）和文档节点（Document nodes）。<br>看一下 XML 文档例子： </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;bookstore&gt;
&lt;book&gt;
  &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;
  &lt;author&gt;J K. Rowling&lt;/author&gt; 
  &lt;year&gt;2005&lt;/year&gt;
  &lt;price&gt;29.99&lt;/price&gt;
&lt;/book&gt;
&lt;/bookstore&gt;
</code></pre><p>以上的XML文档中：</p>
<pre><code>&lt;bookstore&gt; （这是一个“根”）
&lt;author&gt;J K. Rowling&lt;/author&gt; （这是一个“元素”）
lang=&quot;en&quot; （这是一个“属性”）
</code></pre><p>从另一个视角来看它：</p>
<pre><code>bookstore                      （根）
book                         （元素）
title                        （元素）
lang  = en                   （属性）
text = Harry Potter          （文本）
author                       （元素）
text = J K. Rowling          （文本）
year                         （元素）
text = 2005                  （文本）
price                        （元素）
text = 29.99                 （文本）
</code></pre><p><strong> 2.节点之间的关系</strong><br>父（Parent）：每个元素都肯定有一个父节点，最顶层的元素父亲是根节点。同理每个属性必然有一个父，它们的父是元素。 上例XML文档中，根bookstore是元素 book 的父节点，book是元素title, author, year, price 的父节点，title是lang 的父节点。<br>子（Children）：元素可以有零或多个子。上例XML文档中，title, author, year, price是book的子节点。<br>同胞（Sibling）：父节点相同的节点之间互为同胞，也称彼此的兄弟节点。上例XM文档中，title, author, year, price 彼此互为同胞。<br>先辈（Ancestor）：某节点的父节点、父的父，以此类推一直追溯至根节点之间所有节点。上例XM文档中，title, author, year, price 的先辈就是 book, bookstore。<br>后代（Descendant）：某节点的子节点、子的子，以此类推至最后一个子节点之间所有节点。上例XM文档中，bookstore 的后代就是 title, author, year, price 。</p>
<p><strong> 3.选取节点</strong><br>以下为基本路径的表达方式，记住XPath的路径表达式都是基于某个节点之上的，例如最初的当前节点一般是根节点，这与Linux下路径切换原理是一样的。<br>表达式描述：<br>nodename     选取已匹配节点下名为 nodename 的子元素节点<br>/            如果以 / 开头，表示从根节点作为选取起点。<br>//            在已匹配节点后代中选取节点，不考虑目标节点的位置。<br>.            选取当前节点。<br>..            选取当前节点的父元素节点。<br>@            选取属性。</p>
<p><strong> 4.通配符</strong></p>
<p>*          匹配任何元素。<br>@*        匹配任何属性。<br>node()      匹配任何类型的节点。</p>
<p><strong> 5.预判（Predicates）或 条件选取</strong><br>预判是用来查找某个特定的节点或者符合某种条件的节点，预判表达式位于方括号中。使用 “|” 运算符，你可以选取符合“或”条件的若干路径。<br>具体例子见下面代码lxmlTest.py。</p>
<p><strong> 6.坐标轴</strong></p>
<p>XPath 坐标轴：坐标轴用于定义当对当前节点的节点集合。</p>
<table>
<thead>
<tr>
<th>坐标轴名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ancestor</td>
<td>选取当前节点的所有先辈元素及根节点。</td>
</tr>
<tr>
<td>ancestor-or-self</td>
<td>选取当前节点的所有先辈以及当前节点本身。</td>
</tr>
<tr>
<td>attibute</td>
<td>选取当前节点的所有属性。</td>
</tr>
<tr>
<td>child</td>
<td>选取当前节点的所有子元素。</td>
</tr>
<tr>
<td>descendant</td>
<td>选取当前节点的所有后代元素。</td>
</tr>
<tr>
<td>descendant-or-self</td>
<td>选取当前节点的所有后代元素以及当前节点本身。</td>
</tr>
<tr>
<td>following</td>
<td>选取文档中当前节点的结束标签之后的所有节点。</td>
</tr>
<tr>
<td>following-sibling</td>
<td>选取当前节点之后的所有同级节点。</td>
</tr>
<tr>
<td>namespace</td>
<td>选取当前节点的所有命名空间节点。</td>
</tr>
<tr>
<td>parent</td>
<td>选取当前节点的父节点。</td>
</tr>
<tr>
<td>preceding</td>
<td>选取当前节点的开始标签之前的所有节点。</td>
</tr>
<tr>
<td>preceding-sibling</td>
<td>选取当前节点之前的所有同级节点。</td>
</tr>
<tr>
<td>self</td>
<td>选取当前节点。</td>
</tr>
</tbody>
</table>
<p><strong> 7.位置路径的表达式</strong></p>
<p>位置路径可以是绝对路径，也可以是相对路径。绝对路径以 “/” 开头。每条路径包括一个或多个步，每步之间以“/”分隔。</p>
<pre><code>绝对路径：/step/step/…
相对路径：step/step/…
</code></pre><p>每步根据当前节点集合中的节点计算。</p>
<p>步（step）包括三部分：</p>
<pre><code>坐标轴（axis）：      定义所选节点与当前节点之间的关系。
节点测试（node-test）：识别某个坐标轴内部的节点。
预判（predicate）：    提出预判条件对节点集合进行筛选。
</code></pre><p>步的语法：坐标轴::节点测试[预判]<br>**代码例子：SpiderCodes \lxmlTest.py</p>
<h3 id="4-3-2-BeautifulSoup4"><a href="#4-3-2-BeautifulSoup4" class="headerlink" title="4.3.2 BeautifulSoup4"></a>4.3.2 BeautifulSoup4</h3><p>Beautiful Soup是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航（navigating），搜索以及修改剖析树的操作。它可以大大节省你的编程时间。<br>安装：(sudo) pip install beautifuilsoup4<br>使用：<br>在程序中导入 Beautiful Soup库:<br>from BeautifulSoup import BeautifulSoup          # For processing HTML<br>from BeautifulSoup import BeautifulStoneSoup     # For processing XML<br>import BeautifulSoup                             # To get everything</p>
<p>//代码例子</p>
<pre><code>from bs4 import BeautifulSoup
import re
doc = [&apos;&lt;html&gt;&lt;head&gt;&lt;title&gt;Page title&lt;/title&gt;&lt;/head&gt;&apos;,
       &apos;&lt;body&gt;&lt;p id=&quot;firstpara&quot; align=&quot;center&quot;&gt;This is paragraph &lt;b&gt;one&lt;/b&gt;.&apos;,
       &apos;&lt;p id=&quot;secondpara&quot; align=&quot;blah&quot;&gt;This is paragraph &lt;b&gt;two&lt;/b&gt;.&apos;,
       &apos;&lt;/html&gt;&apos;]
soup = BeautifulSoup(&apos;&apos;.join(doc))
print soup.prettify()
</code></pre><p>定位某些 soup元素很简单，比如上例：</p>
<pre><code>    soup.contents[0].name

    soup.contents[0].contents[0].name

    head = soup.contents[0].contents[0]

    head.parent.name

    head.next

    head.nextSibling.name

    head.nextSibling.contents[0]

    head.nextSibling.contents[0].nextSibling

也可以利用soup，获得特定标签或有着特定属性的标签，修改soup也很简单；
</code></pre><p>**代码例子：SpiderCodes \ testBS4.py<br>进一步阅读，可以参考：<br> <a href="https://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html</a></p>
<p><strong>BS4 与 lxml的比较：</strong><br>lxml    C实现，只会局部遍历,快；        复杂，语法不太友好；<br>BS4     Python实现，会加载整个文档,慢； 简单，API人性化；</p>
<h3 id="4-3-3-正则表达式re"><a href="#4-3-3-正则表达式re" class="headerlink" title="4.3.3 正则表达式re"></a>4.3.3 正则表达式re</h3><p>被用来检索\替换那些符合某个模式(规则)的文本,对于文本过滤或规则匹配,最强大的就是正则表达式,是python爬虫里必不可少的神兵利器。</p>
<p>基本匹配规则：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0-9]</td>
<td>任意一个数字，等价\d</td>
</tr>
<tr>
<td>[a-z]</td>
<td>任意一个小写字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>任意一个大写字母</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配非数字，等价\D</td>
</tr>
<tr>
<td>\w</td>
<td>等价[a-z0-9_]，字母数字下划线</td>
</tr>
<tr>
<td>\W</td>
<td>等价对\w取非</td>
</tr>
<tr>
<td>.</td>
<td>任意字符</td>
</tr>
<tr>
<td>[]</td>
<td>匹配内部任意字符或子表达式</td>
</tr>
<tr>
<td>[^]</td>
<td>对字符集合取非</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的字符或者子表达式0次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前一个字符至少1次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前一个字符0次或多次</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结束</td>
</tr>
</tbody>
</table>
<p><strong>Python使用正则表达式</strong><br>Python的re模块<br>pattern 编译好的正则表达式<br><em>几个重要的方法：</em><br>match： 匹配一次从开头;<br>search： 匹配一次，从某位置；<br>findall: 匹配所有；<br>split: 分隔；<br>sub: 替换；</p>
<p><em>需要注意的两种模式： </em><br>贪婪模式：(.<em>)<br>懒惰模式：(.</em>?)</p>
<p>代码例子见： SpiderCodes\greedyRe.py</p>
<p><strong>练习： </strong><br>1.使用一个正则表达式来匹配url链接；如<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>2.抓取<a href="http://example.webscraping.com/sitemap.xml下的数据" target="_blank" rel="noopener">http://example.webscraping.com/sitemap.xml下的数据</a><br>见：rePracticep2.py<br>3.用正则表达式实现下面的效果：<br>把 i=d%0A&amp;from=AUTO&amp;to=AUTO&amp;smartresult=dict<br>转换成下面的形式：<br>i:d%0A<br>from:AUTO<br>to:AUTO<br>smartresult:dict</p>
<p>关于正则表达式，更多的细节，可以读下这篇文章：<br><a href="https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html" target="_blank" rel="noopener">https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html</a></p>
<p>总结：正则，BS，lxml的比较</p>
<h1 id="第五章-动态网页的挑战"><a href="#第五章-动态网页的挑战" class="headerlink" title="第五章 动态网页的挑战"></a>第五章 动态网页的挑战</h1><p>很多网站的数据，比如电商网站商品的价格，评论等等会采用动态加载的方式来加载，这样可能在爬虫程序刚刚访问时无法直接获取到相关数据。那么怎么应对这样的问题呢？</p>
<h2 id="5-1-动态网页的使用场景"><a href="#5-1-动态网页的使用场景" class="headerlink" title="5.1 动态网页的使用场景"></a>5.1 动态网页的使用场景</h2><p>先看下面一个例子：<br>     这是京东上看一本书的场景。我们发现打开一本书之后，书的价格，排名等信息及书的评论信息不是在我们第一次打开网站时就立即加载进来的。而是通过二次请求或多次的异步请求获取的。这样的页面就是动态页面。<br>关于动态页面使用的场景：<br>    希望异步刷新的场景。有些网页内容很多，一次加载完对服务器压力很大，而且有的用户不会去查看所有内容；</p>
<h2 id="5-2-回到与HTTP服务器发送请求数据的原始方法"><a href="#5-2-回到与HTTP服务器发送请求数据的原始方法" class="headerlink" title="5.2 回到与HTTP服务器发送请求数据的原始方法"></a>5.2 回到与HTTP服务器发送请求数据的原始方法</h2><h3 id="5-2-1-GET方法"><a href="#5-2-1-GET方法" class="headerlink" title="5.2.1 GET方法"></a>5.2.1 GET方法</h3><p>GET把参数数据队列添加到URL中，Key和Value的各个字段一一对应；在URL中可以看到。<br>浏览器的URL中有些符号，字符不能被很好的识别。那么我们需要有一套编码的方式来传递信息。所以发送端需要做urlencode； 接收端需要做urldecode;<br><a href="https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=python%20%E7%88%AC%E8%99%AB&amp;oq=python%2520%25E7%2588%25AC%25E8%2599%25AB&amp;rsv_pq=ef9e51560000eca9&amp;rsv_t=db33UmQaiVre2ourDQMjsxtS03DJVCOUAc2AHonGCIhHT2or8zim%2F96kVGA&amp;rqlang=cn&amp;rsv_enter=0&amp;prefixsug=python%2520%25E7%2588%25AC%25E8%2599%25AB&amp;rsp=0&amp;rsv_sug=2" target="_blank" rel="noopener">https://www.baidu.com/s?ie=utf-8&amp;f=3&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=python%20%E7%88%AC%E8%99%AB&amp;oq=python%2520%25E7%2588%25AC%25E8%2599%25AB&amp;rsv_pq=ef9e51560000eca9&amp;rsv_t=db33UmQaiVre2ourDQMjsxtS03DJVCOUAc2AHonGCIhHT2or8zim%2F96kVGA&amp;rqlang=cn&amp;rsv_enter=0&amp;prefixsug=python%2520%25E7%2588%25AC%25E8%2599%25AB&amp;rsp=0&amp;rsv_sug=2</a><br>在线测试工具: <a href="http://tool.chinaz.com/tools/urlencode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/urlencode.aspx</a></p>
<p>1.<a href="https://www.baidu.com/s?wd=DNS?xxx=yyy&amp;time=zzz" target="_blank" rel="noopener">https://www.baidu.com/s?wd=DNS?xxx=yyy&amp;time=zzz</a> get 请求的标识<br>2.<a href="http://acb.com/login?name=zhangsan&amp;password=123" target="_blank" rel="noopener">http://acb.com/login?name=zhangsan&amp;password=123</a><br>login: name=zhangsan  password=123<br>示例代码：<br>          SpiderCodes\baiduSearch.py</p>
<h3 id="5-2-2-POST方法"><a href="#5-2-2-POST方法" class="headerlink" title="5.2.2 POST方法"></a>5.2.2 POST方法</h3><p>通过一个例子来看POST方法的使用：</p>
<p>这是有道翻译的页面，仔细观察会发现，当用户每次输入一个想要翻译的词语时，页面的URL信息并不发生任何改变。这是一个典型的异步使用Ajax的技术，用JSON格式进行数据的传递。<br>我们如何利用爬虫程序来实现一个自己的翻译器呢？<br>来看代码示例：SpiderCodes\youdaofanyip2.py</p>
<h2 id="5-3-更加难以对付的动态网站"><a href="#5-3-更加难以对付的动态网站" class="headerlink" title="5.3 更加难以对付的动态网站"></a>5.3 更加难以对付的动态网站</h2><h3 id="5-3-1-应对需要多次数据的交互模拟的网站"><a href="#5-3-1-应对需要多次数据的交互模拟的网站" class="headerlink" title="5.3.1 应对需要多次数据的交互模拟的网站"></a>5.3.1 应对需要多次数据的交互模拟的网站</h3><p>我们有时会遇到像淘宝这样的大型网站，对数据版权看得特别重的，它们的网站有大量的工程师和技术人员去维护，它们也可能在技术手段上采用多次交互数据包的方式来完成网站服务器与用户浏览器之间的交互。如果此时还采用传统的分析数据包的方式会比较的复杂，难度较高。那么，有没有一劳永逸的方法，来解决此类问题呢？<br>我们的解决方案是：Selenium + PhantomJS。<br>     我们的爬虫其实就是在做模拟浏览器的行为。</p>
<h3 id="5-3-2-Selenium"><a href="#5-3-2-Selenium" class="headerlink" title="5.3.2 Selenium"></a>5.3.2 Selenium</h3><p>一个Web自动化测试工具，最初是为了网站自动化测试而开发的；我们玩游戏有按键精灵；Selenium也可以做类似的事情，但是它是在浏览器中做这样的事情。<br>安装： sudo pip install selenium(pip install selenium)<br>在Python中 from selenium import webdriver 来测试是否装好<br>说明：想要用Python做自动化测试的童鞋们可以好好研究一下Selenium的使用。</p>
<h3 id="5-3-3-PhantomJS"><a href="#5-3-3-PhantomJS" class="headerlink" title="5.3.3 PhantomJS"></a>5.3.3 PhantomJS</h3><p>一个基于webkit无界面(headless)的浏览器,它可以把网站加载到内存中并执行页面上的JS，但它没有图形用户界面，所以耗费的资源比较少；<br>安装：    sudo apt install phantomjs （此方法可能安装不完整,导致部分功能无法使用）<br><strong>Linux Ubuntu下完全安装的方法</strong>(参看<a href="http://blog.csdn.net/m0_38124502/article/details/79276499" target="_blank" rel="noopener">http://blog.csdn.net/m0_38124502/article/details/79276499</a><br>)<br>Wget<br><a href="https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2" target="_blank" rel="noopener">https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2</a></p>
<pre><code>cd 下载
tar -xvf phantomjs-2.1.1-linux-x86_64.tar.bz2 
cd phantomjs-2.1.1-linux-x86_64/
cd bin/
sudo cp phantomjs /usr/bin
</code></pre><p>python -启动-&gt; 浏览器进程phantomjs，</p>
<p><strong>测试：</strong><br>SpiderCodes\Phantomjs..  对其中的例子helloworld.js， pageload.js<br>进行测试；<br>注意：   <em>**</em>有可能造成资源泄漏；为了避免这种事的发生，需要有个策略适当的时候去kill phantomjs进程。</p>
<h3 id="5-3-4-Selenium-PhantomJS"><a href="#5-3-4-Selenium-PhantomJS" class="headerlink" title="5.3.4 Selenium + PhantomJS"></a>5.3.4 Selenium + PhantomJS</h3><p>双剑合璧利用二者同时完成某个任务，示例代码如下：<br>SpiderCodes\testPhantomJS.py</p>
<h2 id="5-4-关于动态网站信息抓取的总结"><a href="#5-4-关于动态网站信息抓取的总结" class="headerlink" title="5.4 关于动态网站信息抓取的总结"></a>5.4 关于动态网站信息抓取的总结</h2><p>总的来说，我们的爬虫要尽量模拟的看起来就像是真正的用户在浏览器上访问服务器网站的行为。如果我们使用GET或POST的方式来模拟浏览器与服务器间通信的行为，成本比较低，但是应对复杂的网站或者服务器精心防御的网站来说是很难骗过服务器的。Selenim+PhantomJS的方案则会让我们的程序看起来更像是普通的用户，但是它的效率相对而言会降低很多，速度也会慢很多。在大规模爬去数据时可能遇到许多新的挑战。（比如网站尺寸的设置，等待时间的设定等）</p>
<p><strong>练习：</strong><br>抓取猫眼电影 <a href="http://maoyan.com/board/4?offset" target="_blank" rel="noopener">http://maoyan.com/board/4?offset</a> 中TOP100的电影榜单；</p>
<h1 id="第六章-表单与爬虫登录问题"><a href="#第六章-表单与爬虫登录问题" class="headerlink" title="第六章 表单与爬虫登录问题"></a>第六章 表单与爬虫登录问题</h1><p>前面的章节中，我们介绍了如果在客户端与服务器之间进行数据交换。我们可以使用GET方法和POST方法与服务器进行交互，敏感数据只应使用POST请求进行发送，以避免将书暴露在URL中。当然，服务器还支持其他HTTP方法，比如PUT和DELETE等方法，但这些方法在表单中都不支持。</p>
<h2 id="6-1-关于表单"><a href="#6-1-关于表单" class="headerlink" title="6.1 关于表单"></a>6.1 关于表单</h2><p>客户端的浏览器需要与网站服务器进行交互，服务器需要根据用户输入返回对应的信息。<br>来看w3c的一个例子：<br><a href="http://www.w3school.com.cn/html/html_forms.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html/html_forms.asp</a><br>关于GET，POST与服务器的交互方法，可以见5.2节。<br>下面我们重点来看一个怎么处理登录表单的问题。</p>
<h2 id="6-2-管理cookie"><a href="#6-2-管理cookie" class="headerlink" title="6.2 管理cookie"></a>6.2 管理cookie</h2><h3 id="6-2-1-使用cookie登录"><a href="#6-2-1-使用cookie登录" class="headerlink" title="6.2.1 使用cookie登录"></a>6.2.1 使用cookie登录</h3><p>HTTP协议本身是无状态的，怎么保存来过或登陆过网站的信息？<br>所以我们需要在HTTP协议之外通过某种机制来识别用户的身份。于是就有了Session和Cookie。</p>
<p><strong>什么是Cookie，什么是Session？</strong><br><strong>会话(Session)跟踪</strong>是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p>
<p><strong>Cookie</strong>意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。所以就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p><strong>Cookie</strong>实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，<br>以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<p>我们通过一个实例来看一下怎么使用Cookie做登录的操作。有些时候爬虫只有登录之后才能抓取到网页中的信息。比如微博，知乎，人人网等。<br>关于Cookie的更详细信息，可以参看： <a href="https://www.w3cschool.cn/pegosu/skj81ozt.html" target="_blank" rel="noopener">https://www.w3cschool.cn/pegosu/skj81ozt.html</a><br>使用Cookie登录页面，见Demo: SpiderCodes\testRenrenLoginwithCookiep2.py</p>
<h3 id="6-2-2-补充知识-cookiejar的使用"><a href="#6-2-2-补充知识-cookiejar的使用" class="headerlink" title="6.2.2 补充知识 cookiejar的使用"></a>6.2.2 补充知识 cookiejar的使用</h3><p>Cookie有时间限制，有域的限制，有编码问题等等。如果自己来管理Cookie，会很繁琐，特别是当有多个Cookie需要管理时，想要很好的管理Cookie很困难。<br>当遇到网页登录后，返回302跳转的情况下，urllib2的Response会丢失Set-Cookie的信息，导致登录不成功。<br>我们需要一个通用的能处理Cookie的工具来自动处理Set-Cookie请求；自动管理过期的Cookie，自动在对应域下发特殊Cookie；为了应对这些问题，我们引入了CookieJar；</p>
<h2 id="6-3-关于验证码（CAPTCHA）"><a href="#6-3-关于验证码（CAPTCHA）" class="headerlink" title="6.3 关于验证码（CAPTCHA）"></a>6.3 关于验证码（CAPTCHA）</h2><p>网站为了防止黑客程序的恶意欺诈和攻击，采取的一种防御措施。据说最早是paypal这家公司引入的技术，现在已经在互联网网站中被广泛使用。</p>
<p>一般处理验证码CAPTCHA有两种方式：<br> 1）在需要输入验证码时程序弹出图片让用户自己输入；<br> 2）使用图像识别技术来识别图中的信息；</p>
<p>光学字符识别 OCR：OCR（Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法，将形状翻译成计算机文字的过程;<br>程序处理复杂验证码的方法：</p>
<h3 id="6-3-1．使用Google的开源项目-Tesseract；"><a href="#6-3-1．使用Google的开源项目-Tesseract；" class="headerlink" title="6.3.1．使用Google的开源项目 Tesseract；"></a>6.3.1．使用Google的开源项目 Tesseract；</h3><p>安装Tesseract：<br>Ubuntu中安装：</p>
<pre><code>sudo apt-get install tesseract-ocr
pip install pytesseract
</code></pre><p>训练与测试：<a href="https://www.cnblogs.com/cnlian/p/5765871.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnlian/p/5765871.html</a></p>
<p>简单的Python测试代码：</p>
<pre><code>from PIL import Image
from pytesseract import *

image = Image.open(&apos;test1.jpg&apos;)

text = image_to_string(image)
print(text)
</code></pre><p>Demo见SpiderCodes\TestOCR\</p>
<h3 id="6-3-2-使用百度AI等等："><a href="#6-3-2-使用百度AI等等：" class="headerlink" title="6.3.2.使用百度AI等等："></a>6.3.2.使用百度AI等等：</h3><p>见Demo: TestBaiduAI.py<br>添加两个Demo：关于验证码识别的处理</p>
<h1 id="第七章-爬虫的持久化问题"><a href="#第七章-爬虫的持久化问题" class="headerlink" title="第七章 爬虫的持久化问题"></a>第七章 爬虫的持久化问题</h1><p>爬虫抓取回来的数据，怎么储存？<br>直接存储在文件中吗，还是存成JSON文件的格式呢。如果数据量巨大呢。我们抓回来的数据是需要将来能够被很好的查询和使用的。那怎么办呢?</p>
<h2 id="7-1-MySQL"><a href="#7-1-MySQL" class="headerlink" title="7.1 MySQL"></a>7.1 MySQL</h2><p>安装：<br>    pip install PyMySQL<br>使用：<br>   见PyMysql.py</p>
<h2 id="7-2-MongoDB"><a href="#7-2-MongoDB" class="headerlink" title="7.2 MongoDB"></a>7.2 MongoDB</h2><h3 id="7-2-1-什么是MongoDB"><a href="#7-2-1-什么是MongoDB" class="headerlink" title="7.2.1 什么是MongoDB"></a>7.2.1 什么是MongoDB</h3><p><a href="https://qixinyue.github.io/2018/08/07/mongodb/" title="mongo" target="_blank" rel="noopener">https://qixinyue.github.io/2018/08/07/mongodb/</a></p>
<h3 id="7-2-2-怎么在爬虫中使用MongoDB"><a href="#7-2-2-怎么在爬虫中使用MongoDB" class="headerlink" title="7.2.2 怎么在爬虫中使用MongoDB"></a>7.2.2 怎么在爬虫中使用MongoDB</h3><h3 id="7-3-HDFS-HBase"><a href="#7-3-HDFS-HBase" class="headerlink" title="7.3 HDFS, HBase"></a>7.3 HDFS, HBase</h3><h1 id="第八章-高效率的爬取数据"><a href="#第八章-高效率的爬取数据" class="headerlink" title="第八章 高效率的爬取数据"></a>第八章 高效率的爬取数据</h1><p>人多力量大，多人干事更快。多个爬虫一起干活效率也更高。<br>随着爬虫抓取数据的提速，及数据量抓取的庞大，问题也会凸显。对方也会尝试用各种手段来禁止爬虫的行为。</p>
<h2 id="8-1-多进程爬虫"><a href="#8-1-多进程爬虫" class="headerlink" title="8.1 多进程爬虫"></a>8.1 多进程爬虫</h2><h2 id="8-2-多线程爬虫"><a href="#8-2-多线程爬虫" class="headerlink" title="8.2 多线程爬虫"></a>8.2 多线程爬虫</h2><h3 id="8-2-1-关于GIL"><a href="#8-2-1-关于GIL" class="headerlink" title="8.2.1 关于GIL"></a>8.2.1 关于GIL</h3><h3 id="8-2-2-线程池的出场"><a href="#8-2-2-线程池的出场" class="headerlink" title="8.2.2 线程池的出场"></a>8.2.2 线程池的出场</h3><h2 id="8-3-关于代理服务器的设置"><a href="#8-3-关于代理服务器的设置" class="headerlink" title="8.3 关于代理服务器的设置"></a>8.3 关于代理服务器的设置</h2><p>有过一定做爬虫经验的人应该都知道，抓的网站和数据多了，如果爬虫抓取速度过快，免不了触发网站的防爬机制，几乎用的同一招就是封IP。<br>解决方案有2个：</p>
<pre><code>1、同一IP，放慢速度(爬取速度慢)
2、使用代理IP访问(推荐)
</code></pre><p>第一种方案牺牲的就是时间和速度，来换取数据，但是一般情况下我们的时间是很宝贵的，我们希望做到的是用最短的时间获取最多的数据，所以应该尽量使用第二种方案。<br>问题是从哪里能找到这么多代理IP呢？</p>
<p>这个问题可以问问搜索引擎。当然如果能结合爬虫程序来问搜索引擎那效率会更高。<br>代码示例：<br>    SpiderCodes\testProxy.py</p>
<p>练习：<a href="https://www.kuaidaili.com/ops/" target="_blank" rel="noopener">https://www.kuaidaili.com/ops/</a> 从这个网页中爬取代理服务器,<br>附录A中有100个代理服务器的地址，请写个程序测试一个看看有多少个是可以正常使用的。</p>
<h1 id="第九章-大数据量时的去重"><a href="#第九章-大数据量时的去重" class="headerlink" title="第九章 大数据量时的去重"></a>第九章 大数据量时的去重</h1><p>随着抓取的数据量到一定程度，数据重复及爬取过程中的死链问题会凸显。怎么来解决这些问题呢？</p>
<h2 id="9-1-怎么去重"><a href="#9-1-怎么去重" class="headerlink" title="9.1 怎么去重"></a>9.1 怎么去重</h2><h2 id="9-2-Redis数据库"><a href="#9-2-Redis数据库" class="headerlink" title="9.2 Redis数据库"></a>9.2 Redis数据库</h2><h3 id="9-2-1-关于Redis"><a href="#9-2-1-关于Redis" class="headerlink" title="9.2.1 关于Redis"></a>9.2.1 关于Redis</h3><h3 id="9-2-2-实际项目中使用Redis"><a href="#9-2-2-实际项目中使用Redis" class="headerlink" title="9.2.2 实际项目中使用Redis"></a>9.2.2 实际项目中使用Redis</h3><h3 id="9-3-BloomFilter"><a href="#9-3-BloomFilter" class="headerlink" title="9.3 BloomFilter"></a>9.3 BloomFilter</h3><h1 id="第十章-Scrapy框架"><a href="#第十章-Scrapy框架" class="headerlink" title="第十章 Scrapy框架"></a>第十章 Scrapy框架</h1><p>在了解了爬虫各种基础知识之后，我们有时需要快速搭建一个个爬虫的程序。有没有这么一个方便的工具或框架能让我们快速搭建起一个个爬虫程序呢？Scrapy呼之欲出。</p>
<h2 id="10-1-什么是Scrapy"><a href="#10-1-什么是Scrapy" class="headerlink" title="10.1 什么是Scrapy"></a>10.1 什么是Scrapy</h2><p>纯Python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。框架本身把一些重复性的工作给你做好了；你就可以轻轻松松的按照其框架本身写几个简单的模块或者简单的扩展一些模块就可以你个性化的功能；当然带来的问题是首先你要学习了解框架，还有，想突破框架本身的限制，比较困难；<br>Scrapy是基于Twisted(竞争对手Tornado)异步网络框架，Scrapy的组件及架构图如下：</p>
<p>Scrapy Engine(引擎): 负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。<br>Scheduler(调度器): 它负责接受引擎发送过来Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。<br>Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spider来处理。<br>Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)。<br>Item Pipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方。<br>Downloader Middlewares（下载中间件）：可以当作是一个可以自定义扩展下载功能的组件。<br>Spider Middlewares（Spider中间件）：可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses; 和从Spider出去的Requests）</p>
<h2 id="10-2-怎么安装使用Scrapy"><a href="#10-2-怎么安装使用Scrapy" class="headerlink" title="10.2 怎么安装使用Scrapy"></a>10.2 怎么安装使用Scrapy</h2><p>下面运行的环境是Ubuntu 17.04</p>
<h3 id="10-2-1-安装"><a href="#10-2-1-安装" class="headerlink" title="10.2.1 安装"></a>10.2.1 安装</h3><p>安装Scrapy in Ubuntu：</p>
<pre><code>sudo apt-get install python-dev python-pip libxml2-dev libxslt1-dev
sudo pip install scrapy
</code></pre><h3 id="10-2-2-制作一个Scrapy爬虫需要的四个步骤"><a href="#10-2-2-制作一个Scrapy爬虫需要的四个步骤" class="headerlink" title="10.2.2 制作一个Scrapy爬虫需要的四个步骤"></a>10.2.2 制作一个Scrapy爬虫需要的四个步骤</h3><ul>
<li><p>新建项目 (scrapy startproject spiderName)新建一个新的爬虫项目，一个项目可能包含很多个爬虫;<br>scrapy startproject tencentSpider<br>查看项目结构：</p>
<p>  tarena@tedu:~/Spider/tencentSpider$ tree.：<br>  ├── scrapy.cfg<br>  └── tencentSpider</p>
<pre><code>├── __init__.py
├── items.py
├── middlewares.py
├── pipelines.py
├── settings.py
└── spiders
    └── __init__.py
</code></pre><p>  2 directories, 7 files</p>
</li>
<li><p>明确目标：明确你想要抓取的目标，生产一个具体的爬虫</p>
<p>  scrapy genspider tencent<br>  cd tencentSpider<br>  scrapy genspider tencent hr.tencent.com<br>  tarena@tedu:~/Spider/tencentSpider$ tree<br>  ├── scrapy.cfg<br>  ├── tecentLog.txt<br>  └── tencentSpider</p>
<pre><code>├── __init__.py
├── __init__.pyc
├── items.py
├── middlewares.py
├── pipelines.py
├── settings.py
├── settings.pyc
└── spiders
    ├── __init__.py
    ├── __init__.pyc
    └── tecent.py
</code></pre><p>  2 directories, 12 files</p>
</li>
</ul>
<p>下面需要具体取修改代码逻辑，按照我们的需求去实现自己的爬虫逻辑：<br>修改setttings.py 设置</p>
<pre><code>pipelines.py 保存的逻辑
tecent.py,   抓取页面信息和继续跳转的逻辑
items.py     保存item的映射
</code></pre><ul>
<li>制作爬虫 (spiders/spiderName.py)：制作爬虫开始爬取网页;</li>
<li><p>存储内容 (pipelines.py)：设计管道存储爬取内容;</p>
</li>
<li><p>在Scrapy下启动爬虫：<br>scrapy crawl tencent</p>
</li>
</ul>
<h1 id="第十一章-反爬及应对反爬的策略"><a href="#第十一章-反爬及应对反爬的策略" class="headerlink" title="第十一章 反爬及应对反爬的策略"></a>第十一章 反爬及应对反爬的策略</h1><p>随着抓取的数据量到一定程度，数据重复及爬取过程中的死链问题会凸显。怎么来解决反爬问题呢？</p>
<h2 id="11-1-网站如何发现爬虫"><a href="#11-1-网站如何发现爬虫" class="headerlink" title="11.1 网站如何发现爬虫"></a>11.1 网站如何发现爬虫</h2><p>一般来说，网站会有以下一些简单的策略发现爬虫程序：<br>  1）单一IP非常规的访问频次；<br>  2）单一IP非常规的数据流量；<br>  3）大量重复简单的网站浏览行为，只下载网页，没有后续的JS,CSS请求；<br>  5）通过一些陷阱来发现爬虫，例如一些通过CSS对用户隐藏的链接，只有爬虫才会访问；</p>
<h2 id="11-2-网站如何进行反爬"><a href="#11-2-网站如何进行反爬" class="headerlink" title="11.2 网站如何进行反爬"></a>11.2 网站如何进行反爬</h2><p>一般来说网站会采用下面两个简单的策略来防止爬虫：<br>1.大量使用动态网页，是的爬虫的爬取难度增加，重要数据都拿不到，即使爬虫采用了Web环境来渲染（内置浏览器），也会大大增加爬虫的负担和爬虫时间；（当然，采用动态加载的技术，对服务器的负担也会大大减轻）<br>2.基于流量的拒绝：<br>  开启带宽限制模块，限制每个IP最多连接数，最大带宽等；</p>
<h2 id="11-3-爬虫如何发现自己可能被网站识别了"><a href="#11-3-爬虫如何发现自己可能被网站识别了" class="headerlink" title="11.3 爬虫如何发现自己可能被网站识别了"></a>11.3 爬虫如何发现自己可能被网站识别了</h2><p>如果爬取过程中出现以下情况，那么小心了，你的爬虫可能被网站发现了：<br>    1.验证码出现；<br>    2.Unusual content delivery delay 非常规的延时;<br>    3.Frequent response with HTTP 403, 404, 301 or 50x error;</p>
<h2 id="11-4-爬虫应对反爬的策略"><a href="#11-4-爬虫应对反爬的策略" class="headerlink" title="11.4 爬虫应对反爬的策略"></a>11.4 爬虫应对反爬的策略</h2><p>我们可以从以下几个方面来考虑应对反爬：<br>1）User-Agent池；<br>2）代理服务器池；<br>3）CookieJar等的管理；<br>4）协议的细节考虑，如：需要大量的实践经验总结的<br>          抓取数据时不处理CSS，JS等；<br>          nofollow属性；css的display属性；探测陷阱；<br>          验证refer locator等；<br>5）使用分布式的多机策略；爬慢点，把爬虫放到访问频繁的主站IP子网下，如教育网；<br>6）使用了规则来批量爬取，需对规则进行组合；<br>7）验证码的搞定：机器学习，图像识别；<br>8）尽可能遵守Robots协议；</p>
<p><strong>总结与进一步工作</strong><br><strong>这十一篇主要面对初级及中级爬虫工程师的参考资料。由于本人能力及知识有限，目前只能总结到这里。但是关于爬虫的知识和技术，互联网知识和技术更新换代非常快。后期本人会尽我所能，根据实际工程需要，增加新的实用的知识。</strong></p>
<p>附录A 收集到的100个可能能用的代理服务器<br>106.39.179.236:80<br>23.94.191.219:1080<br>121.41.175.199:80<br>122.183.139.98:8080<br>118.193.107.182:80<br>92.42.109.45:1080<br>128.199.77.93:8080<br>46.101.60.239:8118<br>185.106.121.98:1080<br>185.82.203.81:1080<br>112.114.93.27:8118<br>104.131.69.203:80<br>138.201.0.184:1080<br>46.101.46.174:8118<br>178.62.123.38:8118<br>217.23.15.193:1080<br>60.168.207.208:8010<br>139.59.170.110:8118<br>223.241.118.228:8010<br>123.192.114.113:80<br>103.37.95.110:8000<br>180.179.43.250:80<br>185.117.74.81:1080<br>116.199.2.196:80<br>118.193.107.119:80<br>128.199.77.93:8000<br>170.246.114.213:8080<br>104.243.47.146:1080<br>111.3.108.44:8118<br>124.42.7.103:80<br>39.134.161.18:80<br>146.185.156.221:8118<br>47.89.249.110:80<br>118.193.107.192:80<br>124.232.163.10:3128<br>223.19.105.206:80<br>46.166.168.243:1080<br>118.114.77.47:8080<br>182.253.205.85:8090<br>45.55.132.29:9999<br>58.251.227.238:8118<br>118.193.107.142:80<br>118.193.107.135:80<br>118.193.107.219:80<br>46.101.45.212:8118<br>114.249.45.176:8118<br>80.152.201.116:8080<br>94.177.254.86:80<br>197.155.158.22:80<br>196.200.173.83:80<br>212.237.10.45:8080<br>188.166.144.173:8118<br>210.71.198.230:8118<br>177.114.228.112:8080<br>218.50.2.102:8080<br>198.204.251.158:1080<br>188.166.204.221:8118<br>185.117.74.126:1080<br>106.39.179.244:80<br>39.134.161.14:8080<br>85.10.247.136:1080<br>46.166.168.245:1080<br>5.167.50.35:3129<br>118.178.227.171:80<br>122.96.59.102:82<br>52.174.89.111:80<br>103.25.173.237:808<br>121.232.145.168:9000<br>103.251.167.8:1080<br>46.101.26.217:8118<br>171.37.178.175:9797<br>103.251.166.18:1080<br>186.225.176.93:8080<br>121.232.147.132:9000<br>104.224.168.178:8888<br>47.90.2.253:8118<br>121.232.145.82:9000<br>118.193.107.36:80<br>58.56.128.84:9001<br>139.59.153.59:80<br>122.183.139.101:8080<br>163.172.184.226:8118<br>198.204.251.146:1080<br>213.133.100.195:1080<br>42.104.84.106:8080<br>117.2.64.109:8888<br>121.232.144.229:9000<br>156.67.219.61:8080<br>138.36.106.90:80<br>1.179.233.66:80<br>222.33.192.238:8118<br>138.197.224.12:8118<br>151.106.10.6:1080<br>134.35.250.204:8080<br>58.251.227.233:8118<br>52.221.40.19:80<br>222.73.68.144:8090<br>46.166.168.247:1080<br>192.99.222.207:80<br>1.23.160.212:8080</p>
<p>附录B Python2与3 urllib库对照表<br>参照 <a href="http://blog.csdn.net/whatday/article/details/54710403" target="_blank" rel="noopener">http://blog.csdn.net/whatday/article/details/54710403</a><br><strong>Python2    与     Python3   urllib库对照表：</strong></p>
<table>
<thead>
<tr>
<th>python2urllib库</th>
<th>python3urllib库</th>
</tr>
</thead>
<tbody>
<tr>
<td>urllib.urlretrieve()</td>
<td>urllib.request.urlretrieve()</td>
</tr>
<tr>
<td>urllib.urlcleanup()</td>
<td>urllib.request.urlcleanup()</td>
</tr>
<tr>
<td>urllib.quote()</td>
<td>urllib.parse.quote() </td>
</tr>
<tr>
<td>urllib.quote_plus()</td>
<td>urllib.parse.quote_plus()</td>
</tr>
<tr>
<td>urllib.unquote()</td>
<td>urllib.parse.unquote()</td>
</tr>
<tr>
<td>urllib.unquote_plus()</td>
<td>urllib.parse.unquote_plus()</td>
</tr>
<tr>
<td>urllib.urlencode()</td>
<td>urllib.parse.urlencode()</td>
</tr>
<tr>
<td>urllib.pathname2url()</td>
<td>urllib.request.pathname2url()</td>
</tr>
<tr>
<td>urllib.url2pathname()</td>
<td>urllib.request.url2pathname()</td>
</tr>
<tr>
<td>urllib.getproxies()</td>
<td>urllib.request.getproxies()</td>
</tr>
<tr>
<td>urllib.URLopener</td>
<td>urllib.request.URLopener </td>
</tr>
<tr>
<td>urllib.FancyURLopener</td>
<td>urllib.request.FancyURLopener</td>
</tr>
<tr>
<td>urllib.ContentTooShortError</td>
<td>urllib.error.ContentTooShortError</td>
</tr>
<tr>
<td>urllib2.urlopen()</td>
<td>urllib.request.urlopen()</td>
</tr>
<tr>
<td>urllib2.install_opener()</td>
<td>urllib.request.install_opener()</td>
</tr>
<tr>
<td>urllib2.build_opener()</td>
<td>urllib.request.build_opener()</td>
</tr>
<tr>
<td>urllib2.URLError</td>
<td>urllib.error.URLError</td>
</tr>
<tr>
<td>urllib2.HTTPError</td>
<td>urllib.error.HTTPError</td>
</tr>
<tr>
<td>urllib2.Request</td>
<td>urllib.request.Request</td>
</tr>
<tr>
<td>urllib2.OpenerDirector</td>
<td>urllib.request.OpenerDirector</td>
</tr>
<tr>
<td>urllib2.BaseHandler</td>
<td>urllib.request.BaseHandler</td>
</tr>
<tr>
<td>urllib2.HTTPDefaultErrorHandler</td>
<td>urllib.request.HTTPDefaultErrorHandler</td>
</tr>
<tr>
<td>urllib2.HTTPRedirectHandler</td>
<td>urllib.request.HTTPRedirectHandler</td>
</tr>
<tr>
<td>urllib2.HTTPCookieProcessor</td>
<td>urllib.request.HTTPCookieProcessor</td>
</tr>
<tr>
<td>urllib2.ProxyHandler</td>
<td>urllib.request.ProxyHandler</td>
</tr>
<tr>
<td>urllib2.HTTPPasswordMgr</td>
<td>urllib.request.HTTPPasswordMgr</td>
</tr>
<tr>
<td>urllib2.HTTPPasswordMgrWithDefaultRealm</td>
<td>urllib.request.HTTPPasswordMgrWithDefaultReam</td>
</tr>
<tr>
<td>urllib2.AbstractBasicAuthHandler</td>
<td>urllib.request.AbstractBasicAuthHandler</td>
</tr>
<tr>
<td>urllib2.HTTPBasicAuthHandler</td>
<td>urllib.request.HTTPBasicAuthHandler</td>
</tr>
<tr>
<td>urllib2.ProxyBasicAuthHandler</td>
<td>urllib.request.ProxyBasicAuthHandler</td>
</tr>
<tr>
<td>urllib2.AbstractDigestAuthHandler</td>
<td>urllib.request.AbstractDigestAuthHandler</td>
</tr>
<tr>
<td>urllib2.HTTPDigestAuthHandler</td>
<td>urllib.request.HTTPDigestAuthHandler</td>
</tr>
<tr>
<td>urllib2.ProxyDigestAuthHandler</td>
<td>urllib.request.ProxyDigestAuthHandler</td>
</tr>
<tr>
<td>urllib2.HTTPHandler</td>
<td>urllib.request.HTTPHandler</td>
</tr>
<tr>
<td>urllib2.HTTPSHandler</td>
<td>urllib.request.HTTPSHandler</td>
</tr>
<tr>
<td>urllib2.FileHandler</td>
<td>urllib.request.FileHandler</td>
</tr>
<tr>
<td>urllib2.FTPHandler</td>
<td>urllib.request.FTPHandler</td>
</tr>
<tr>
<td>urllib2.CacheFTPHandler</td>
<td>urllib.request.CacheFTPHandler </td>
</tr>
<tr>
<td>urllib2.UnknownHandler</td>
<td>urllib.request.UnknownHandler</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/mysql/" itemprop="url">mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T20:43:07+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,524 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  36 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h1 id="MySQL-第一部分"><a href="#MySQL-第一部分" class="headerlink" title="MySQL-第一部分"></a>MySQL-第一部分</h1></blockquote>
<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><ul>
<li><h2 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h2><p>数据库是存储数据的仓库</p>
</li>
<li><h2 id="哪些公司在用数据库"><a href="#哪些公司在用数据库" class="headerlink" title="哪些公司在用数据库"></a>哪些公司在用数据库</h2><p>金融机构、游戏网站、购物网站、论坛网站 … …</p>
</li>
<li><h2 id="提供数据库服务的软件"><a href="#提供数据库服务的软件" class="headerlink" title="提供数据库服务的软件"></a>提供数据库服务的软件</h2></li>
</ul>
<ul>
<li><p>软件分类<br>MySQL、SQL_Server、Oracle、DB2、MongoDB、Mariadb … …</p>
</li>
<li><p>在生产环境中,如何选择使用哪个数据库软件<br>1、 是否开源<br>  开源软件：MySQL、MongoDB、Mariadb<br>  商业软件：Oracle、DB2、SQL_Server<br>2、 是否跨平台<br>  不跨平台：SQL_Server<br>  跨平台：MySQL、MongoDB、Oracle、DB2、Mariadb<br>3、 公司的类型<br>  商业软件：政府部门、金融机构<br>  开源软件：游戏网站、购物网站、论坛网站 …</p>
</li>
</ul>
<ul>
<li><h2 id="MySQL特点"><a href="#MySQL特点" class="headerlink" title="MySQL特点"></a>MySQL特点</h2></li>
</ul>
<h3 id="1-关系型数据库"><a href="#1-关系型数据库" class="headerlink" title="1 关系型数据库"></a>1 关系型数据库</h3><h4 id="关系型数据库特点"><a href="#关系型数据库特点" class="headerlink" title="关系型数据库特点"></a>关系型数据库特点</h4><p>1、数据是以行和列的形式去存储的<br>2、表中的每一行叫一条记录<br>3、表中的每一列叫一个字段<br>4、表和表之间的逻辑关联叫关系</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>1、关系型数据库存储<br>表1、学生信息表</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
<th>班级</th>
</tr>
</thead>
<tbody>
<tr>
<td>星矢</td>
<td>25</td>
<td>三班</td>
</tr>
<tr>
<td>水冰月</td>
<td>26</td>
<td>六班</td>
</tr>
</tbody>
</table>
<p>表2、班级信息表</p>
<table>
<thead>
<tr>
<th>班级</th>
<th>班主任</th>
</tr>
</thead>
<tbody>
<tr>
<td>三班</td>
<td>大空翼</td>
</tr>
<tr>
<td>六班</td>
<td>松人</td>
</tr>
</tbody>
</table>
<p>2、非关系型数据库存储<br>{“姓名”:”星矢”,”年龄”:25,”班级”:”三班”}<br>{“姓名”:”水冰月”,”年龄”:26,”班级”:”六班”,”班主任”:”松人”}</p>
<h3 id="2-跨平台"><a href="#2-跨平台" class="headerlink" title="2 跨平台"></a>2 跨平台</h3><p>可以在Unix、Linux、Windows上运行数据库服务</p>
<h3 id="3-支持多种编程语言"><a href="#3-支持多种编程语言" class="headerlink" title="3 支持多种编程语言"></a>3 支持多种编程语言</h3><p>  python、java、php …</p>
<ul>
<li><h2 id="数据库软件、数据库、数据仓库"><a href="#数据库软件、数据库、数据仓库" class="headerlink" title="数据库软件、数据库、数据仓库"></a>数据库软件、数据库、数据仓库</h2>1、 数据库软件<br>是一种软件,可以看得见,可操作,用来实现数据库逻辑功能<br>2、 数据库<br>是一种逻辑概念,用来存储数据的仓库,侧重存储<br>3、 数据仓库<br>从数据量来说,数据仓库要比数据库庞大的多,主要用于数据挖掘和数据分析</li>
</ul>
<p>数据库：user表 验证<br>数据仓库：哪个时间段用户登录量最多,哪个用户一年购物最多,……</p>
<h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><h3 id="Ubuntu安装MySQL"><a href="#Ubuntu安装MySQL" class="headerlink" title="Ubuntu安装MySQL"></a>Ubuntu安装MySQL</h3><p>1、安装服务端<br>    <code>sudo apt-get install mysql-server</code><br>2、安装客户端<br>    <code>sudo apt-get install mysql-client</code><br>3、Ubuntu安装软件<br>    <code>1、sudo apt-get update
    2、sudo apt-get -f install</code><br>        修复依赖关系</p>
<h3 id="Windows安装MySQL服务"><a href="#Windows安装MySQL服务" class="headerlink" title="Windows安装MySQL服务"></a>Windows安装MySQL服务</h3><p>1、下载MySQL安装包<br>    <code>mysql-installer***5.7.***.msi</code><br>2、双击、按照教程安装即可</p>
<h2 id="启动和连接"><a href="#启动和连接" class="headerlink" title="启动和连接"></a>启动和连接</h2><p>1、服务端启动</p>
<pre><code>* sudo /etc/init.d/mysql start
* sudo /etc/init.d/mysql status | stop | restart
</code></pre><p>2、客户端连接</p>
<ul>
<li>命令格式<br>  mysql -h主机地址 -u用户名 -p密码<br>  mysql -hlocalhost -uroot -p123456</li>
<li>本地登录可省略-h选项<br>  mysql -uroot -p123456</li>
</ul>
<h2 id="基本SQL命令"><a href="#基本SQL命令" class="headerlink" title="基本SQL命令"></a>基本SQL命令</h2><h3 id="1-SQL命令的使用规则"><a href="#1-SQL命令的使用规则" class="headerlink" title="1  SQL命令的使用规则"></a>1  SQL命令的使用规则</h3><ul>
<li>每条命令必须以 ; 结尾</li>
<li>SQL命令不区分字母大小写</li>
<li>使用 \c 终止当前命令的执行</li>
</ul>
<h3 id="2-库的管理"><a href="#2-库的管理" class="headerlink" title="2  库的管理"></a>2  库的管理</h3><ul>
<li>库的基本操作<br>  1、查看已有的库<pre><code>show databases;
</code></pre>  2、创建库(指定字符集)<pre><code>create database 库名 [character set utf8];
</code></pre>  3、查看创建库的语句<pre><code>show create database 库名;
</code></pre>  4、查看当前所在库<pre><code>select database();
</code></pre>  5、切换库<pre><code>use 库名;
</code></pre>  6、查看库中已有表<pre><code>show tables;
</code></pre>  7、删除库<pre><code>drop database 库名;
</code></pre></li>
<li><p>练习<br>  1、创建库testdb,指定字符集为utf8</p>
<pre><code>create database testdb character set utf8;
</code></pre><p>  2、进入到库testdb</p>
<pre><code>use testdb;
</code></pre><p>  3、查看当前所在库</p>
<pre><code>select database();
</code></pre><p>  4、创建库testdb2,指定字符集为latin1</p>
<pre><code>create database testdb2 character set latin1;
</code></pre><p>  5、进入到库testdb2</p>
<pre><code>use testdb2;
</code></pre><p>  6、查看testdb2的默认字符集</p>
<pre><code>show create database testdb2;
</code></pre><p>  7、删除库testdb</p>
<pre><code>drop database testdb;
</code></pre><p>  8、删除库testdb2</p>
<pre><code>drop database testdb2;
</code></pre></li>
<li><p>库名的命名规则<br>  1、可以使用数字、字母、_,但是不能为纯数字<br>  2、库名区分字母大小写<br>  3、库名具有唯一性<br>  4、不能使用特殊字符和mysql关键字</p>
</li>
</ul>
<h3 id="3-表的管理"><a href="#3-表的管理" class="headerlink" title="3  表的管理"></a>3  表的管理</h3><ul>
<li><p>表的基本操作<br>  1、创建表</p>
<pre><code>create table 表名(
字段名1        数据类型,
字段名2        数据类型,
字段名3        数据类型
);
</code></pre><p>  2、查看创建表的语句(字符集、存储引擎)</p>
<pre><code>show create table 表名;
</code></pre><p>  3、查看表结构</p>
<pre><code>desc 表名;
</code></pre><p>  4、删除表</p>
<pre><code>drop table 表名;
</code></pre></li>
<li><p>练习<br>  1、创建库python1<br>  2、在 python1 库中创建表 pymysql并指定字符集为utf8,字段有三个：id  name  age 数据类型自己定义<br>  3、查看表pymysql的默认字符集和存储引擎<br>  4、查看表 pymysql 的表结构<br>  5、删除表 pymysql<br>  6、删除库 python1<br>  7、创建库 python2<br>  8、在库python2中创建表 t1 指定字符集utf8,字段有 id name score三个,数据类型自己定义<br>  9、查看t1的表结构</p>
</li>
<li><p>注意<br>  1、所有的数据都是以文件的形式存放在数据库目录下<br>  2、数据库目录：/var/lib/mysql</p>
</li>
</ul>
<h3 id="4-表记录的管理"><a href="#4-表记录的管理" class="headerlink" title="4 表记录的管理"></a>4 表记录的管理</h3><ul>
<li><p>在表中插入记录<br>  1、insert into 表名 values(值1),(值2),…;<br>  2、insert into 表名(字段名1,字段名2,…) values(值1),(值2),…;</p>
</li>
<li><p>查询表记录<br>  1、select * from 表名 [where 条件];<br>  2、select 字段名1,字段名2,… from 表名 [where 条件];</p>
</li>
<li><p>练习<br>  1、查看所有库<br>  2、创建一个新库 studb<br>  3、在 studb 中创建一张表 tab1,指定字符集utf8,表中字段有 id  name  age  score 四个<br>  4、查看tab1的表结构</p>
<pre><code>desc tab1;
</code></pre><p>  5、在 tab1 中随意插入2条记录</p>
<pre><code>insert into tab1 values
(1,&quot;Tom&quot;,22,100),(2,&quot;Lucy&quot;,23,80);
</code></pre><p>  6、在 tab1 的name,age两个字段插入2条记录</p>
<pre><code>insert into tab1(name,age) values
(&quot;Bob&quot;,30),(&quot;Green&quot;,33);
</code></pre><p>  7、查看 tab1 中的所有记录</p>
<pre><code>select * from tab1;
</code></pre><p>  8、查看 tab1 中所有人的名字和成绩</p>
<pre><code>select name,score from tab1;
</code></pre></li>
</ul>
<h3 id="5-如何更改库的默认字符集"><a href="#5-如何更改库的默认字符集" class="headerlink" title="5 如何更改库的默认字符集"></a>5 如何更改库的默认字符集</h3><ul>
<li><p>方法<br>通过更改MySQL的配置文件实现</p>
</li>
<li><p>步骤<br>  1、获取root权限</p>
<pre><code>sudo -i
</code></pre><p>  2、备份mysql的配置文件</p>
<pre><code>cd /etc/mysql/mysql.conf.d/
cp mysqld.cnf mysqld.cnf.bak
</code></pre><p>  3、修改配置文件</p>
<pre><code>subl mysqld.cnf
在[mysqld]下面添加：
character_set_server = utf8
</code></pre><p>  4、重启MySQL服务/重新加载配置文件(force-reload)<br>  /etc/init.d/mysql restart | force-reload<br>  5、创建库验证默认字符集是否为utf8</p>
</li>
</ul>
<h3 id="6-客户端把数据存储到数据库服务器上的过程"><a href="#6-客户端把数据存储到数据库服务器上的过程" class="headerlink" title="6 客户端把数据存储到数据库服务器上的过程"></a>6 客户端把数据存储到数据库服务器上的过程</h3><pre><code>1、连接到数据库服务器 mysql -h ... -u ... -p ...
2、选择库  use 库名
3、创建表/修改表 
4、断开与数据库服务器的连接 exit | quit | \q
</code></pre><h3 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7 数据类型"></a>7 数据类型</h3><ul>
<li>数值类型()</li>
</ul>
<ul>
<li><p>1、整型<br>1、int 大整型(4个字节)</p>
<pre><code>取值范围：0 ~ 2**32 -1(42亿多)
</code></pre><p>2、tinyint 微小整型(1个字节)</p>
<pre><code>1、有符号(signed默认) :-128 ~ 127
2、无符号(unsigned) : 0 ~ 255
</code></pre><p>3、smallint 小整型(2个字节)<br>4、bigint 极大整型(8个字节) 0 ~ 2**64 -1</p>
</li>
<li><p>2、浮点型<br>1、float(4个字节,最多显示7个有效位)</p>
<pre><code>1、用法
    字段名 float(m,n)  m:总位数 n:小数位位数
    float(5,2) 取值范围？ -999.99 ~ 999.99
2、注意
    1、浮点型插入整数时会自动补全小数位
    2、小数位如果多于指定的位数,会对下一位四舍五入
</code></pre><p>2、double(8个字节,最多显示15个有效位)<br>3、decimal(最多显示28个有效位)</p>
<pre><code>1、字段名 decimal(m,n)
2、存储空间(整数部分和小数部分分开存储)
    规则：将9位数字的倍数包装成4个字节
    即：对于每个部分,需要4个字节来存储9位数的每个倍数,剩余数字所需的存储空间如下表：

    剩余数字    字节
       0        0
        1-2       1
        3-4       2
        5-6       3
        7-9       4
    示例：decimal(19,9) ---&gt;9字节
        整数部分：10/9=商1余1 4字节+1字节=5字节
        小数部分：9/9=商1余0  4字节+0字节=4字节
</code></pre></li>
</ul>
<ul>
<li>字符类型</li>
</ul>
<ul>
<li>1、char(定长)<br>  1、宽度取值范围：1~255<br>  2、不给定宽度默认为1</li>
</ul>
<ul>
<li>2、varchar(变长)<br>  1、取值范围：1~65535</li>
</ul>
<ul>
<li>3、char 和 varchar 的特点<br>  1、char：浪费存储空间,但是性能高<br>  2、varchar：节省存储空间,但是性能低</li>
</ul>
<ul>
<li>4、text / longtext(4G) / blob / longblob(4G)</li>
</ul>
<ul>
<li>5、字符类型的宽度和数值类型的宽度的区别<br>  1、数值类型的宽度为显示宽度,仅仅用于select查询时显示,和占用的存储空间大小无关,可用zerofill查看效果<br>  2、字符类型的宽度超过则无法存储</li>
</ul>
<ul>
<li>6、练习<br>  1、创建一个库studb2,在studb2库中创建表tab,字段如下：<pre><code>学号：id 要求显示宽度为2,位数不够用0填充
姓名：name 变长,宽度20
年龄：age 微小整型,不能输入负数
身高：height 浮点型,小数位为2位
工资：salary 浮点型,最大为 9999 9999 . 99
 create table tab(
-&gt; id int(2) zerofill,
-&gt; name varchar(20),
-&gt; age tinyint unsigned,
-&gt; height float(5,2),
-&gt; salary decimal(10,2)
-&gt; );
</code></pre>  2、查看 tab 的表结构<br>  3、在表中插入 1 条记录<br>  4、查询所有学生的 id 、name 、height 和 salary    </li>
</ul>
<ul>
<li><p>枚举类型(字段值只能在列举的范围内选择)<br>  1、单选(最多65535个不同值)</p>
<pre><code>字段名 enum(值1,值2,...,值N)
</code></pre><p>  2、多选(最多64个不同值)</p>
<pre><code>字段名 set(值1,值2,...,值N)
插入记录时 &quot;girl,python,mysql&quot;
</code></pre></li>
<li><p>日期时间类型<br>  1、year : 年 YYYY<br>  2、date : 日期 YYYYMMDD<br>  3、time : 时间 HHMMSS<br>  4、datetime</p>
<pre><code>timestamp : 日期时间 YYYYMMDDHHMMSS
</code></pre><p>  5、示例</p>
<pre><code> mysql&gt; create table t11(
-&gt; id int,
-&gt; name char(15),
-&gt; birth_year year,
-&gt; birthday date,
-&gt; class time,
-&gt; meeting datetime
-&gt; )character set utf8;
</code></pre></li>
</ul>
<p>作业：面试题<br>  1、MySQL中的数据类型有：<strong><strong> </strong></strong> <strong><strong> </strong></strong><br>  2、关系型数据库的核心内容是 _关系_ 即 <em>二维表</em><br>  3、简述客户端把数据存储到数据库服务器上的过程<br>  4、char和varchar的区别,各自的特点<br>  5、创建一个学校的库 school<br>  6、在库中创建一个表 students 存储学生信息,字段如下<br>    学号(显示宽度为3,不够用0填充)、姓名、年龄(不能为负数)、手机号、成绩(浮点型)、性别(单选)、爱好(多选)、入学时间(年月日)<br>  7、查看students的表结构<br>  8、在表中随意插入1条记录<br>  9、在表中的 姓名、手机号、成绩 三个字段插入3条记录<br>  10、查看所有学生的姓名、手机号和成绩</p>
<blockquote>
<h1 id="MySQL-第二部分"><a href="#MySQL-第二部分" class="headerlink" title="MySQL-第二部分"></a>MySQL-第二部分</h1></blockquote>
<h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><ul>
<li><p>1、 NOW() 返回服务器当前时间 YYYY-MM-DD HH:MM:SS</p>
</li>
<li><p>2、CURDATE() 返回当前日期 YYYY-MM-DD</p>
</li>
<li><p>3、CURTIME() 返回当前时间 HH:MM:SS</p>
</li>
<li><p>4、year(时间) 返回指定时间的年份</p>
</li>
<li><p>5、date(时间) 返回指定时间的日期</p>
</li>
<li><p>6、time(时间) 返回指定时间的时间<br>  insert into t11 values(2,”Tom”,year(now()),date(now()),time(now()),now())</p>
</li>
<li><p>7、日期时间运算<br>  1、语法格式</p>
<pre><code>select ... from 表名 where 
字段名 运算符 (时间 interval 时间间隔单位);
interval ：间隔类型关键字
时间间隔单位 ：
    1 day
    2 hour | minute | year | month
</code></pre><p>  2、示例</p>
<pre><code>1、查询1天以内的记录
    select * from t11 where 
    meeting &gt; (now() - interval 1 day);
                    现在时间 - 1天时间 = 1天以前的时间点
    解释：
    where id &gt; 5 

    where meeting &gt; 时间点
             2018-05-31 00:00:00 &gt; 2018-05-31 08:00:00

2、查询1天以前3天以内的记录
    select * from t11 where 
    meeting &lt; (now()-interval 1 day) and
    meeting &gt; (now()-interval 3 day);
</code></pre></li>
</ul>
<h2 id="表字段的操作"><a href="#表字段的操作" class="headerlink" title="表字段的操作"></a>表字段的操作</h2><pre><code>1、语法：alter table 表名 执行动作;
2、添加字段(add)
    alter table 表名 add 字段名 数据类型;
    alter table 表名 add 字段名 数据类型 first;
    alter table 表名 add 字段名 数据类型 after 字段名;
3、删除字段(drop)
    alter table 表名 drop 字段名;
4、修改字段数据类型(modify)
    alter table 表名 modify 字段名 新数据类型;
    # 修改数据类型会受到表中原有数据的限制
</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><pre><code>1、创建库 studb2
2、在库中创建表 stuinfo,字段如下：
    姓名、年龄、手机号 char(11)
3、查看表结构
4、在表中第一列添加一个字段：学号
    alter table stuinfo add id int first;
5、把手机号的数据类型改为 bigint 8个字节
    alter table stuinfo modify phnumber bigint;
6、在表中最后一列添加一个字段：注册时间 register,数据类型为：timestamp
    alter table stuinfo add register timestamp;
7、在表中 学号、姓名、年龄、手机号 四个字段插入2条记录
    insert into stuinfo(id,name,age,phnumber) values
    (1,&quot;Tom&quot;,20,13838384386),(2,&quot;Jim&quot;,25,13999999999);
8、查询5分钟内的记录明细
    select * from stuinfo where
    register &gt; (now() - interval 5 minute);
</code></pre><h2 id="表记录的管理-删除、更改"><a href="#表记录的管理-删除、更改" class="headerlink" title="表记录的管理(删除、更改)"></a>表记录的管理(删除、更改)</h2><pre><code>1、删除表记录
    1、delete from 表名 where 条件;
    2、注意
        delete语句后如果不加where条件,会将表中所有记录全部删除
2、更改表记录
    1、update 表名 set 字段1=值1,字段2=值2 where 条件;
    2、注意
        update语句后如果不加where条件,会将表中所有记录全部更新
3、练习
    1、查找所有蜀国英雄的记录
        select * from hero where country=&quot;蜀国&quot;;
    2、查找一下女英雄的姓名和性别
        select name,sex from hero where sex=&quot;女&quot;;
    3、把id为2的记录姓名改为 司马懿,性别改为 男,国家改为 魏国
        update hero set name=&quot;司马懿&quot;,sex=&quot;男&quot;,country=&quot;魏国&quot; where id=2;
    4、删除所有的魏国人
        delete from hero where country=&quot;魏国&quot;;
    5、把魏延的编号(id)改为 66
    update hero set id=66 where name=&quot;魏延&quot;;
    6、删除hero表中的所有英雄
        delete from hero;
</code></pre><h2 id="运算符操作"><a href="#运算符操作" class="headerlink" title="运算符操作"></a>运算符操作</h2><pre><code>1、数值比较&amp;字符比较
    1、数值比较运算符：=、!=、&gt;、&gt;=、&lt;、&lt;=
    2、字符比较运算符：=、!=
    3、示例
        1、查找sanguo表中攻击力大于200的英雄的姓名和攻击力
            select name,gongji from sanguo where gongji&gt;200;
2、逻辑比较
    1、and (两个或多个条件同时满足)
    2、or (两个或多个条件有一个条件满足就可以)
    3、示例
        1、找出攻击值大于200的蜀国英雄的名字和攻击值
            select name,gongji from sanguo where gongji&gt;200 and country=&quot;蜀国&quot;;
        2、将吴国英雄中攻击值为110的英雄的攻击值设置为100,防御值设置为60
            update sanguo set gongji=100,fangyu=60 where country=&quot;吴国&quot; and gongji=110;
        3、查找蜀国和魏国的英雄
            select * from sanguo where country=&quot;蜀国&quot; or country=&quot;魏国&quot;;
3、范围内比较
    1、运算符
        where 字段名 between 值1 and 值2  # 值为数字
        where 字段名 in(值1,值2,...)
        where 字段名 not in(值1,值2,...)
    2、示例
        1、查找攻击值在100-200之间的蜀国英雄信息
            select * from sanguo where gongji between 100 and 200 and country=&quot;蜀国&quot;;
        2、查找编号为1、3或5的蜀国英雄 和 貂蝉的 编号、姓名和国家
            select id,name,country from sanguo where id in(1,3,5) and country=&quot;蜀国&quot; or name=&quot;貂蝉&quot;;
        3、查找蜀国和吴国以外的国家的女英雄信息
            select * from sanguo where country not in(&quot;蜀国&quot;,&quot;吴国&quot;) and sex=&quot;女&quot;;
4、匹配空、非空
    1、空 ：is null
    2、非空：is not null
    3、示例
        1、查找姓名为NULL的蜀国女英雄信息
            select * from sanguo  where name is null and country=&quot;蜀国&quot; and sex=&quot;女&quot;;
        2、查找姓名为&quot;&quot;的英雄的 id 姓名 和 国家
            select id,name,country from sanguo where name=&quot;&quot;;
    4、注意
        1、null ：空值,必须用is 或者 is not 去匹配
        2、&quot;&quot;        ：空字符串,只能用 = 或者 != 去匹配
5、模糊比较
    1、语法格式 
        where 字段名 like 表达式
    2、表达式
        1、_ ：匹配单个字符
        2、% ：匹配0到多个字符
    3、示例
        # 匹配名字中至少有2个字符的记录
        select name from sanguo where name like &quot;_%_&quot;;
        # 匹配所有记录(NULL除外)
        select name from sanguo where name like &quot;%&quot;;
        # 匹配名字中有三个字符的记录
        select name from sanguo where name like &quot;___&quot;;
        # 匹配姓 赵 的英雄记录
        select name from sanguo where name like &quot;赵%&quot;;
</code></pre><h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><pre><code>1、总结(执行顺序)
    3、select ...聚合函数 from 表名
    1、where ...
    2、group by ...
    4、having ...
    5、order by ...
    6、limit ...
2、order by(给查询结果进行排序)
    1、order by 字段名 排序方式
    2、排序方式
        1、ASC(默认) ：升序
        2、DESC ：降序
    3、示例
        1、将英雄按防御值从低到高排序
            select * from sanguo order by fangyu ASC;
        2、将蜀国英雄按攻击值从高到低排序
            select * from sanguo  where country=&quot;蜀国&quot; order by gongji desc;
        3、将魏蜀两国男英雄中名字为三个字的英雄按防御值升序排列
            select * from sanguo  where country in(&quot;魏国&quot;,&quot;蜀国&quot;) and sex=&quot;男&quot; and   name like &quot;___&quot; order by fangyu ASC;
3、limit(永远放在SQL语句的最后写)
    1、作用 ：限制显示查询记录的个数
    2、用法
        1、limit n  --&gt;显示 n 条记录
        2、limit m,n --&gt;从 m+1 条记录开始,显示 n 条记录
             limit 2,3 --&gt;显示3、4、5三条记录
            ## m的值是从0开始计数,2则表示第3条记录
    3、示例
        1、在蜀国英雄中,查找防御值倒数第二名到倒数第四名的英雄记录
            select * from sanguo  where country=&quot;蜀国&quot;  order by fangyu ASC limit 1,3;
        2、在蜀国且名字不为空值的英雄中,查找攻击值前三名的英雄的姓名、攻击值和国家
            select name,gongji,country from sanguo where country=&quot;蜀国&quot; and name is not null  order by gongji desc  limit 3;
4、聚合函数
    1、分类
        1、avg(字段名) : 求该字段的平均值
        2、sum(字段名)
        3、max(字段名)
        4、min(字段名)
        5、count(字段名) : 统计该字段记录的个数
    2、示例
        1、攻击力最强值
            select max(gongji) from sanguo;
        2、统计表中 id 和 name 字段分别有多少条记录
            select count(id),count(name) from sanguo;
            ## 控制NULL不会被统计,空字符串&quot;&quot;会被统计
        3、统计蜀国英雄中攻击值 &gt;200 的英雄个数
            select count(*) from sanguo where country=&quot;蜀国&quot;;
5、group by(分组)
    1、作用 ：给查询结果进行分组
    2、用法 ：group by 字段名
    3、示例
        1、计算一下每个国家的平均攻击力
            select country,avg(gongji) from sanguo
            group by country;
            1、分组    2、聚合                3、去重
                蜀国
                蜀国      蜀国平均值             蜀国
                蜀国
                魏国      魏国平均值             魏国
                魏国
                吴国            吴国平均值             吴国
        2、查找所有国家中 英雄数量最多的前2名国家的 国家名称和英雄数量
            select country,count(*) as number from sanguo
            group by country
            order by number desc
            limit 2;
    4、注意
        1、group by后的字段名必须要为select之后的字段名,如果查询字段和group by之后的字段不一致,则必须要对该字段进行聚合处理(聚合函数)
6、having
    1、作用 ：对查询的结果进行进一步的筛选
    2、示例
        1、找出平均攻击力 &gt;105 的国家的前2名,显示国家名和平均攻击力
            select country,avg(gongji) from sanguo
            group by country
            having avg(gongji) &gt; 105
            order by avg(gongji) desc
            limit 2;
    3、注意
        1、having语句通常与group by语句联合使用,用来过滤由group by语句返回的结果集
        2、where只能操作表中实际存在的字段(desc 表名;),having操作的是由聚合函数生成的显示列
7、distinct(不显示字段的重复值)
    1、用法
        select distinct 字段名1,字段名2... from 表名;
    2、示例
        1、统计sanguo表中一共有多少个国家
            select distinct country from sanguo;
        2、计算蜀国一共有多少个英雄
            select count(distinct id) as number from sanguo;
    3、注意
        1、distinct处理的是distinct 和 from 之间的所有字段,所有字段的值必须全部相同才能去重
8、查询表记录时做数学运算    
    1、运算符
        + - * / %
    2、示例
        1、查询时显示所有英雄攻击力翻倍
            select id,name,gongji*2 as new_gj,country from sanguo;
</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><pre><code>1、作用
    为了限制无效的数据插入到数据表中
2、约束分类
    1、默认约束(default)
        1、作用 ：插入记录时,不给该字段赋值,使用默认值
        2、格式 ：字段名 数据类型 default 值
    2、非空约束(not null)
        1、作用 ：不允许该字段的值有NULL记录
        2、格式 ：字段名 数据类型 not null

        ##可连用：字段名 数据类型 not null default 值
</code></pre><blockquote>
<h1 id="MySQL-第三部分"><a href="#MySQL-第三部分" class="headerlink" title="MySQL-第三部分"></a>MySQL-第三部分</h1></blockquote>
<h2 id="索引-index"><a href="#索引-index" class="headerlink" title="索引(index)"></a>索引(index)</h2><ul>
<li>定义<br>  对数据库中表的一列或者多列的值进行排序的一种结构(MySQL中索引用BTREE方式)</li>
<li>优点<br>  可以加快数据的检索速度</li>
<li>缺点<br>  1、当对表中的数据进行增加、删除和修改的时候,索引需要动态维护,降低了数据的维护速度<br>  2、索引需要占用物理空间</li>
<li>索引示例<br>  1、开启运行时间检测<pre><code>show variables like &quot;%pro%&quot;;
set profiling=1;
</code></pre>  2、执行查询语句<pre><code>select name from t1 where name=&quot;lucy1009999&quot;;
</code></pre>  3、查看执行时间<pre><code>show profiles;
</code></pre>  4、在name字段创建索引<pre><code>create index index_name on t1(name);
</code></pre>  5、执行查询语句<pre><code>select name from t1 where name=&quot;lucy1009998&quot;;
</code></pre>  6、查看执行时间<pre><code>show profiles;
</code></pre></li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul>
<li>1、普通索引(index)<br>  1、使用规则<pre><code>1、一张表中可以有多个index字段
2、字段的值可以重复,且可以为NULL
3、经常把做查询条件的字段设置为index字段
4、index字段的key标志为 MUL
</code></pre>  2、创建index<pre><code>1、创建表
    ... index(字段名),index(字段名));
2、已有表
    create index 索引名 on 表名(字段名);
</code></pre>  3、查看索引<pre><code>1、desc 表名;
2、show index from 表名;
</code></pre>  4、删除index<pre><code>drop index 索引名 on 表名;
    ## 删除index只能一个一个删
</code></pre></li>
</ul>
<ul>
<li>2、唯一索引(unique)<br>  1、使用规则<pre><code>1、一个表中可以有多个unique字段
2、对应字段的值不允许重复,但可以为NULL
3、key标志：UNI
</code></pre>  2、创建<pre><code>1、创建表
    ... unique(字段名),unique(字段名));
    ... unique(phnumber),unique(cardnumber));
2、已有表
    create unique index 索引名 on 表名(字段名);
3、查看/删除(同index)
    drop index 索引名 on 表名;
</code></pre></li>
</ul>
<ul>
<li>3、主键索引(primary key)<br>   &amp;&amp;<br>  自增长属性(auto_increment)配合主键一起使用<br>  1、使用规则<pre><code>1、一个表中只能有一个主键字段
2、对应字段值不允许重复,且不能为NULL
3、key标志：PRI
4、把表中能够唯一标识一条记录的字段设置为主键,通常把记录编号的字段设置为主键
</code></pre>  2、创建<pre><code>1、创建表
    ... id int primary key auto_increment,
    ... ...)[auto_increment=10000];
    ... id int auto_increment,
    ... primary key(id))[auto_increment=1000];
2、在已有表中创建
    alter table 表名 add primary key(字段名);
3、删除主键
    1、删除auto_increment属性
        alter table 表名 modify id int;
    2、删除主键
        alter table 表名 drop primary key;
4、在已有表中添加自增长属性并指定起始值
    1、添加自增长属性
        alter table 表名 modify id int auto_increment;
    2、指定起始值
        alter table 表名 auto_increment=值;
</code></pre></li>
</ul>
<ul>
<li><p>4、外键索引(foreign key)<br>  1、定义</p>
<pre><code>让当前表的字段值在另一个表的范围内选择
</code></pre><p>  2、语法格式</p>
<pre><code>foreign key(参考字段名)
references 被参考表名(被参考字段名)
on delete 级联动作
on update 级联动作
</code></pre><p>  3、示例</p>
<pre><code>表1：缴费信息表(财务)
    学号    姓名        班级    金额
    1        唐伯虎    二班    200
    2        点秋香    二班    300
    3        祝枝山    二班    500

表2：班级信息表(班主任)
    学号    姓名        金额
    1        唐伯虎    200
    2        点秋香    300
表1：
    create table jftab(
    id int primary key,
    name varchar(20),
    class varchar(7),
    money int)character set utf8;
    insert into jftab values
    (1,&quot;唐伯虎&quot;,&quot;AID04&quot;,200),
    (2,&quot;点秋香&quot;,&quot;AID04&quot;,300),
    (3,&quot;祝枝山&quot;,&quot;AID04&quot;,500);
表2：
    create table bjtab(
    stu_id int,
    name varchar(20),
    money int,
    foreign key(stu_id) references jftab(id) on delete cascade on update cascade
    )character set utf8;
    insert into bjtab values
    (1,&quot;唐伯虎&quot;,200),
    (2,&quot;点秋香&quot;,300);
</code></pre><p>  4、级联动作</p>
<pre><code>1、cascade ：数据级联更新
    当主表删除记录或更改被参考字段值时,从表级联更新
2、restrict(默认)
    当主表删除记录或更改被参考字段值时,从表中有相关联记录则不允许主表操作
3、set null
    当主表删除记录或更改被参考字段值时,从表中相关联记录的字段值设置为 NULL
4、no action
    同 restrict,都是立即检查外键限制
</code></pre><p>  5、删除外键限制</p>
<pre><code>alter table 表名 drop foreign key 外键名;
外键名查看方式：show create table 表名;
</code></pre><p>  6、在已有表中添加外键限制</p>
<pre><code>alter table 表名 add
foreign key(..) references 表名(字段名) 
on delete 级联动作
on update 级联动作
</code></pre><p>  7、使用规则</p>
<pre><code>1、两张表参考字段和被参考字段数据类型要一致
2、被参考字段必须为key的一种,通常primary key
</code></pre></li>
</ul>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><ul>
<li>作用 ：把文件系统的内容导入到数据库中</li>
<li>语法格式<br>  load data infile “文件名”<br>  into table 表名<br>  fields terminated by “分隔符”<br>  lines terminated by “\n”</li>
<li>示例<br>  1、把 /ect/passwd 文件中的内容导入到 db3下的userinfo表<pre><code>tarena  :  x  :  1000  :  1000  :
用户名        密码        uid            gid
tarena,,,  :  /home/tarena  :  /bin/bash
用户描述            主目录           登录权限
</code></pre></li>
<li><p>操作步骤<br>  1、在数据库中创建对应的表</p>
<pre><code>create table userinfo(
username varchar(20),
password char(10),
uid int,
gid int,
comment varchar(50),
homedir varchar(50),
shell varchar(50)
)character set utf8;
</code></pre><p>  2、把要导入的文件拷贝到数据库搜索路径中</p>
<pre><code>1、查看数据库搜索路径
    show variables like &quot;secure_file_priv&quot;;
2、sudo cp /etc/passwd /var/lib/mysql-files/
</code></pre><p>  3、执行数据导入语句</p>
<pre><code>load data infile &quot;/var/lib/mysql-files/passwd&quot;
into table userinfo
fields terminated by &quot;:&quot;
lines terminated by &quot;\n&quot;;
</code></pre></li>
<li><p>练习</p>
<p>  将AID1709.csv文件导入到 aid1709 表中</p>
<p>  1、创建表</p>
<pre><code>create table aid1709(
id int,
name varchar(20),
score float(5,2),
phone bigint,
class char(7)
)character set utf8;
</code></pre><p>  2、拷贝文件</p>
<pre><code>$ : sudo cp ~/AID1709.csv /var/lib/mysql-files/
</code></pre><p>  3、执行数据导入语句</p>
<pre><code>load data infile &quot;/var/lib/mysql-files/AID1709.csv&quot;
into table aid1709
fields terminated by &quot;,&quot;
lines terminated by &quot;\n&quot;;
</code></pre></li>
</ul>
<h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><ul>
<li>作用<br>  将数据库中表记录保存到系统文件里</li>
<li>语法格式<br>  select … from 表名<br>  into outfile “文件名”<br>  fields terminated “分隔符”<br>  lines terminated by “\n”</li>
<li>示例<br>  1、把userinfo表中的用户名、密码和uid号三个字段的值给导出来<pre><code>-&gt; select username,password,uid from userinfo
-&gt; into outfile &quot;/var/lib/mysql-files/user1.txt&quot;
-&gt; fields terminated by &quot;   &quot;
-&gt; lines terminated by &quot;\n&quot;;
</code></pre>  2、把 mysql库下的user表中 user、host的值导出来,user.csv<pre><code>-&gt; select user,host from mysql.user
-&gt; into outfile &quot;/var/lib/mysql-files/user.csv&quot;
-&gt; fields terminated by &quot;,&quot;
-&gt; lines terminated by &quot;\n&quot;;
</code></pre></li>
<li>注意<br>  1、导出的内容由SQL查询语句决定<br>  2、执行导出命令时路径必须指定对应的数据库目录下<br>  chmod 777 文件名<br>  chmod +rw 文件名</li>
</ul>
<h2 id="表的复制"><a href="#表的复制" class="headerlink" title="表的复制"></a>表的复制</h2><p>表的重命名：alter table 表名 rename 新表名;</p>
<ul>
<li>复制语法格式<br>  create table 表名 select … from 表名 …;</li>
<li>示例<br>  1、复制 aid1709 表的全部记录和字段,aid17092<pre><code>create table aid17092 select * from aid1709;
</code></pre>  2、复制 aid1709 表中成绩低于65分的学生到表next<pre><code>create table next select * from aid1709 where socre&lt;65;
</code></pre></li>
<li>只复制表结构<pre><code>create table 表名 select * from 表名 where false;
</code></pre></li>
</ul>
<h2 id="嵌套查询-子查询"><a href="#嵌套查询-子查询" class="headerlink" title="嵌套查询(子查询)"></a>嵌套查询(子查询)</h2><ul>
<li>定义 ：把内层的查询结果作为外层查询的条件</li>
<li>语法<br>  SQL查询语句 where 条件(SQL查询语句)</li>
<li>示例<br>  1、把uid的值小于这个平均值的用户名和uid号显示出来<pre><code>select username,uid from userinfo 
where uid&lt;(select avg(uid) from userinfo);
</code></pre>  2、找出每个国家攻击力最高的英雄的名字和攻击值<pre><code>-&gt; select name,gongji from sanguo
-&gt; where gongji in(
-&gt; select max(gongji) from sanguo group by country);
</code></pre></li>
</ul>
<blockquote>
<h1 id="MySQL-第四部分"><a href="#MySQL-第四部分" class="headerlink" title="MySQL-第四部分"></a>MySQL-第四部分</h1></blockquote>
<h2 id="1、多表查询"><a href="#1、多表查询" class="headerlink" title="1、多表查询"></a>1、多表查询</h2><p>语法格式：<br>    select 字段名列表 from 表名列表 where 条件;</p>
<ul>
<li>显示省市详细信息<br>  select sheng.s_name,city.c_name from sheng,city where sheng.s_id=city.cfather_id;</li>
<li>显示省市县详细信息<br>  select sheng.s_name,city.c_name,xian.x_name from  sheng,city,xian  where sheng.s_id=city.cfather_id and city.c_id=xian.xfather_id;</li>
</ul>
<h2 id="2、连接查询"><a href="#2、连接查询" class="headerlink" title="2、连接查询"></a>2、连接查询</h2><h3 id="1、内连接-只有在满足连接条件情况才会将指定字段选出来"><a href="#1、内连接-只有在满足连接条件情况才会将指定字段选出来" class="headerlink" title="1、内连接 - 只有在满足连接条件情况才会将指定字段选出来"></a>1、内连接 - 只有在满足连接条件情况才会将指定字段选出来</h3><pre><code>1、语法格式
    select 字段名 from 表1 
    inner join 表2 on 条件 
    inner join 表3 on 条件;
2、示例
    1、显示省和市详细信息
        select sheng.s_name,city.c_name from sheng
        inner join city
        on sheng.s_id=city.cfather_id;
    2、显示省、市、县的详细信息
     select sheng.s_name,city.c_name,xian.x_name 
     from sheng 
     inner join city
     on sheng.s_id=city.cfather_id
     inner join xian
     on city.c_id=xian.xfather_id;
</code></pre><h3 id="2、外连接-将整个表合并然后进行查询"><a href="#2、外连接-将整个表合并然后进行查询" class="headerlink" title="2、外连接 - 将整个表合并然后进行查询"></a>2、外连接 - 将整个表合并然后进行查询</h3><pre><code>1、左连接
    1、定义：以左表为主显示查询结果
    2、语法格式：
        select 字段名列表 from 表1 
        left join 表2 on 条件
        left join 表3 on 条件;
    3、示例
        1、显示省、市详细信息
        select sheng.s_name,city.c_name from sheng
        left join city
        on sheng.s_id=city.cfather_id;
        2、显示省、市、县详细信息,要求所有的市全部显示
    select sheng.s_name,city.c_name,xian.x_name
    from sheng
    right join city 
    on sheng.s_id=city.cfather_id
    left join xian
    on city.c_id=xian.xfather_id;
2、右连接
    用法同左连接,以右表为主显示查询结果
</code></pre><h2 id="3、数据备份-mysqldump-在Linux终端操作"><a href="#3、数据备份-mysqldump-在Linux终端操作" class="headerlink" title="3、数据备份(mysqldump,在Linux终端操作)"></a>3、数据备份(mysqldump,在Linux终端操作)</h2><pre><code>1、命令格式
    mysqldump -u用户名 -p 源库名 &gt; 路径/***.sql
2、示例
    1、备份db4库
        mysqldump -uroot -p db4 &gt; ~/mydata/db4.sql
3、源库名的表示方式
    --all-databases        备份所有库
    库名                            备份单个库
    -B 库1 库2 ...        备份多个库
    库名 表1 表2 ...    备份指定库的指定表
4、练习
    1、备份所有库all.sql,放到mydata目录中
        mysqldump -uroot -p --all-databases &gt; all.sql
    2、备份db4库中的sheng、city和xian三张表为db4scx.sql
        mysqldump -uroot -p db4 sheng city xian &gt; db4scx.sql
</code></pre><h2 id="4、数据恢复"><a href="#4、数据恢复" class="headerlink" title="4、数据恢复"></a>4、数据恢复</h2><pre><code>1、命令格式
    mysql -u用户名 -p 目标库名 &lt; 路径/***.sql
2、恢复db4库
    1、先创建空库
        create database db4 character set utf8;
    2、恢复
        mysql -uroot -p db4 &lt; db4.sql
3、从所有库的备份中恢复某一个库(--one-database)
    mysql -u用户名 -p --one-database 目标库名 &lt; all.sql
4、(1).在db4.sheng新增一条记录
     (2).在db4库新创建一张表 t88
5、注意
    1、恢复库时如果恢复到原库会将表中数据覆盖,新增的表不会删除
    2、数据恢复时如果要恢复的库不存在,则先要创建空库
</code></pre><h2 id="5、事务和事务回滚"><a href="#5、事务和事务回滚" class="headerlink" title="5、事务和事务回滚"></a>5、事务和事务回滚</h2><pre><code>1、定义 ：一件事从开始发生到结束的整个过程
2、属性
    1、原子性
    2、一致性
    3、隔离性
    4、持久性
3、事务和事务回滚的应用
    1、事务应用
        1、开启事务
            mysql&gt; begin;
            mysql&gt; ...一条或者多条sql命令
                ##此时autocommit被禁用
        2、终止事务
            mysql&gt; commit;
            mysql&gt; rollback;
    2、注意
        事务回滚只针对于表记录的操作：增、删、改有效,对创建库、表的操作无效
4、案例
    1、背景
        你：建行卡
        你朋友：工商卡
        你在建行自动取款机上给你朋友工商卡转5000元
    2、过程
        表1：CCB
            create table CCB(
            name char(15),
            money int
            );
            insert into CCB values(&quot;Zhuanqian&quot;,10000);
        表2：ICBC
            create table ICBC(
            name char(15),
            money int
            );
            insert into ICBC values(&quot;Shouqian&quot;,4000);
    3、
        mysql&gt; begin;
        mysql&gt; update CCB set money=5000 where name
        mysql&gt; update ICBC set money=9000 where name
        mysql&gt; commit; 转账成功
        mysql&gt; rollback; 转账失败
</code></pre><h2 id="6、存储引擎-处理表的处理器"><a href="#6、存储引擎-处理表的处理器" class="headerlink" title="6、存储引擎(处理表的处理器)"></a>6、存储引擎(处理表的处理器)</h2><pre><code>1、基本操作
    1、查看所有的存储引擎
        show engines;
    2、查看已有表的存储引擎
        show create table 表名;
        ## engine=innodb
    3、创建表时指定存储引擎
        create table 表名(...)engine=myisam;
    4、工作中常用存储引擎
        InnoDB myisam
    [mysqld]
    defaut-storage-engine=myisam
2、常用存储引擎的特点
    1、innodb特点
        1、共享表空间
            表名.frm  表结构
            表名.ibd  表记录&amp;索引信息
        2、支持行级锁
    2、myisam特点
        1、独享表空间
            表名.frm  表结构
            表名.myd  表记录
            表名.myi  索引文件
        2、支持表级锁
3、锁
    1、加锁的目的
        解决客户端并发访问的冲突问题
    2、锁的分类
        1、锁类型
            读锁(select)共享锁：加读锁后不能更改表中内容,但可以进行查询
            写锁 互斥锁 排他锁
        2、锁粒度
            表级锁
            行级锁
4、如何决定表使用哪种存储引擎
    1、执行查询操作多的表使用myisam(使用innodb浪费资源)
    2、执行写操作多的表使用innodb存储引擎
</code></pre><h2 id="7、MySQL调优"><a href="#7、MySQL调优" class="headerlink" title="7、MySQL调优"></a>7、MySQL调优</h2><pre><code>1、选择合适的存储引擎
    查询多--&gt;myisam
    写操作多--&gt;innodb
2、SQL语句调优(尽量避免全表扫描)
    1、在select、where、order by常涉及到的字段上建立索引
    2、where子句中不适用 !=,否则导致全表扫描
    3、尽量避免NULL值判断,否则导致全表扫描
        示例：
        优化前：
            select id from t1 where number is null;
        优化后：
            可以在number设置默认值0,确保number无NULL值,查询如下：
            select id from t1 where number=0;
    4、尽量避免用 or 来连接条件,否则全表扫描
        优化前：
            select id from t1 where id=10 or id=20;
        优化后：
            select id from t1 where id=10
            union all
            select id from t1 where id=20;
    5、模糊查询尽量避免前置 % ,否则全表扫描
        select id from t1 where name like &quot;c%&quot;;
    6、尽量避免 in 和 not in,否则全表扫描
        示例：
            select id from t1 where number in(1,2,3);
            对于连续的值,尽量用between and
    7、尽量避免使用select * from t1;
        要用具体的字段名代替*,不要返回用不到的任何字段
</code></pre><h2 id="8、与Python交互"><a href="#8、与Python交互" class="headerlink" title="8、与Python交互"></a>8、与Python交互</h2><pre><code>1、交互类型
    1、python3
        pymysql $ sudo pip3 install pymysql
    2、python2
        MySQLdb $ sudo pip install mysql-python
2、connection对象
    1、创建与数据库连接对象(调用connect()方法)
        conn = pymysql.connect(参数列表)
        参数列表：
            1. host ：主机地址,本机:&apos;localhost&apos;
            2. port ：mysql端口,默认3306
            3. database        ：数据库名
            4. password ：连接密码
            5. charset ：编码方式,推荐使用utf8
            6. user ：用户
        示例：
            conn = pymysql.connect(host=&quot;localhost&quot;,
            user=&quot;root&quot;,password=&quot;123456&quot;,
            database=&quot;db4&quot;,charset=&quot;utf8&quot;)
    2、连接对象(如:conn)的方法
        1、close() 关闭连接
        2、commit() 提交到数据库执行
        3、rollback() 事务回滚操作
        4、cursor() 创建游标对象,用于执行SQL语句获得结果
3、游标对象(cursor对象)
    1、作用 ：执行sql语句
    2、创建游标对象：调用连接对象的cursor()方法
        示例：cursor1 = conn.cursor()
    3、游标对象的方法
        1、execute(operation[,参数]) 执行sql语句
        2、close() 关闭游标对象
        3、fetchone() 获取结果集的第一条记录,返回一个元组
        4、fetchmany(n) 获取结果计的n条记录,返回一个大元组
        5、fetchall() 获取结果集的所有记录,返回一个大元组
4、总结：pymysql使用流程
    1、建立数据库连接 conn
    2、创建游标对象 cursor1 = conn.cursor()
    3、利用游标对象的方法操作数据库
        cursor1.execute(&quot;sql语句&quot;)
    4、提交 conn.commit()
    5、关闭游标 cursor1.close()
    6、关闭数据库连接 conn.close()
</code></pre><p>9、workbench<br>    可视化软件</p>
<h2 id="10、ER模型"><a href="#10、ER模型" class="headerlink" title="10、ER模型"></a>10、ER模型</h2><pre><code>Entry - Relation
1、关系
    1、分类
        1、一对一关系(1:1) : 班级和班长
        2、一对多关系(1:n) : 公司和职工
        3、多对多关系(m:n) : 学生和课程
2、ER图的绘制
    1、矩形框代表实体,菱形框代表关系,椭圆形代表属性
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/mongodb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/mongodb/" itemprop="url">mongodb</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-07T10:31:00+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6,659 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  27 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>MongoDB （芒果数据库）</p>
<h2 id="数据存储阶段"><a href="#数据存储阶段" class="headerlink" title="数据存储阶段"></a>数据存储阶段</h2><ul>
<li><h2 id="文件管理阶段-（-txt-doc-xls）"><a href="#文件管理阶段-（-txt-doc-xls）" class="headerlink" title="文件管理阶段 （.txt  .doc  .xls）"></a>文件管理阶段 （.txt  .doc  .xls）</h2></li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>数据可以长期保存</li>
<li>可以存储大量的数据</li>
<li>使用简单<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li>
<li>数据的一致性差</li>
<li>数据的查找修改不方便</li>
<li><p>数据的冗余性大</p>
</li>
<li><h2 id="数据库存储阶段"><a href="#数据库存储阶段" class="headerlink" title="数据库存储阶段"></a>数据库存储阶段</h2></li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>数据组织结构化，降低了冗余</li>
<li>提高了增删改查的效率</li>
<li>方便扩展</li>
<li>方便程序调用，做自动化的处理</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>数据库使用往往需要特定的语句或者命令进行操作，相对比较复杂</li>
</ul>
<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><ul>
<li><p>数据 ：能够输入到计算机中并被识别处理的信息的集合</p>
</li>
<li><p>数据结构：研究一个数据集合中，数据之间关系的学科</p>
</li>
<li><p>数据库：按照数据结构，存储管理数据的仓库。数据库是在数据库管理系统管理和控制下在一定介质上的数据集合。</p>
</li>
<li><p>数据库管理系统：数据库管理软件，用于建立维护数据库</p>
</li>
<li><p>数据库系统：由数据库和数据库管理系统等开发工具组成的集合</p>
</li>
</ul>
<hr>
<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>采用关系模型来组织数据结构的数据库（二维表）</p>
<p>Oracle   DB2   SQLServer    MySQL   SqLite </p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>容易理解，逻辑类似常见表格</li>
<li>使用方便，都使用sql语句，sql语句非常成熟</li>
<li>数据的一致性高，冗余低，完整性好</li>
<li>技术成熟，可以使用外部链接等复杂的操作</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>每次都需要sql语句的解析，消耗较大</li>
<li>不能很好满足并发需求，特别是海量数据的爆发，关系型数据库普遍读写能力不足</li>
<li>关系型数据库内部每一步都要加锁的操作，以保证操作的原子性，增加了数据库负担</li>
<li>数据的一致性有时会导致大量的空间浪费</li>
</ul>
<h2 id="非关系型数据库-（NoSql-–-gt-not-only-sql）"><a href="#非关系型数据库-（NoSql-–-gt-not-only-sql）" class="headerlink" title="非关系型数据库 （NoSql –&gt; not only sql）"></a>非关系型数据库 （NoSql –&gt; not only sql）</h2><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>高并发，读写能力强</li>
<li>普遍比关系型数据库容易扩展</li>
<li>弱化了数据结构，降低了数据的一致性</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>通用性差，没有sql一样的一致化的操作</li>
<li>操作灵活，容易混乱</li>
<li>没有join等操作，有的数据库不支持关系型数据库中类似事务等操作。版本更新快</li>
</ul>
<h2 id="Nosql的使用情况"><a href="#Nosql的使用情况" class="headerlink" title="Nosql的使用情况"></a>Nosql的使用情况</h2><ol>
<li>数据一致性要求低</li>
<li>数据库处理海量并发存储</li>
<li>数据库大小不容易估算，需要分布扩展</li>
<li>给定的数据比较容易建立Nosql模型</li>
</ol>
<h2 id="Nosql的分类"><a href="#Nosql的分类" class="headerlink" title="Nosql的分类"></a>Nosql的分类</h2><ul>
<li>键值型数据库 ： Redis  </li>
<li>列存储数据库  </li>
<li>文档型数据库 ： MongoDB  </li>
<li>图形数据库</li>
</ul>
<h2 id="MongoDB数据库-（非关系型数据库—》-文档型数据库）"><a href="#MongoDB数据库-（非关系型数据库—》-文档型数据库）" class="headerlink" title="MongoDB数据库 （非关系型数据库—》 文档型数据库）"></a>MongoDB数据库 （非关系型数据库—》 文档型数据库）</h2><p>1.由c++编写的数据库管理系统<br>2.支持丰富的增删改查操作<br>3.支持丰富的数据类型<br>4.支持众多的编程语言接口（python PHP c++  c#）<br>5.使用方便，便于部署。在非关系数据库中属于比较成熟   的数据库</p>
<h2 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h2><ul>
<li>自动安装<br><code>sudo apt-get install mongodb</code></li>
</ul>
<ul>
<li><p>用来查看软件位置<br><code>whereis  软件名称</code></p>
</li>
<li><p>默认安装位置： /var/lib/mongodb</p>
</li>
<li>配置文件位置： /etc/mongodb.conf</li>
<li>命令集: /usr/bin  /usr/local/bin</li>
</ul>
<ul>
<li>手动安装</li>
</ul>
<ol>
<li><p>下载MongoDB （开源）<br><a href="http://www.mongodb.com" target="_blank" rel="noopener">www.mongodb.com</a> —&gt;get mongodb–&gt;community server<br>选择想要的版本下载</p>
</li>
<li><p>选择合适的位置解压 （/usr/local  /opt）<br>tar 解压后得到Mongodb文件夹</p>
</li>
<li><p>将MongoDB文件夹中的bin文件夹变为环境变量<br>PATH=$PATH:/opt/mongo…./bin<br>export PATH<br>将以上两句写入 /etc/rc.local</p>
</li>
<li><p>重启系统</p>
</li>
</ol>
<h2 id="MongoDB命令"><a href="#MongoDB命令" class="headerlink" title="MongoDB命令"></a>MongoDB命令</h2><ol>
<li><p>设置数据库的存储位置<br>mongod  –dbpath  目录<br>e.g.mongod –dbpath  dbs</p>
</li>
<li><p>设置数据库端口<br>mongod  –port   8080<br>*如果不设置默认 27017</p>
</li>
<li><p><code>mongo</code><br>进入mongo shell界面 ：mongodb的交互界面，用来通过mongo语句操作mongodb数据库<br>退出mongo shell ： <code>quit()</code>  或者 ctrl + c </p>
</li>
<li><p>组织结构 ： 键值对–&gt; 文档 —&gt; 集合 –&gt;数据库</p>
</li>
</ol>
<h4 id="mysql存放情况"><a href="#mysql存放情况" class="headerlink" title="mysql存放情况"></a>mysql存放情况</h4><table>
<thead>
<tr>
<th>ID</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Lily</td>
<td>17</td>
</tr>
<tr>
<td>2</td>
<td>Lucy</td>
<td>18</td>
</tr>
</tbody>
</table>
<h4 id="mongodb存放情况"><a href="#mongodb存放情况" class="headerlink" title="mongodb存放情况"></a>mongodb存放情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;:ObjectId(&quot;agfsdfglk989q98&quot;),</span><br><span class="line">	&quot;name&quot;:&quot;Lily&quot;,</span><br><span class="line">	&quot;age&quot;:17</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">	&quot;_id&quot;:ObjectId(&quot;aggfsdfg3989q98&quot;),</span><br><span class="line">	&quot;name&quot;:&quot;Lucy&quot;,</span><br><span class="line">	&quot;age&quot;:18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mysql-和-mongodb-概念比较"><a href="#mysql-和-mongodb-概念比较" class="headerlink" title="mysql 和 mongodb 概念比较"></a>mysql 和 mongodb 概念比较</h3><table>
<thead>
<tr>
<th>mysql</th>
<th>mongodb</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>表/集合</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>字段/域</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>记录/文档</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
</tbody>
</table>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><ul>
<li><p>创建一个名字为stu的数据库<br><code>use databaseName</code><br>e.g.use  stu<br><strong> use 实际上是表示选择使用哪个数据库，如果这个数据库不存在则表示同时创建这个数据库</strong><br><strong> 使用use后数据库不会被马上创建，而是需要写入数据时才会创建</strong></p>
</li>
<li><p>查看当前系统下数据库<br><code>show  dbs</code></p>
</li>
<li><p>系统数据库：<br>admin ： 存放用户及其权限<br>local ： 存储本地数据<br>config ： 存储分片信息</p>
</li>
<li><p>数据库的命名规则：<br>1.使用UTF-8字符<br>2.不能含有空格，点  /  \  ‘\0’字符<br>3.长度不能超过64字节<br>4.不能和系统数据库重名<br>5.习惯使用小写字母，表达数据库功能</p>
</li>
</ul>
<p><strong> db：mongo系统全局变量，代表你当前正在使用的数据库</strong></p>
<p><strong> 当不用use选择任何数据库时，db表示test。此时插入数据则创建test数据库</strong></p>
<h2 id="数据库的备份和恢复"><a href="#数据库的备份和恢复" class="headerlink" title="数据库的备份和恢复"></a>数据库的备份和恢复</h2><ul>
<li><p>备份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongodump -h dbhost  -d  dbname  -o  dbdir</span><br><span class="line">e.g. mongodump -h 127.0.0.1 -d stu  -o  bak</span><br><span class="line">将127.0.0.1主机上stu数据库备份入bak文件夹</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h  dbhost:port  -d dbname path</span><br><span class="line">e.g. mongorestore -h 127.0.0.1:27017 -d student bak/stu</span><br><span class="line">将bak文件夹下备份的stu数据库恢复到 本机的student数据库中。student不存在则会自动创建</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数据库的监测"><a href="#数据库的监测" class="headerlink" title="数据库的监测"></a>数据库的监测</h2><ul>
<li><p><code>mongostat</code><br>insert query update delete ： 每秒增删改查的次数<br>command  每秒运行命令次数<br>flushes  每秒和磁盘交互次数<br>vsize  使用虚拟内存</p>
</li>
<li><p><code>mongotop</code><br>监测每个数据库的读写时长</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>ns</th>
<th>total</th>
<th>read</th>
<th>write</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据集合</td>
<td>总时长</td>
<td>读时长</td>
<td>写时长</td>
</tr>
</tbody>
</table>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p><code>db.dropDatabase()</code><br>删除db当前所代表的数据库</p>
<h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p><code>db.createCollection(collection_name)</code><br>e.g.  db.createCollection(‘class2’)<br>创建一个集合名字为class2</p>
<hr>
<p>当向一个集合中插入数据的时候，如果这个集合不存在则会自动创建<br><code>db.collectionName.insert(...)</code><br>e.g.  db.class3.insert({name:’Lucy’})<br>      如果class3不存在则自动创建这个集合</p>
<hr>
<p>集合命名规则：<br>1.合法的utf-8字符串<br>2.不能有’\0’<br>3.不能以system.开头 因为这是系统的保留前缀<br>4.不能和关键字重复</p>
<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p><code>db.collectionName.drop()</code><br>e.g. db.class3.drop()<br>删除class3这个集合</p>
<h2 id="集合重命名"><a href="#集合重命名" class="headerlink" title="集合重命名"></a>集合重命名</h2><p><code>db.collectionName.renameCollection(&quot;new_name&quot;)</code><br>e.g.   db.class2.renameCollection(“class0”)<br>将class2 重命名为class0 </p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>mongodb中数据的组织形式 —&gt;文档<br>mongo文档： 以键值对的形式组成的类似于字典的数据描述形式</p>
<h2 id="键-：即文档的域"><a href="#键-：即文档的域" class="headerlink" title="键 ：即文档的域"></a>键 ：即文档的域</h2><ul>
<li>键的命名规则</li>
</ul>
<ol>
<li>utf-8格式字符串</li>
<li>不适用‘\0’ 通常不会适用.和$</li>
<li>一个文档中键不可以重复</li>
</ol>
<p><strong> 文档中的键值对是有序的</strong><br><strong> mongodb严格的区分大小写</strong></p>
<ul>
<li>值 ：即文档存储的数据,支持bson类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>整形</td>
<td>整数</td>
</tr>
<tr>
<td>布尔类型</td>
<td>true  false</td>
</tr>
<tr>
<td>浮点型</td>
<td>小数</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Timestamp</td>
<td>时间戳</td>
</tr>
<tr>
<td>Date</td>
<td>时间日期</td>
</tr>
<tr>
<td>Object</td>
<td>内部文档</td>
</tr>
<tr>
<td>Null</td>
<td>空值 null</td>
</tr>
<tr>
<td>Symbol</td>
<td>特殊字符</td>
</tr>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>Binary data</td>
<td>二进制字符串</td>
</tr>
<tr>
<td>code</td>
<td>代码</td>
</tr>
<tr>
<td>regex</td>
<td>正则表达式</td>
</tr>
<tr>
<td>ObjectId</td>
<td>ObjectId字串</td>
</tr>
</tbody>
</table>
<ul>
<li>ObjectId<br>“_id” : ObjectId(“5b28a02c154710728ef6cac2”)<br>_id : 当在mongodb中插入文档时，如果不指定_id则会自动添加这个域。值是一个ObjectId类型数据<br>24位 16进制数 —-&gt;保证_id值的唯一性<br>8位文档创建时间  6位机器id  4位进程id  6位计数器</li>
</ul>
<hr>
<h4 id="集合中的文档"><a href="#集合中的文档" class="headerlink" title="集合中的文档"></a>集合中的文档</h4><ol>
<li>集合中的文档不一定都有相同的域</li>
<li>集合中文档域的个数也不一定相同</li>
</ol>
<h4 id="集合的设计"><a href="#集合的设计" class="headerlink" title="集合的设计"></a>集合的设计</h4><ol>
<li>集合中的文档尽可能描述同一类数据</li>
<li>同一类数据不要过多的分散集合存放</li>
<li>集合中文档的层次不要包含太多</li>
</ol>
<h2 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h2><ul>
<li>插入单个文档<br><code>db.collectionName.insert()</code></li>
</ul>
<p>e.g. db.class1.insert({name:’Lucy’,age:18})</p>
<p>1 <strong>插入操作的键可以不加引号</strong><br>2 <strong>查看插入结果  db.class1.find()</strong><br>3 <strong>_id 为系统自动添加主键，如果自己写_id则会使用自己的值，但是仍然不能重复</strong></p>
<ul>
<li>插入多个文档<br><code>db.collectionName.insert([{},{},{}])</code><br>e.g. db.class0.insert([{name:’阿花’,age:28},{name:’阿彪’,age:27},{name:’阿宝’,age:’26’}])</li>
</ul>
<ul>
<li>save 插入文档<br>db.collectionName.save()<br>e.g.  db.class0.save({name:’阿荣’,age:29})</li>
</ul>
<p>1 <strong>如果不加_id选项时save和insert相同</strong><br>2 <strong>如果加_id项，则如果此_id值存在则save表示修改该文档内容，如果不存在则正常插入</strong></p>
<h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><ol>
<li>关系型数据库和非关系型数据库有什么区别？</li>
<li>复习mysql增删改查操作</li>
<li>练习mongo数据库的创建删除，集合的创建删除，文档插入</li>
</ol>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="获取集合对象"><a href="#获取集合对象" class="headerlink" title="获取集合对象"></a>获取集合对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.class1</span><br><span class="line">db.getCollection(&quot;class1&quot;)</span><br><span class="line">e.g.  db.getCollection(&quot;class0&quot;).insert(&#123;name:&apos;阿喜&apos;,age:25&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql : select ... from  table where  ....</span><br><span class="line">mongo :  db.collection.find(query,field)</span><br></pre></td></tr></table></figure>
<h2 id="查找所有内容"><a href="#查找所有内容" class="headerlink" title="查找所有内容"></a>查找所有内容</h2><p><code>db.collection.find()</code>  —-&gt; select * from table</p>
<h3 id="find-query-field"><a href="#find-query-field" class="headerlink" title="find(query,field)"></a>find(query,field)</h3><p><strong>功能 ：</strong> 查找数据<br><strong>参数 ：</strong><br>query ： 筛选条件，相当于where子句<br>field ： 选定要展示的域<br><strong>返回值：</strong> 返回查找到的文档</p>
<h4 id="query-：-以键值对的形式给出筛选条件"><a href="#query-：-以键值对的形式给出筛选条件" class="headerlink" title="query ： 以键值对的形式给出筛选条件"></a>query ： 以键值对的形式给出筛选条件</h4><p>e.g. db.class0.find({name:’阿宝’})</p>
<h4 id="field-：以键值对的形式给出要展示（不展示）的域-域名为键，值为1则表示展示，0表示不展示"><a href="#field-：以键值对的形式给出要展示（不展示）的域-域名为键，值为1则表示展示，0表示不展示" class="headerlink" title="field ：以键值对的形式给出要展示（不展示）的域,域名为键，值为1则表示展示，0表示不展示"></a>field ：以键值对的形式给出要展示（不展示）的域,域名为键，值为1则表示展示，0表示不展示</h4><ul>
<li>如果某个域设为0则表示不展示该域，其他域均显示<br>如果某个域设为1则表示展示该域，其他域均不显示</li>
<li>在field显示设置的时候普通域0和1不能同时出现</li>
<li>_id 默认永远显示，除非设置为0</li>
<li>如果不写field参数则表示所有内容都显示<br><code>e.g.   db.class1.find({name:&#39;Abby&#39;},{_id:0,name:1,age:1})</code></li>
</ul>
<h3 id="findOne-query-field"><a href="#findOne-query-field" class="headerlink" title="findOne(query,field)"></a>findOne(query,field)</h3><p><strong>功能 :</strong> 查找符合条件的第一条文档<br><strong>参数 ：</strong> 同find<br><strong>返回值：</strong>返回查找到的文档<br><code>e.g.  db.class1.findOne({age:18},{_id:0})</code></p>
<h2 id="query更多的筛选功能"><a href="#query更多的筛选功能" class="headerlink" title="query更多的筛选功能"></a>query更多的筛选功能</h2><h3 id="操作符：使用-符号注明的一个特殊字串，表达一定的含义。-比如-lt-表示小于"><a href="#操作符：使用-符号注明的一个特殊字串，表达一定的含义。-比如-lt-表示小于" class="headerlink" title="操作符：使用$符号注明的一个特殊字串，表达一定的含义。 比如 $lt 表示小于"></a>操作符：使用$符号注明的一个特殊字串，表达一定的含义。 比如 $lt 表示小于</h3><h4 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$eq</td>
<td>等于</td>
<td>db.class1.find({age:{$eq:18}},{_id:0})</td>
<td><strong>字符串也可以比较大小</strong></td>
</tr>
<tr>
<td>$lt</td>
<td>小于</td>
<td>db.class1.find({age:{$lt:18}},{_id:0})</td>
<td></td>
</tr>
<tr>
<td>$lte</td>
<td>小于等于</td>
<td>db.class0.find({age:{$lte:27}},{_id:0})</td>
<td></td>
</tr>
<tr>
<td>$gt</td>
<td>大于</td>
<td>db.class0.find({age:{$gt:26}},{_id:0})</td>
<td></td>
</tr>
<tr>
<td>$gte</td>
<td>大于等于</td>
<td>db.class0.find({age:{$gte:27}},{_id:0})</td>
<td></td>
</tr>
<tr>
<td>$ne</td>
<td>不等于</td>
<td>db.class0.find({age:{$ne:27}},{_id:0})</td>
<td>如果一个文档不存在某个域，则也认为不等于</td>
</tr>
<tr>
<td>$in</td>
<td>包含</td>
<td>db.class0.find({age:{$in:[25,27,30]}},{_id:0})</td>
<td>年龄包含在25 27 30中的</td>
</tr>
<tr>
<td>$nin</td>
<td>不包含</td>
<td>db.class0.find({age:{$nin:[24,25,26]}},{_id:0})</td>
<td>年龄不包含24，25，26 </td>
</tr>
</tbody>
</table>
<h4 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>表达式 </th>
</tr>
</thead>
<tbody>
<tr>
<td>$and</td>
<td>逻辑与</td>
<td>db.class1.find({$and:[{name:{$lt:’Tom’}},{age:17}]},{_id:0})</td>
</tr>
<tr>
<td>$or</td>
<td>逻辑或</td>
<td>db.class0.find({$or:[{age:{$gt:28}},{age:{$lt:26}}]},{_id:0})</td>
</tr>
<tr>
<td>$not</td>
<td>逻辑非</td>
<td>db.class1.find({age:{$not:{$eq:18}}},{_id:0})</td>
</tr>
<tr>
<td>$nor</td>
<td>既不也不</td>
<td>db.class1.find({$nor:[{age:17},{sex:’m’}]},{_id:0})</td>
</tr>
</tbody>
</table>
<h4 id="条件混合"><a href="#条件混合" class="headerlink" title="条件混合"></a>条件混合</h4><p>（年龄大于27 并且叫阿花） 或者  叫阿喜</p>
<p><code>db.class0.find({$or:[{name:&#39;阿花&#39;,age:{$gt:27}},{name:&#39;阿喜&#39;}]},{_id:0})</code></p>
<h4 id="数组值-1-2-3-4"><a href="#数组值-1-2-3-4" class="headerlink" title="数组值 [1,2,3,4]"></a>数组值 [1,2,3,4]</h4><ul>
<li>数值类型可以混合</li>
<li>是有序的</li>
</ul>
<h4 id="数组查找"><a href="#数组查找" class="headerlink" title="数组查找"></a>数组查找</h4><table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
<th>表达式 </th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td>查看数组中是否包含某一项</td>
<td>db.class2.find({score:{$lt:60}},{_id:0})</td>
</tr>
<tr>
<td>$all</td>
<td>查找数组中同时包含多项的文档</td>
<td>db.class2.find({score:{$all:[65,88]}},{_id:0})</td>
</tr>
<tr>
<td>$size</td>
<td>通过数组中元素个数查找</td>
<td>db.class2.find({score:{$size:4}},{_id:0})</td>
</tr>
<tr>
<td>$slice</td>
<td>显示数组中的前几项</td>
<td>db.class2.find({},{_id:0,score:{$slice:2}})</td>
</tr>
<tr>
<td>$slice</td>
<td>跳过数组中第一项显示后两项</td>
<td>db.class2.find({},{_id:0,score:{$slice:[1,2]}})</td>
</tr>
<tr>
<td>$exists</td>
<td>判断一个域是否存在</td>
<td>db.class1.find({sex:{$exists:true}},{_id:0})</td>
</tr>
<tr>
<td>$mod</td>
<td>查找age除以2余数为1 的文档</td>
<td>db.class2.find({age:{$mod:[2,1]}},{_id:0})</td>
</tr>
<tr>
<td>$type</td>
<td>查找指定数据类型的文档</td>
<td>db.class2.find({age:{$type:1}},{_id:0})</td>
</tr>
</tbody>
</table>
<p><strong>关于$type的类型取值如下</strong></p>
<table>
<thead>
<tr>
<th>类型描述</th>
<th>类型值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Double</td>
<td>1</td>
</tr>
<tr>
<td>String</td>
<td>2</td>
</tr>
<tr>
<td>Object</td>
<td>3</td>
</tr>
<tr>
<td>Array</td>
<td>4</td>
</tr>
<tr>
<td>Binary data</td>
<td>5</td>
</tr>
<tr>
<td>Object id</td>
<td>7</td>
</tr>
<tr>
<td>Boolean</td>
<td>8</td>
</tr>
<tr>
<td>Date</td>
<td>9</td>
</tr>
<tr>
<td>Null</td>
<td>10</td>
</tr>
<tr>
<td>Regular expression</td>
<td>11</td>
</tr>
<tr>
<td>JavaScript code</td>
<td>13</td>
</tr>
<tr>
<td>Symbol</td>
<td>14</td>
</tr>
<tr>
<td>JavaScript code with scope</td>
<td>15</td>
</tr>
<tr>
<td>32-bit integer</td>
<td>16</td>
</tr>
<tr>
<td>Timestamp</td>
<td>17</td>
</tr>
<tr>
<td>64-bit integer</td>
<td>18</td>
</tr>
<tr>
<td>Min key</td>
<td>255</td>
</tr>
<tr>
<td>Max key</td>
<td>127</td>
</tr>
</tbody>
</table>
<h4 id="查找结果相关的函数"><a href="#查找结果相关的函数" class="headerlink" title="查找结果相关的函数"></a>查找结果相关的函数</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>distinct()</td>
<td>查看集合某个域的取值范围</td>
</tr>
<tr>
<td>pretty()</td>
<td>格式化显示查找结果</td>
</tr>
<tr>
<td>limit(n)</td>
<td>显示查找结果的前2条</td>
<td>db.class0.find({},{_id:0}).limit(2)</td>
</tr>
<tr>
<td>skip(n)</td>
<td>显示查找结果跳过前2条</td>
<td>db.class0.find({},{_id:0}).skip(2)</td>
</tr>
<tr>
<td>count()</td>
<td>查找结果计数</td>
<td>db.class0.find({age:{$gt:26}},{_id:0}).count()</td>
</tr>
<tr>
<td>sort({域:1/-1})</td>
<td>对查找结果排序显示</td>
<td>db.class2.find({},{_id:0}).sort({age:1})</td>
</tr>
</tbody>
</table>
<p><strong> sort函数参数1 表示按照升序排列  -1表示降序排列</strong></p>
<h4 id="函数连续使用"><a href="#函数连续使用" class="headerlink" title="函数连续使用"></a>函数连续使用</h4><p>当函数返回的是文档集合时可以连续调用操作函数<br>e.g.  db.class2.find({},{_id:0}).sort({age:1}).limit(3)</p>
<h3 id="文档删除操作"><a href="#文档删除操作" class="headerlink" title="文档删除操作"></a>文档删除操作</h3><p><code>db.collection.remove(query,justOne)</code><br>功能 ： 删除文档<br>参数 ： </p>
<ul>
<li>query  : 筛选要删除的文档 相当于where,用法同查找操作</li>
<li>justOne：布尔值，默认为false 表示删除所有符合条件的文档,如果赋值为true则只删除第一条符合条件文档<br>e.g.  <code>db.class1.remove({sex:{$exists:true}})</code> 删除所有有sex域的文档<br>e.g.  <code>db.class1.remove({age:17},true)</code>删除第一条年龄为17的文档</li>
</ul>
<h3 id="删除集合中所有文档"><a href="#删除集合中所有文档" class="headerlink" title="删除集合中所有文档"></a>删除集合中所有文档</h3><p><code>db.collection.remove({})</code><br>e.g.  db.class0.remove({})  </p>
<p>练习：</p>
<ol>
<li>创建数据库 名字 grade<br>use grade</li>
<li>数据库中创建集合名字 class</li>
<li>集合中插入若干文档，文档格式如下<br>name:’zhang’,age:10,sex:’m’,hobby:[‘a’,’b’]｝<br>hobby 可以是 ： draw sing  dance  basketball  football  pingpong  computer<br>db.class.insert(｛name:’zhang’,age:10,sex:’m’,hobby:[‘a’,’b’]｝)</li>
<li>查找练习</li>
</ol>
<hr>
<p>查看班级所有人信息<br>db.class.find()</p>
<hr>
<p>查看班级中年龄为8岁的学生信息<br>find({age:8})</p>
<hr>
<p>查看年龄大于10岁的学生信息<br>find({age:{$gt:10}})</p>
<hr>
<p>查看年龄在8-11岁之间的学生信息<br>find({age:{$gte:8,$lte:11}})</p>
<hr>
<p>找到年龄为9岁且为男生的学生<br>find({age:9,sex:’m’})</p>
<hr>
<p>找到年龄小于7岁或者大于11岁的学生<br>find({$or:[{age:{$lt:7}},{age:{$gt:11}}]})</p>
<hr>
<p>找到年龄是8岁或者11岁的学生<br>find({age:{$in:[8,11]}})</p>
<hr>
<p>找到有两项兴趣爱好的学生<br>find({hobby:{$size:2}})</p>
<hr>
<p>找到兴趣爱好中有draw的学生<br>find({hobby:’draw’})</p>
<hr>
<p>找到喜欢画画和跳舞的学生<br>find({hobby:{$all:[‘draw’,’dance’]}})</p>
<hr>
<p>统计兴趣有三项的学生人数<br>find({hobby:{$size:3}}).count()</p>
<hr>
<p>找出本班年龄第二大的学生<br>find().sort({age:-1}).skip(1).limit(1)</p>
<hr>
<p>查看学生的兴趣范围<br>db.class.distinct(‘hobby’)</p>
<hr>
<p>找到班级中年龄最大的三个学生<br>find().sort({age:-1}).limit(3)</p>
<ol start="5">
<li>删除所有年龄大于12或者小于6岁的学生<br>db.class.remove({$or:[{age:{$lt:6}},{age:{$gt:12}}]})</li>
</ol>
<hr>
<h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p><code>db.collection.update(query,update,upsert,multi)</code><br><strong>功能：</strong>修改文档<br><strong>参数：</strong></p>
<ul>
<li>query ： 筛选要修改的文档，相当于where子句,用法同查找</li>
<li>update： 将筛选的文档修改什么内容，相当于set。需要配合修改操作符使用</li>
<li>upsert： bool值  默认为false  表示如果query的文档不存在则无法修改,如果设置为true 则表示如果筛选的文档不存在则根据修改内容插入一条文档</li>
<li>multi ： bool值 默认为false 表示如果有多条文档符合筛选条件只修改第一条，如果设置为true则表示修改全部</li>
</ul>
<p>e.g. 将Lucy年龄改为20  <code>db.class1.update({name:&#39;Lucy&#39;},{$set:{age:20}})</code><br>e.g. 如果没有name 为 Lily的文档则插入一条   <code>db.class1.update({name:&#39;Lily&#39;},{$set:{age:20}},true)</code><br>e.g.  如果匹配到的文档有多个，则都进行修改 <code>db.class1.update({age:17},{$set:{age:18}},false,true)</code></p>
<h2 id="修改操作符"><a href="#修改操作符" class="headerlink" title="修改操作符"></a>修改操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$set</td>
<td>修改一个域的值，或者增加一个域</td>
<td>db.class1.update({},{$set:{sex:’w’}},false,true)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>db.class1.update({name:’Abby’},{$set:{age:19,sex:’m’}})</td>
</tr>
<tr>
<td>$unset</td>
<td>删除一个域</td>
<td>db.class1.update({name:’Abby’},{$unset:{sex:0}})</td>
<td></td>
</tr>
<tr>
<td>$rename</td>
<td>修改域名</td>
<td>db.class1.update({},{$rename:{sex:’gender’}},false,true)</td>
<td></td>
</tr>
<tr>
<td>$setOnInsert</td>
<td>如果第三个参数为true 并且插入新的文档，则作为插入补充内容</td>
<td>db.class1.update({name:’Jame’},{$set:{age:19},$setOnInsert:{gender:’m’,’tel’:”12345”}},true)</td>
</tr>
<tr>
<td>$inc</td>
<td>加减修改器</td>
<td>db.class1.update({name:’Abby’},{$inc:{age:1}})</td>
</tr>
<tr>
<td>$mul</td>
<td>乘除法修改器</td>
<td>db.class1.update({name:’Jame’},{$mul:{age:0.5}})</td>
</tr>
<tr>
<td>$min</td>
<td>如果筛选的文档指定的值小于min则不修改</td>
<td>db.class1.update({gender:’w’},{$min:{age:19}},false,true)</td>
</tr>
<tr>
<td>$max</td>
<td>如果筛选的文档指定域的值大于max值则不变</td>
<td>db.class1.update({name:’Jame’},{$max:{age:20}})</td>
</tr>
</tbody>
</table>
<h2 id="数组修改器"><a href="#数组修改器" class="headerlink" title="数组修改器"></a>数组修改器</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$push</td>
<td>向数组中添加一项</td>
<td>db.class2.update({name:’小刚’},{$push:{score:10}})</td>
</tr>
<tr>
<td>$pushAll</td>
<td>向数组中添加多项</td>
<td>db.class2.update({name:’小明’},{$pushAll:{score:[10,5]}})</td>
</tr>
<tr>
<td>$pull</td>
<td>从数组中删除一项</td>
<td>db.class2.update({name:’小红’},{$pull:{score:’78’}})</td>
</tr>
<tr>
<td>$pullAll</td>
<td>从数组中删除多项</td>
<td>db.class2.update({name:’小明’},{$pullAll:{score:[10,5]}})</td>
</tr>
<tr>
<td>$each</td>
<td>对多个值进行逐一操作</td>
<td>db.class2.update({name:’小明’},{$push:{score:{$each:[10,5]}}})</td>
</tr>
<tr>
<td>$position</td>
<td>需要搭配each使用，插入到1号位置</td>
<td>db.class2.update({name:’小红’},{$push:{score:{$each:[78],$position:1}}})</td>
</tr>
<tr>
<td>$sort</td>
<td>对数组进行排序</td>
<td>db.class2.update({name:’小明’},{$push:{score:{$each:[],$sort:1}}})</td>
</tr>
<tr>
<td>$pop</td>
<td>弹出最后一项</td>
<td>db.class2.update({name:’小明’},{$pop:{score:1}})</td>
</tr>
<tr>
<td>$addToSet</td>
<td>向数组中添加一项，不能和其他的项重复</td>
<td>db.class2.update({name:’小明’},{$addToSet:{score:5}})</td>
</tr>
</tbody>
</table>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><hr>
<p>mongo中存储事件格式 ： ISODate()</p>
<hr>
<p>方法1： new Date()   自动生成当前时间<br><code>db.class0.insert({title:&#39;Python入门&#39;,date:new Date()})</code></p>
<hr>
<p>方法2： ISODate()  生成当前时间<br><code>db.class0.insert({title:&#39;Python精通&#39;,date:ISODate()})</code></p>
<hr>
<p>方法3： Date()  将生成的当前时间变为字符串<br><code>db.class0.insert({title:&#39;Python疯狂&#39;,date:Date()})</code></p>
<hr>
<p>ISODate()<br><strong>功能：</strong>生成mongo时间存储类型<br><strong>参数：</strong>参数为指定时间<br>“2018-1-1 12:10:34”<br>“20180101 12:10:34”<br>“20181102”<br>e.g. <code>db.class0.insert({title:&#39;Python崩溃&#39;,date:ISODate(&quot;2018-11-12 11:23:32&quot;)})</code></p>
<hr>
<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>valueof（） 将当前时间生成为时间戳<br>e.g.  <code>db.class0.insert({title:&#39;Python放生&#39;,date:ISODate().valueOf()})</code></p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><ol>
<li>如果某个域存在却没有值可以设置为null<br>e.g.  <code>db.class0.insert({title:&#39;Python 爬虫&#39;,price:null})</code></li>
<li>某个域不存在，可以使用null来匹配<br>e.g. <code>db.class1.find({gender:null},{_id:0})</code> 当gender域不存在时可以找到这个文档</li>
</ol>
<h2 id="Object-内部文档"><a href="#Object-内部文档" class="headerlink" title="Object  内部文档"></a>Object  内部文档</h2><p>文档内某个域的值还是一个文档则这个文档为内部文档</p>
<ul>
<li>当需要使用内部文档某个域时，可以使用外部文档引用内部文档的方式。但是注意在使用时需要加引号<br>e.g. <code>db.class3.find({&#39;book2.title&#39;:&#39;Css3&#39;},{_id:0})</code><br>e.g. <code>db.class3.update({&#39;book3.title&#39;:&#39;JavaScript&#39;},{$set:{&#39;book3.price&#39;:38.8}})</code></li>
</ul>
<h2 id="数组的下标引用"><a href="#数组的下标引用" class="headerlink" title="数组的下标引用"></a>数组的下标引用</h2><p>使用数组时，可以使用数组域数组序列下标的方式使用数组中的具体某一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.g.  修改数组中的第0项</span><br><span class="line">db.class2.update(&#123;name:&quot;小明&quot;&#125;,&#123;$set:&#123;&apos;score.0&apos;:15&#125;&#125;)</span><br><span class="line">e.g. 通过数组中的第0项查找</span><br><span class="line">db.class2.find(&#123;&apos;score.0&apos;:15&#125;,&#123;_id:0&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="查找结果的有序性"><a href="#查找结果的有序性" class="headerlink" title="查找结果的有序性"></a>查找结果的有序性</h2><p>即可以对find查找结果使用[]引用序列下标的方式获取查找结果的第几项<br>e.g.<code>db.class2.find({},{_id:0})[3]</code></p>
<hr>
<p>练习 ：<br>使用之前的grade数据库</p>
<hr>
<ol>
<li>将小红年龄修改为8岁，兴趣爱好变为跳舞 画画<br>｛$set:{age:8,hobby:[‘dance’,’draw’]}｝</li>
</ol>
<hr>
<ol start="2">
<li>追加小明的兴趣 爱好 唱歌<br>{$push:{hobby:’sing’}}</li>
</ol>
<hr>
<ol start="3">
<li>小王兴趣爱好多了 吹牛，打篮球<br>{$pushAll:{hobby:[‘吹牛’,’basketball’]}}</li>
</ol>
<hr>
<ol start="4">
<li>小李兴趣多了跑步和唱歌，但是要确保不和之前的兴趣重复<br>｛$addToSet:{hobby:{$each:[‘running’,’sing’]}}｝</li>
</ol>
<hr>
<ol start="5">
<li>该班所有同学年龄加1<br>update({},{$inc:{age:1}},false,ture)</li>
</ol>
<hr>
<ol start="6">
<li>删除小明的sex属性<br>{$unset:{sex:0}}</li>
</ol>
<hr>
<ol start="7">
<li>删除小李的兴趣中的第一项<br>{$pop:{hobby:-1}}</li>
</ol>
<hr>
<ol start="8">
<li>删除小红兴趣中画画和唱歌<br>{$pullAll:{hobby:[‘draw’,’sing’]}}</li>
</ol>
<hr>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>指建立指定键值及所在文档中存储位置的对照清单。使用索引可以方便我们进行快速查找，减少遍历次数，提高查找效率</strong></p>
<h3 id="mongo如何创建索引"><a href="#mongo如何创建索引" class="headerlink" title="mongo如何创建索引"></a>mongo如何创建索引</h3><p>ensureIndex()<br>功能： 创建索引<br>参数： 索引域，索引类别，索引选项<br>e.g.  根据name域创建索引<br><code>db.class1.ensureIndex({&#39;name&#39;:1})</code></p>
<ul>
<li>1表示正向索引，-1表示逆向索引</li>
</ul>
<hr>
<h3 id="查看集合索引"><a href="#查看集合索引" class="headerlink" title="查看集合索引"></a>查看集合索引</h3><p>db.class1.getIndexes()</p>
<ul>
<li>_id域是由系统自动为集合创建的索引<br>自定义索引名称<br>通过第二个参数中name选项<br><code>db.class1.ensureIndex({&#39;age&#39;:1},{name:&#39;myIndex&#39;})</code></li>
</ul>
<hr>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>dropIndex（）<br>功能：删除索引<br>参数：要删除的索引，可以是索引名称或者索引键值对<br>e.g.   <code>db.class1.dropIndex({name:1})</code><br>e.g.   <code>db.class1.dropIndex(&#39;myIndex&#39;)</code><br>dropIndexes()<br>功能：删除所有索引<br>e.g.  删除所有索引但是不会删除_id索引<br><code>db.class1.dropIndexes()</code></p>
<hr>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>根据多个域创建一个索引<br>e.g.   <code>db.class1.ensureIndex({name:1,age:-1})</code></p>
<hr>
<h3 id="数组和子文档索引"><a href="#数组和子文档索引" class="headerlink" title="数组和子文档索引"></a>数组和子文档索引</h3><p>如果对某个域的值为数组或者子文档的域创建索引，则通过数组或者子文档进行查找时也是索引查找<br>e.g. 如果对score创建了索引则该查找也为索引查找<br><code>db.class2.find({&#39;score.0&#39;:15},{_id:0})</code></p>
<hr>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>创建索引时希望集合中创建索引的域的值均不重复<br>e.g.<code>db.class1.ensureIndex({name:1},{unique:true})</code><br>当对某个域创建了唯一索引则无法插入重复值</p>
<hr>
<h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><p>只针对有指定域的文档创建索引表，如果某个文档没有该域则不会在索引表中插入内容<br>e.g.  对没有gender域的文档不做索引处理<br><code>db.class1.ensureIndex({gender:1},{sparse:true})</code></p>
<hr>
<h3 id="索引约束"><a href="#索引约束" class="headerlink" title="索引约束"></a>索引约束</h3><ol>
<li>当数据发生更新索引表也要随之更新,影响插入,删除,修改操作效率</li>
<li>索引表也需要占有一定的磁盘空间</li>
</ol>
<hr>
<p><strong>综上：<br>1.当对数据库进行大量的查找操作，而不是修改操作<br>2.集合中文档的数量较大的时候<br>比较适合创建索引</strong></p>
<hr>
<h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p>对文档的筛选结果进行整理统计(更高级的查找)<br>db.collection.aggregate()<br>功能： 聚合函数 ，完成聚合操作<br>参数： 聚合条件  —&gt; 聚合操作符</p>
<h2 id="聚合操作符"><a href="#聚合操作符" class="headerlink" title="聚合操作符"></a>聚合操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$group</td>
<td>分组聚合,需要配合具体的分组操作符使用</td>
<td>db.class1.aggregate({$group:{_id:’$age’,num:{$sum:1}}})    </td>
</tr>
<tr>
<td>$sum</td>
<td>求和</td>
<td>db.class1.aggregate({$group:{_id:’$gender’,num:{$sum:’$age’}}})</td>
</tr>
<tr>
<td>$avg</td>
<td>求平均数</td>
<td>db.class1.aggregate({$group:{_id:’$gender’,avg_age:{$avg:’$age’}}})</td>
</tr>
<tr>
<td>$max</td>
<td>求最大值</td>
<td>db.class1.aggregate({$group:{_id:’$gender’,max:{$max:’$age’}}})</td>
</tr>
<tr>
<td>$min</td>
<td>求最小值</td>
<td>db.class1.aggregate({$group:{_id:’$gender’,min:{$min:’$age’}}})</td>
</tr>
<tr>
<td>$project</td>
<td>用于修改文档的显示效果</td>
<td>db.class1.aggregate({$project:{_id:0,name:1,age:1}})</td>
</tr>
<tr>
<td>$match</td>
<td>过滤数据</td>
<td>db.class1.aggregate({$match:{age:{$gt:18}}})</td>
</tr>
<tr>
<td>$limit</td>
<td>显示前几条文档</td>
<td>db.class1.aggregate({$limit:3})</td>
</tr>
<tr>
<td>$skip</td>
<td>跳过几条文档</td>
<td>db.class1.aggregate({$skip:2})</td>
</tr>
<tr>
<td>$sort</td>
<td>排序</td>
<td>db.class1.aggregate({$sort:{age:-1}})</td>
</tr>
</tbody>
</table>
<h2 id="聚合管道-：将前一个聚合操作得到的结果，给后一个聚合操作继续使用"><a href="#聚合管道-：将前一个聚合操作得到的结果，给后一个聚合操作继续使用" class="headerlink" title="聚合管道 ：将前一个聚合操作得到的结果，给后一个聚合操作继续使用"></a>聚合管道 ：将前一个聚合操作得到的结果，给后一个聚合操作继续使用</h2><p>db.collection.aggregate([聚合1，聚合2…])<br>e.g.  match —&gt; project —&gt; sort<br><code>db.class1.aggregate([{$match:{gender:&#39;m&#39;}},{$project:{_id:0}},{$sort:{age:-1}}])</code><br>e.g.  group —&gt; match<br><code>db.class1.aggregate([{$group:{_id:&#39;$name&#39;,num:{$sum:1}}},{$match:{num:{$gt:1}}}])</code></p>
<hr>
<h2 id="固定集合"><a href="#固定集合" class="headerlink" title="固定集合"></a>固定集合</h2><p>mongodb中可以创建大小固定的集合，称之为固定集合。<br><strong> 特点 ：</strong> </p>
<ul>
<li>插入速度快，顺序查找速度快</li>
<li>能够淘汰早期的数据</li>
<li>可以控制集合的空间大小</li>
</ul>
<p><strong>使用 ：</strong><br>临时缓存<br>日志处理</p>
<p><strong>创建：</strong><br>db.createCollection(collection,{capped:true,size:10000,max:10000})<br>capped:true    表示创建的集合是固定集合<br>size：表示集合的大小 单位 kb<br>max: 表示最多存放的文档个数<br>e.g. <code>db.createCollection(&#39;log&#39;,{capped:true,size:10,max:3})</code></p>
<hr>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="文件存储数据库的方式"><a href="#文件存储数据库的方式" class="headerlink" title="文件存储数据库的方式"></a>文件存储数据库的方式</h3><ol>
<li>存储路径<br>将文件在本地的路径以字符串形式存储到数据库<br>优点：节省数据库空间<br>缺点：当数据库或者文件位置发生变化时需要修改数据库内容 </li>
<li>存储文件本身<br>将文件以二进制（数据库指定编码）的形式存入到数据库中<br>优点 ： 数据库在，文件就在，不会丢失<br>缺点 ： 占用数据库的空间大。特别是文件较大的时候，由于数据库都是结构化的存储数据，所以对大文件处理效率较低</li>
</ol>
<h3 id="mongo存储大文件方案-：-GridFS-存储大文件"><a href="#mongo存储大文件方案-：-GridFS-存储大文件" class="headerlink" title="mongo存储大文件方案 ： GridFS 存储大文件"></a>mongo存储大文件方案 ： GridFS 存储大文件</h3><p>超过16M的文件为大文件</p>
<h4 id="GridFS方案解释"><a href="#GridFS方案解释" class="headerlink" title="GridFS方案解释"></a>GridFS方案解释</h4><p>  在mongodb一个数据库中创建两个集合共同完成文件的存储<br>  fs.files ： 存储文件的相关信息（文件名，文件类型）<br>  fs.chunks: 分块存储文件的实际内容</p>
<h3 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h3><p> <code>mongofiles  -d  dbname  put  file</code></p>
<p>数据库不存在则自动创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.files</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5b2dc13269d72e13a6a28eaa&quot;), &quot;chunkSize&quot; : 261120, &quot;uploadDate&quot; : ISODate(&quot;2018-06-23T03:40:34.827Z&quot;), &quot;length&quot; : 119862, &quot;md5&quot; : &quot;ab01c0bfa9d2751b2ae33aea70e8f879&quot;, &quot;filename&quot; : &quot;file.jpg&quot; &#125;</span><br><span class="line"></span><br><span class="line">fs.chunks </span><br><span class="line"></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5b2dc13269d72e13a6a28eab&quot;), &quot;files_id&quot; : ObjectId(&quot;5b2dc13269d72e13a6a28eaa&quot;), &quot;n&quot; : 0, &quot;data&quot; : BinData(0,&quot;/9j/4AAQSkZJRgAB...)&#125;</span><br></pre></td></tr></table></figure>
<p>对于同一个文件 fs.files 的_id值 等于 fs.chunks 中files_id域的值</p>
<h3 id="提取文件"><a href="#提取文件" class="headerlink" title="提取文件"></a>提取文件</h3><p><code>mongofiles -d  dbname  get  file</code> </p>
<h3 id="Grid的优缺点"><a href="#Grid的优缺点" class="headerlink" title="Grid的优缺点"></a>Grid的优缺点</h3><p>优点 ： 存储方便，提供较好的存命令，方便移植<br>缺点 ： 读写效率低</p>
<hr>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>通过获取操作数据库的返回结果，得到返回结果的对象。通过该游标对象可以进一步得到数据库内容。<br>var cursor = db.class1.find()<br>cursor.next()<br>cursor.hasNext()</p>
<h2 id="通过python-操作MongoDB"><a href="#通过python-操作MongoDB" class="headerlink" title="通过python 操作MongoDB"></a>通过python 操作MongoDB</h2><p>pymongo 模块   第三方模块</p>
<p>安装<br>    <code>sudo pip3 install pymongo</code></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p>创建mongodb数据库连接对象<br> conn = pymongo.MongoClient(‘localhost’,27017)</p>
</li>
<li><p>生成要操作的数据库对象 (<strong>getitem</strong>)<br><code>db = conn.stu
db = conn[&#39;stu&#39;]</code></p>
</li>
<li><p>获取集合对象<br><code>myset = db.class0
myset = db[&#39;class0&#39;]</code></p>
</li>
<li><p>通过集合对象操作mongodb数据库</p>
<p>  增删改查索引聚合文件操作</p>
</li>
<li><p>关闭数据库连接<br><code>conn.close()</code></p>
</li>
</ol>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>insert()   参数用法同mongoshell中insert<br>insert_many()  or  insert_one()<br>save()</p>
<h4 id="查找操作-1"><a href="#查找操作-1" class="headerlink" title="查找操作"></a>查找操作</h4><p>find()<br>功能 ： 查找数据库内容<br>参数 ： 同mongo shell find（）<br>返回值 ： 返回一个结果游标cursor</p>
<p>在pymongo中使用操作符的方法和在mongoshell中一样，只需要加引号以字符串的方式给出</p>
<p>cursor属性函数</p>
<p>next()<br>limit()<br>skip()<br>count()<br>sort()<br>pymongo  ：sort([(‘age’,-1),(‘name’,1)])<br>mongo shell ： sort({age:-1,name:1})</p>
<p>当游标使用了next或for取值后就不能再进行limit skip或者sort操作了</p>
<p>find_one() 返回一个字典</p>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p><code>update（query,update,upsert=False,multi=False）
update_many（）
update_one()</code></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><pre><code>remove(query,multi = True)
</code></pre><p>multi默认为True表示删除所有符合条件的数据<br>设置为False表示只删除一条</p>
<h4 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h4><p>ensure_index()<br>list_indexes()<br>drop_index()<br>drop_indexes()</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>aggregate([])<br>参数： 和mongoshell中写法一致<br>返回值 ： 返回一个迭代器同find </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Godshion</p>
              <p class="site-description motion-element" itemprop="description">本站主要提供python教学的系列知识汇总</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                主页
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_41661393" title="csdn_blog" target="_blank">csdn_blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Godshion</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">72.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  






	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
