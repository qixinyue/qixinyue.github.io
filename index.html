<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本站主要提供python教学的系列知识汇总">
<meta property="og:type" content="website">
<meta property="og:title" content="响神的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="响神的博客">
<meta property="og:description" content="本站主要提供python教学的系列知识汇总">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="响神的博客">
<meta name="twitter:description" content="本站主要提供python教学的系列知识汇总">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>响神的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">响神的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">计算机编程-python入门到精通</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/redis/" itemprop="url">Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T18:07:40+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,443 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  55 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>redis是一种非关系型数据库(NOSQL not only sql)，是一个由Salvatore Sanfikippo写的key-value存储系统。<br>Redis是开源的，使用的是ANSI C语言编写的，遵守BSD协议，支持网络，可基于内存，可持久化的日志型键值对的数据库<br>值的数据类型： 字符串string 哈希Map 列表list 集合set 有序集合sorted sets等类型。</p>
<h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<h2 id="Redis优势"><a href="#Redis优势" class="headerlink" title="Redis优势"></a>Redis优势</h2><ul>
<li>性能极高 读写速度达到了110K/s 81K/s</li>
<li>丰富的数据类型</li>
<li>原子性</li>
<li>丰富的特性-Redis还支持publish/subscribe 通知，key过期等特性</li>
</ul>
<p>Redis与其他key-value存储的区别</p>
<ul>
<li>Redis有着更加复杂的数据结构并且提供对其的原子操作，redis的数据类型都是基本数据类型，对程序员透明，不需要进行抽象</li>
<li>Redis运行在内存中，但是可以持久化到磁盘，在运行速度上更加快。</li>
</ul>
<h1 id="Redis环境配置"><a href="#Redis环境配置" class="headerlink" title="Redis环境配置"></a>Redis环境配置</h1><h2 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h2><p>windows下载地址：<a href="https://github.com/MSOpenTech/redis/releases。" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases。</a><br>下载zip格式的文件，解压，然后在解压目录下，点击路径，将原来的删除，输入cmd，回车进入到该目录的命令行模式窗口下，为了方便，请添加该路径到环境变量，具体方法这里不详述了。<br>然后在打开的命令行运行指令</p>
<pre><code>redis-server.exe redis.windows.conf
</code></pre><p>这样就可以看到类型如下界面，我的路径是D:\Redis-x64-3.2.100&gt;：</p>
<pre><code>Microsoft Windows [版本 10.0.15063]
(c) 2017 Microsoft Corporation。保留所有权利。

D:\Redis-x64-3.2.100&gt;redis-server.exe redis.windows.conf
                _._
           _.-``__ &apos;&apos;-._
      _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.100 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._
 (    &apos;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379
 |    `-._   `._    /     _.-&apos;    |     PID: 1716
  `-._    `-._  `-./  _.-&apos;    _.-&apos;
 |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|
 |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io
  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;
 |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|
 |    `-._`-._        _.-&apos;_.-&apos;    |
  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;
      `-._    `-.__.-&apos;    _.-&apos;
          `-._        _.-&apos;
              `-.__.-&apos;

[1716] 20 Aug 18:31:21.434 # Server started, Redis version 3.2.100
[1716] 20 Aug 18:31:21.435 * The server is now ready to accept connections on port 6379
</code></pre><p>这个指令的作用是开启redis的服务器，我们需要再启动一个客户端，在刚刚的目录下再打开一个命令行窗口，执行指令</p>
<pre><code>redis-cli.exe -h 127.0.0.1 -p 6379
</code></pre><p>来启动客户端，以下指令不指定情况下都是在该窗口发送的。</p>
<p>设置键值对指令 set myKey abc<br>取出键值对  get myKey</p>
<pre><code>D:\Redis-x64-3.2.100&gt;redis-cli.exe -h 127.0.0.1 -p 6379
127.0.0.1:6379&gt; set myKey abc
OK
127.0.0.1:6379&gt; get myKey
&quot;abc&quot;
127.0.0.1:6379&gt;
</code></pre><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p>ubuntu下执行如下指令安装redis</p>
<pre><code>sudo apt-get install redis-server
</code></pre><p>启动reids</p>
<pre><code>redis-server
</code></pre><p>查看redis是否启动</p>
<pre><code>redis-cli
</code></pre><h2 id="Mac-下安装-（没有试过，手上没有这个系统的机器）"><a href="#Mac-下安装-（没有试过，手上没有这个系统的机器）" class="headerlink" title="Mac 下安装 （没有试过，手上没有这个系统的机器）"></a>Mac 下安装 （没有试过，手上没有这个系统的机器）</h2><ol>
<li><p>官网<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a> 下载最新的稳定版本,这里是3.2.0</p>
</li>
<li><p>sudo mv 到 /usr/local/</p>
</li>
<li><p>sudo tar -zxf redis-3.2.0.tar 解压文件</p>
</li>
<li><p>进入解压后的目录 cd redis-3.2.0</p>
</li>
<li><p>sudo make test 测试编译</p>
</li>
<li><p>sudo make install </p>
</li>
</ol>
<p>mac 下安装也可以使用 homebrew，homebrew 是 mac 的包管理器。</p>
<p>1、执行 brew install redis</p>
<p>2、启动 redis，可以使用后台服务启动 brew services start redis。或者直接启动：redis-server /usr/local/etc/redis.conf</p>
<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>查看配置名称<br>CONFIG GET CONFIG_SETTING_NAME<br>获取log级别<br>CONFIG GET loglevel<br>获取所有配置项<br>CONFIG GET *</p>
<p>设置配置项<br>基本语法规则： CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE<br>示例如下：</p>
<pre><code>CONFIG SET loglevel &quot;notice&quot;
</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>redis.conf 配置项说明如下：</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<p> daemonize no</p>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<p> pidfile /var/run/redis.pid</p>
</li>
<li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
<p> port 6379</p>
</li>
<li><p>绑定的主机地址</p>
<p> bind 127.0.0.1</p>
</li>
</ol>
<p>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>
<pre><code>timeout 300
</code></pre><ol start="6">
<li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
<p> loglevel verbose</p>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<p> logfile stdout</p>
</li>
<li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</dbid></p>
<p> databases 16</p>
</li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<p> save <seconds> <changes></changes></seconds></p>
<p> Redis默认配置文件中提供了三个条件：</p>
<p> save 900 1</p>
<p> save 300 10</p>
<p> save 60 10000</p>
<p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
</li>
</ol>
<ol start="10">
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
<p>rdbcompression yes</p>
</li>
<li><p>指定本地数据库文件名，默认值为dump.rdb</p>
<p>dbfilename dump.rdb</p>
</li>
<li><p>指定本地数据库存放目录</p>
<p>dir ./</p>
</li>
<li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
<p>slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<p>masterauth <master-password></master-password></p>
</li>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</password></p>
<p>requirepass foobared</p>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<p>maxclients 128</p>
</li>
<li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
<p>maxmemory <bytes></bytes></p>
</li>
<li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
<p>appendonly no</p>
</li>
<li><p>指定更新日志文件名，默认为appendonly.aof</p>
<p> appendfilename appendonly.aof</p>
</li>
<li><p>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）</p>
<p>appendfsync everysec</p>
</li>
</ol>
<ol start="21">
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
<p> vm-enabled no</p>
</li>
<li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
<p> vm-swap-file /tmp/redis.swap</p>
</li>
<li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
<p> vm-max-memory 0</p>
</li>
<li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
<p> vm-page-size 32</p>
</li>
<li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
<p> vm-pages 134217728</p>
</li>
<li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
<p> vm-max-threads 4</p>
</li>
<li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
<p>glueoutputbuf yes</p>
</li>
<li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
<p>hash-max-zipmap-entries 64</p>
<p>hash-max-zipmap-value 512</p>
</li>
<li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
<p>activerehashing yes</p>
</li>
<li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
<p>include /path/to/local.conf</p>
</li>
</ol>
<h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
<p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; SET name &quot;qixinyue&quot;
OK
redis 127.0.0.1:6379&gt; GET name
&quot;qixinyue&quot;
</code></pre><p>在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 qixinyue。</p>
<p>注意：一个键最大能存储512MB。</p>
<p>Redis 字符串命令<br>下表列出了常用的 redis 字符串命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td>GET key</td>
<td>获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td>GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>MGET key1 [key2..]</td>
<td>获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td>SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td>SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>MSET key value [key value …]</td>
<td>同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td>PSETEX key milliseconds value</td>
<td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td>INCR key</td>
<td>将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td>INCRBY key increment</td>
<td>将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td>DECR key</td>
<td>将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td>DECRBY key decrement</td>
<td>key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p>实例</p>
<pre><code>redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;
&quot;OK&quot;
redis&gt; HGET myhash field1
&quot;Hello&quot;
redis&gt; HGET myhash field2
&quot;World&quot;
</code></pre><p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</p>
<p>每个 hash 可以存储 2<sup>32</sup> -1 键值对（40多亿）。</p>
<p>Redis hash 命令<br>下表列出了 redis hash 基本的相关命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>HDEL key field1 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>2</td>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>3</td>
<td>HGET key field</td>
<td>获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td>4</td>
<td>HGETALL key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>5</td>
<td>HINCRBY key field increment</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>6</td>
<td>HINCRBYFLOAT key field increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>7</td>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>8</td>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>9</td>
<td>HMGET key field1 [field2]</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>10</td>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td>11</td>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td>12</td>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>13</td>
<td>HVALS key</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>14</td>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody>
</table>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; lpush qixinyue redis
(integer) 1
redis 127.0.0.1:6379&gt; lpush qixinyue mongodb
(integer) 2
redis 127.0.0.1:6379&gt; lpush qixinyue rabitmq
(integer) 3
redis 127.0.0.1:6379&gt; lrange qixinyue 0 10
1) &quot;rabitmq&quot;
2) &quot;mongodb&quot;
3) &quot;redis&quot;
redis 127.0.0.1:6379&gt;
</code></pre><p>列表最多可存储 2<sup>32</sup> - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<p>Redis 列表命令<br>下表列出了列表相关的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>2</td>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>3</td>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>4</td>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>5</td>
<td>LINSERT key BEFORE&#124;AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>6</td>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>7</td>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>8</td>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>9</td>
<td>LPUSHX key value</td>
<td>将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>10</td>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>11</td>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>12</td>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>13</td>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>14</td>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>15</td>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>16</td>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>17</td>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>sadd 命令<br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p>
<p>sadd key member<br>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; sadd qixinyue redis
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue mongodb
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue rabitmq
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue rabitmq
(integer) 0
redis 127.0.0.1:6379&gt; smembers qixinyue

1) &quot;redis&quot;
2) &quot;rabitmq&quot;
3) &quot;mongodb&quot;
</code></pre><p>注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>
<p>集合中最大的成员数为 2<sup>32</sup> - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<p>Redis 集合命令<br>下表列出了 Redis 集合基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SADD key member1 [member2]</td>
<td>向集合添加一个或多个成员</td>
</tr>
<tr>
<td>2</td>
<td>SCARD key</td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td>SDIFF key1 [key2]</td>
<td>返回给定所有集合的差集</td>
</tr>
<tr>
<td>4</td>
<td>SDIFFSTORE destination key1 [key2]</td>
<td>返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>5</td>
<td>SINTER key1 [key2]</td>
<td>返回给定所有集合的交集</td>
</tr>
<tr>
<td>6</td>
<td>SINTERSTORE destination key1 [key2]</td>
<td>返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>7</td>
<td>SISMEMBER key member</td>
<td>判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>8</td>
<td>SMEMBERS key</td>
<td>返回集合中的所有成员</td>
</tr>
<tr>
<td>9</td>
<td>SMOVE source destination member</td>
<td>将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>10</td>
<td>SPOP key</td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>11</td>
<td>SRANDMEMBER key [count]</td>
<td>返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>12</td>
<td>SREM key member1 [member2]</td>
<td>移除集合中一个或多个成员</td>
</tr>
<tr>
<td>13</td>
<td>SUNION key1 [key2]</td>
<td>返回所有给定集合的并集</td>
</tr>
<tr>
<td>14</td>
<td>SUNIONSTORE destination key1 [key2]</td>
<td>所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>15</td>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代集合中的元素</td>
</tr>
</tbody>
</table>
<h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<p>zadd 命令<br>添加元素到集合，元素在集合中存在则更新对应score</p>
<p>zadd key score member<br>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; zadd qixinyue 0 redis
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 mongodb
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 rabitmq
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 rabitmq
(integer) 0
redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE qixinyue 0 1000
1) &quot;mongodb&quot;
2) &quot;rabitmq&quot;
3) &quot;redis&quot;
</code></pre><p>Redis 有序集合命令<br>下表列出了 redis 有序集合的基本命令:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ZADD key score1 member1 [score2 member2]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>2</td>
<td>ZCARD key</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td>ZCOUNT key min max</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>4</td>
<td>ZINCRBY key increment member</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>5</td>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>6</td>
<td>ZLEXCOUNT key min max</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>7</td>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>8</td>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>9</td>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>10</td>
<td>ZRANK key member</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>11</td>
<td>ZREM key member [member …]</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>12</td>
<td>ZREMRANGEBYLEX key min max</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>13</td>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>14</td>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>15</td>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>16</td>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>17</td>
<td>ZREVRANK key member</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>18</td>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>19</td>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>20</td>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<h1 id="Redis-keys-命令"><a href="#Redis-keys-命令" class="headerlink" title="Redis keys 命令"></a>Redis keys 命令</h1><p>下表给出了与 Redis 键相关的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>DEL key</td>
<td>该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td>2</td>
<td>DUMP key</td>
<td>序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td>3</td>
<td>EXISTS key</td>
<td>检查给定 key 是否存在。</td>
</tr>
<tr>
<td>4</td>
<td>EXPIRE key seconds</td>
<td>为给定 key 设置过期时间。</td>
</tr>
<tr>
<td>5</td>
<td>EXPIREAT key timestamp</td>
<td>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td>6</td>
<td>PEXPIRE key milliseconds</td>
<td>设置 key 的过期时间以毫秒计。</td>
</tr>
<tr>
<td>7</td>
<td>PEXPIREAT key milliseconds-timestamp</td>
<td>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td>8</td>
<td>KEYS pattern</td>
<td>查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td>9</td>
<td>MOVE key db</td>
<td>将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td>10</td>
<td>PERSIST key</td>
<td>移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td>11</td>
<td>PTTL key</td>
<td>以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td>12</td>
<td>TTL key</td>
<td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td>13</td>
<td>RANDOMKEY</td>
<td>从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td>14</td>
<td>RENAME key newkey</td>
<td>修改 key 的名称</td>
</tr>
<tr>
<td>15</td>
<td>RENAMENX key newkey</td>
<td>仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td>16</td>
<td>TYPE key</td>
<td>返回 key 所储存的值的类型。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis HyperLogLog"></a>Redis HyperLogLog</h1><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p><strong>HyperLogLog作用</strong><br>Redis HyperLogLog 是用来做基数统计的算法</p>
<p><strong>HyperLogLog 的优点</strong><br>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>什么是基数?</strong><br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。<br>基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p>实例<br>以下实例演示了 HyperLogLog 的工作过程：</p>
<pre><code>redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;redis&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;mongodb&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;mysql&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFCOUNT qixinyuekey

(integer) 3
</code></pre><p>Redis HyperLogLog 命令<br>下表列出了 redis HyperLogLog 的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PFADD key element [element …]</td>
<td>添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td>2</td>
<td>PFCOUNT key [key …]</td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td>3</td>
<td>PFMERGE destkey sourcekey [sourcekey …]</td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系如下：<br>channel1 -&gt;client2<br>channel1 -&gt;client5<br>channel1 -&gt;client1</p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br>channel1（message） -&gt;client2<br>channel1（message） -&gt;client5<br>channel1（message） -&gt;client1</p>
<p>实例<br>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<pre><code>redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat

Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;redisChat&quot;
3) (integer) 1
</code></pre><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<pre><code>redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;

(integer) 1

redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by qixinyue.github.io&quot;

(integer) 1

# 订阅者的客户端会显示如下消息
1) &quot;message&quot;
2) &quot;redisChat&quot;
3) &quot;Redis is a great caching technique&quot;
1) &quot;message&quot;
2) &quot;redisChat&quot;
3) &quot;Learn redis by .github.io&quot;
</code></pre><p>Redis 发布订阅命令<br>下表列出了 redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>2</td>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>3</td>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>4</td>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>5</td>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>6</td>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p><strong>一个事务从开始到执行会经历以下三个阶段：</strong></p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<p>实例<br>以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：</p>
<pre><code>redis 127.0.0.1:6379&gt; MULTI
OK

redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;
QUEUED

redis 127.0.0.1:6379&gt; GET book-name
QUEUED

redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;
QUEUED

redis 127.0.0.1:6379&gt; SMEMBERS tag
QUEUED

redis 127.0.0.1:6379&gt; EXEC
1) OK
2) &quot;Mastering C++ in 21 days&quot;
3) (integer) 3
4) 1) &quot;Mastering Series&quot;
   2) &quot;C++&quot;
   3) &quot;Programming&quot;
</code></pre><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<p>官网上的说明 :</p>
<pre><code>It&apos;s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.
</code></pre><p>比如：</p>
<pre><code>redis 127.0.0.1:7000&gt; multi
OK
redis 127.0.0.1:7000&gt; set a aaa
QUEUED
redis 127.0.0.1:7000&gt; set b bbb
QUEUED
redis 127.0.0.1:7000&gt; set c ccc
QUEUED
redis 127.0.0.1:7000&gt; exec
1) OK
2) OK
3) OK
</code></pre><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p>
<p>Redis 事务命令<br>下表列出了 redis 事务的相关命令：</p>
<p>序号|    命令|描述<br>1    DISCARD 取消事务，放弃执行事务块内的所有命令。<br>2    |EXEC |执行所有事务块内的命令。<br>3    |MULTI |标记一个事务块的开始。<br>4    |UNWATCH |取消 WATCH 命令对所有 key 的监视。<br>5    |WATCH key [key …]| 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<h1 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h1><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<p>语法<br>Eval 命令的基本语法如下：</p>
<pre><code>redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]
</code></pre><p>实例<br>以下实例演示了 redis 脚本工作过程：</p>
<pre><code>redis 127.0.0.1:6379&gt; EVAL &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second

1) &quot;key1&quot;
2) &quot;key2&quot;
3) &quot;first&quot;
4) &quot;second&quot;
</code></pre><p><strong>Redis 脚本命令</strong><br>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>EVAL script numkeys key [key …] arg [arg …]</td>
<td>执行 Lua 脚本。</td>
</tr>
<tr>
<td>2</td>
<td>EVALSHA sha1 numkeys key [key …] arg [arg …]</td>
<td>执行 Lua 脚本。</td>
</tr>
<tr>
<td>3</td>
<td>SCRIPT EXISTS script [script …]</td>
<td>查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td>4</td>
<td>SCRIPT FLUSH</td>
<td>从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td>5</td>
<td>SCRIPT KILL</td>
<td>杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td>6</td>
<td>SCRIPT LOAD script</td>
<td>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h1><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<p>实例<br>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<pre><code>redis 127.0.0.1:6379&gt; AUTH &quot;password&quot;
OK
redis 127.0.0.1:6379&gt; PING
PONG
</code></pre><p><strong>Redis 连接命令</strong><br>下表列出了 redis 连接的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AUTH password</td>
<td>验证密码是否正确</td>
</tr>
<tr>
<td>2</td>
<td>ECHO message</td>
<td>打印字符串</td>
</tr>
<tr>
<td>3</td>
<td>PING</td>
<td>查看服务是否运行</td>
</tr>
<tr>
<td>4</td>
<td>QUIT</td>
<td>关闭当前连接</td>
</tr>
<tr>
<td>5</td>
<td>SELECT index</td>
<td>切换到指定的数据库</td>
</tr>
</tbody>
</table>
<h1 id="Redis服务器"><a href="#Redis服务器" class="headerlink" title="Redis服务器"></a>Redis服务器</h1><p>Redis服务器命令主要是用于管理redis服务。</p>
<p>实例<br>以下实例演示了如何获取redis服务器的统计信息：</p>
<pre><code>redis 127.0.0.1:6379&gt;信息

#Server
redis_version：2.8.13
redis_git_sha1：00000000
redis_git_dirty：0
redis_build_id：c2238b38b1edb0e2
redis_mode：独立
os：Linux 3.5.0-48-generic x86_64
arch_bits：64
multiplexing_api：epoll的
gcc_version：4.7.2
PROCESS_ID：3856
run_id：0e61abd297771de3fe812a3c21027732ac9f41fe
TCP_PORT：6379
uptime_in_seconds：11554
uptime_in_days：0
赫兹：10
lru_clock：16651447
CONFIG_FILE：

＃客户
connected_clients：1
客户longest_output_list：0
客户biggest_input_buf：0
blocked_clients：0

＃记忆
used_memory：589016
used_memory_human：575.21K
used_memory_rss：2461696
used_memory_peak：667312
used_memory_peak_human：651.67K
used_memory_lua：33792
mem_fragmentation_ratio：4.18
mem_allocator：jemalloc-3.6.0

#Persistence
负载：0
rdb_changes_since_last_save：3
rdb_bgsave_in_progress：0
rdb_last_save_time：1409158561
rdb_last_bgsave_status：OK
rdb_last_bgsave_time_sec：0
rdb_current_bgsave_time_sec：-1
aof_enabled：0
aof_rewrite_in_progress：0
aof_rewrite_scheduled：0
aof_last_rewrite_time_sec：-1
aof_current_rewrite_time_sec：-1
aof_last_bgrewrite_status：OK
aof_last_write_status：OK

#Stats
total_connections_received：24
total_commands_processed：294
instantaneous_ops_per_sec：0
rejected_connections：0
sync_full：0
sync_partial_ok：0
sync_partial_err：0
expired_keys：0
evicted_keys：0
keyspace_hits：41
keyspace_misses：82
pubsub_channels：0
pubsub_patterns：0
latest_fork_usec：264

#Replication
作用：主
connected_slaves：0
master_repl_offset：0
repl_backlog_active：0
repl_backlog_size：1048576
repl_backlog_first_byte_offset：0
repl_backlog_histlen：0

＃ 中央处理器
used_cpu_sys：10.49
used_cpu_user：4.96
used_cpu_sys_children：0.00
used_cpu_user_children：0.01

#Keyspace
DB0：键= 94，期满= 1，avg_ttl = 41638810
DB1：键= 1，过期= 0，avg_ttl = 0
DB3：键= 1，过期= 0，avg_ttl = 0
</code></pre><p><strong>Redis服务器命令</strong><br>下表列出了redis服务器的相关命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BGREWRITEAOF</td>
<td>异步执行一个AOF（AppendOnly File）文件重写操作</td>
</tr>
<tr>
<td>2</td>
<td>BGSAVE</td>
<td>在后台异步保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td>3</td>
<td>CLIENT KILL [ip：port] [ID client-id]</td>
<td>关闭客户端连接</td>
</tr>
<tr>
<td>4</td>
<td>CLIENT LIST</td>
<td>获取连接到服务器的客户端连接列表</td>
</tr>
<tr>
<td>5</td>
<td>CLIENT GETNAME</td>
<td>获取连接的名称</td>
</tr>
<tr>
<td>6</td>
<td>客户端暂停超时</td>
<td>在指定时间内终止运行来自客户端的命令</td>
</tr>
<tr>
<td>7</td>
<td>CLIENT SETNAME connection-name</td>
<td>设置当前连接的名称</td>
</tr>
<tr>
<td>8</td>
<td>CLUSTER SLOTS</td>
<td>获取集群节点的映射数组</td>
</tr>
<tr>
<td>9</td>
<td>COMMAND</td>
<td>获取Redis命令详情数组</td>
</tr>
<tr>
<td>10</td>
<td>COMMAND COUNT</td>
<td>获取Redis命令总数</td>
</tr>
<tr>
<td>11</td>
<td>COMMAND GETKEYS</td>
<td>获取给定命令的所有键</td>
</tr>
<tr>
<td>12</td>
<td>TIME</td>
<td>返回当前服务器时间</td>
</tr>
<tr>
<td>13</td>
<td>COMMAND INFO command-name [command-name …]</td>
<td>获取指定Redis命令描述的数组</td>
</tr>
<tr>
<td>14</td>
<td>CONFIG GET参数</td>
<td>获取指定配置参数的值</td>
</tr>
<tr>
<td>15</td>
<td>CONFIG REWRITE</td>
<td>对启动Redis服务器时所指定的redis.conf配置文件进行改写</td>
</tr>
<tr>
<td>16</td>
<td>CONFIG SET参数值</td>
<td>修改redis配置参数，无需重启</td>
</tr>
<tr>
<td>17</td>
<td>CONFIG RESETSTAT</td>
<td>重置INFO命令中的某些统计数据</td>
</tr>
<tr>
<td>18</td>
<td>DBSIZE</td>
<td>返回当前数据库的key的数量</td>
</tr>
<tr>
<td>19</td>
<td>DEBUG OBJECT键</td>
<td>获取键的调试信息</td>
</tr>
<tr>
<td>20</td>
<td>DEBUG SEGFAULT</td>
<td>让Redis服务崩溃</td>
</tr>
<tr>
<td>21</td>
<td>FLUSHALL</td>
<td>删除所有数据库的所有关键</td>
</tr>
<tr>
<td>22</td>
<td>FLUSHDB</td>
<td>删除当前数据库的所有关键</td>
</tr>
<tr>
<td>23</td>
<td>INFO [section]</td>
<td>获取Redis服务器的各种信息和统计数值</td>
</tr>
<tr>
<td>24</td>
<td>LASTSAVE</td>
<td>返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示</td>
</tr>
<tr>
<td>25</td>
<td>MONITOR</td>
<td>实时打印出Redis服务器接收到的命令，调试用</td>
</tr>
<tr>
<td>26</td>
<td>ROLE</td>
<td>返回主从实例所属的角色</td>
</tr>
<tr>
<td>27</td>
<td>SAVE</td>
<td>同步保存数据到硬盘</td>
</tr>
<tr>
<td>28</td>
<td>SHUTDOWN [NOSAVE] [SAVE]</td>
<td>异步保存数据到硬盘，并关闭服务器</td>
</tr>
<tr>
<td>29</td>
<td>SLAVEOF主机端口</td>
<td>将当前服务器转变为指定服务器的从属服务器（从服务器）</td>
</tr>
<tr>
<td>30</td>
<td>SLOWLOG子命令[参数]</td>
<td>管理redis的慢日志</td>
</tr>
<tr>
<td>31</td>
<td>SYNC</td>
<td>用于复制功能（复制）的内部命令</td>
</tr>
</tbody>
</table>
<h1 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h1><h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<p>语法<br>redis Save 命令基本语法如下：</p>
<pre><code>redis 127.0.0.1:6379&gt; SAVE 
</code></pre><p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; SAVE 
OK
</code></pre><p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：</p>
<pre><code>redis 127.0.0.1:6379&gt; CONFIG GET dir
1) &quot;dir&quot;
2) &quot;/usr/local/redis/bin&quot;
</code></pre><p>以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/bin。</p>
<p>Bgsave<br>创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p>
<p>实例</p>
<pre><code>127.0.0.1:6379&gt; BGSAVE

Background saving started
</code></pre><h1 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h1><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>
<p>实例<br>我们可以通过以下命令查看是否设置了密码验证：</p>
<pre><code>127.0.0.1:6379&gt; CONFIG get requirepass
1) &quot;requirepass&quot;
2) &quot;&quot;
</code></pre><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p>
<p>你可以通过以下命令来修改该参数：</p>
<p>127.0.0.1:6379&gt; CONFIG set requirepass “qixinyue”<br>OK<br>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “qixinyue”</p>
<p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。</p>
<p>语法<br>AUTH 命令基本语法格式如下：</p>
<pre><code>127.0.0.1:6379&gt; AUTH password
</code></pre><p>实例</p>
<pre><code>127.0.0.1:6379&gt; AUTH &quot;qixinyue&quot;
OK
127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;
OK
127.0.0.1:6379&gt; GET mykey
&quot;Test value&quot;
</code></pre><h1 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h1><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<p>语法<br>redis 性能测试的基本命令如下：</p>
<pre><code>redis-benchmark [option] [option value]
</code></pre><p>实例<br>以下实例同时执行 10000 个请求来检测性能：</p>
<pre><code>$ redis-benchmark -n 10000  -q

PING_INLINE: 141043.72 requests per second
PING_BULK: 142857.14 requests per second
SET: 141442.72 requests per second
GET: 145348.83 requests per second
INCR: 137362.64 requests per second
LPUSH: 145348.83 requests per second
LPOP: 146198.83 requests per second
SADD: 146198.83 requests per second
SPOP: 149253.73 requests per second
LPUSH (needed to benchmark LRANGE): 148588.42 requests per second
LRANGE_100 (first 100 elements): 58411.21 requests per second
LRANGE_300 (first 300 elements): 21195.42 requests per second
LRANGE_500 (first 450 elements): 14539.11 requests per second
LRANGE_600 (first 600 elements): 10504.20 requests per second
MSET (10 keys): 93283.58 requests per second
</code></pre><p>redis 性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>-h</td>
<td>指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>2</td>
<td>-p</td>
<td>指定服务器端口</td>
<td>6379</td>
</tr>
<tr>
<td>3</td>
<td>-s</td>
<td>指定服务器 socket</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>-c</td>
<td>指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>-n</td>
<td>指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td>6</td>
<td>-d</td>
<td>以字节的形式指定 SET/GET 值的数据大小</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>-k</td>
<td>1=keep alive 0=reconnect</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>-r</td>
<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>-P</td>
<td>通过管道传输 <numreq> 请求</numreq></td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>-q</td>
<td>强制退出 redis。仅显示 query/sec 值</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>–csv</td>
<td>以 CSV 格式输出</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>-l</td>
<td>生成循环，永久执行测试</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>-t</td>
<td>仅运行以逗号分隔的测试命令列表。</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>-I(大写的i)</td>
<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td></td>
</tr>
</tbody>
</table>
<p>实例<br>以下实例我们使用了多个参数来测试 redis 性能：</p>
<pre><code>$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q

SET: 146198.83 requests per second
LPUSH: 145560.41 requests per second
</code></pre><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<h1 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h1><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>
<p>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。<br>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法<br>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送<br>最大连接数<br>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p>
<p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<pre><code>config get maxclients

1) &quot;maxclients&quot;
2) &quot;10000&quot;
</code></pre><p>实例<br>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<pre><code>redis-server --maxclients 100000
</code></pre><p>客户端命令<br>S.N.    |命令|    描述<br>–|–|–<br>1    |CLIENT LIST    |返回连接到 redis 服务的客户端列表<br>2    |CLIENT SETNAME|    设置当前连接的名称<br>3    |CLIENT GETNAME    |获取通过 CLIENT SETNAME 命令设置的服务名称<br>4    |CLIENT PAUSE    |挂起客户端连接，指定挂起的时间以毫秒计<br>5    |CLIENT KILL    |关闭客户端连接</p>
<h1 id="Redis管道技术"><a href="#Redis管道技术" class="headerlink" title="Redis管道技术"></a>Redis管道技术</h1><p>Redis的是一种基于客户端 - 服务端模型以及请求/响应协议的TCP服务这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听套接字返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<h2 id="Redis管道技术-1"><a href="#Redis管道技术-1" class="headerlink" title="Redis管道技术"></a>Redis管道技术</h2><p>Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p>
<p>实例<br>查看redis管道，只需要启动redis实例并输入以下命令：</p>
<pre><code>$（echo -en“PING \ r \ n \ nSET qixinyuekey redis \ r \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \访问者\ r \ n \ n \ nIN访问者\ r \ nINCR访问者\ r \ n”;“睡眠10”| nc localhost 6379

+ PONG
+ OK
Redis的
：1
：2
：3
</code></pre><p>以上实例中我们通过使用PING命令查看redis服务是否可用，之后我们设置了qixinyuekey的值为redis，然后我们获取qixinyuekey的值并使得访客自增3次。</p>
<p>在返回的结果中我们可以看到这些命令一次性向redis服务提交，并最终一次性读取所有服务端的响应</p>
<h2 id="管道技术的优势"><a href="#管道技术的优势" class="headerlink" title="管道技术的优势"></a>管道技术的优势</h2><p>管道技术最显着的优势是提高了redis服务的性能。</p>
<p>一些测试数据<br>在下面的测试中，我们将使用Redis的的红宝石客户端，支持管道技术特性，测试管道技术对速度的提升效果。</p>
<pre><code>需要&apos;rubygems&apos; 
要求&apos;redis&apos;
def bench（descr） 
start = Time.now 
产量 
把“＃{descr}＃{Time.now-start}秒” 
结束
def without_pipelining 
r = Redis.new 
10000.times { 
    r.ping 
} 
结束
def with_pipelining 
r = Redis.new 
r.pipelined { 
    10000.times { 
        r.ping 
    } 
} 
结束
工作台（“没有流水线”）{ 
    without_pipelining 
} 
工作台（“与流水线”）{ 
    with_pipelining 
}
</code></pre><p>从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返时延已经被改善得相当低了。</p>
<pre><code>没有流水线1.185238秒 
使用流水线0.250783秒
</code></pre><p>如你所见，开启管道后，我们的速度效率提升了4.7倍。</p>
<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h1><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h2 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h2><ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<h2 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h2><p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>
</ul>
<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p>
<h2 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h2><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</p>
<p>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。</p>
<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。</p>
<h2 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h2><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
<h1 id="Python操作redis"><a href="#Python操作redis" class="headerlink" title="Python操作redis"></a>Python操作redis</h1><h2 id="1、String-操作"><a href="#1、String-操作" class="headerlink" title="1、String 操作"></a>1、String 操作</h2><p>　　redis中的String在在内存中按照一个name对应一个value来存储</p>
<p>set()</p>
<pre><code>#在Redis中设置值，默认不存在则创建，存在则修改
r.set(&apos;name&apos;, &apos;zhangsan&apos;)
&apos;&apos;&apos;参数：
     set(name, value, ex=None, px=None, nx=False, xx=False)
     ex，过期时间（秒）
     px，过期时间（毫秒）
     nx，如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value)
     xx，如果设置为True，则只有name存在时，当前set操作才执行&apos;&apos;&apos;


setex(name, value, time)
#设置过期时间（秒）

psetex(name, time_ms, value)
#设置过期时间（豪秒）
</code></pre><p>mset()</p>
<pre><code>#批量设置值
r.mset(name1=&apos;zhangsan&apos;, name2=&apos;lisi&apos;)
#或
r.mget({&quot;name1&quot;:&apos;zhangsan&apos;, &quot;name2&quot;:&apos;lisi&apos;})
</code></pre><p>get(name)</p>
<p>　　获取值</p>
<p>mget(keys, *args)</p>
<pre><code>#批量获取
print(r.mget(&quot;name1&quot;,&quot;name2&quot;))
#或
li=[&quot;name1&quot;,&quot;name2&quot;]
print(r.mget(li))
</code></pre><p>getset(name, value)</p>
<pre><code>#设置新值，打印原值
print(r.getset(&quot;name1&quot;,&quot;wangwu&quot;)) #输出:zhangsan
print(r.get(&quot;name1&quot;)) #输出:wangwu
</code></pre><p>getrange(key, start, end)</p>
<pre><code>#根据字节获取子序列
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.getrange(&quot;name&quot;,0,3))#输出:zhan
</code></pre><p>setrange(name, offset, value)</p>
<pre><code>#修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
r.setrange(&quot;name&quot;,1,&quot;z&quot;)
print(r.get(&quot;name&quot;)) #输出:zzangsan
r.setrange(&quot;name&quot;,6,&quot;zzzzzzz&quot;)
print(r.get(&quot;name&quot;)) #输出:zzangszzzzzzz
</code></pre><p>setbit(name, offset, value)</p>
<pre><code>#对二进制表示位进行操作
&apos;&apos;&apos; name:redis的name
    offset，位的索引（将值对应的ASCII码变换成二进制后再进行索引）
    value，值只能是 1 或 0 &apos;&apos;&apos;

str=&quot;345&quot;
r.set(&quot;name&quot;,str)
for i in str:
    print(i,ord(i),bin(ord(i)))#输出 值、ASCII码中对应的值、对应值转换的二进制
&apos;&apos;&apos;
输出:
    3 51 0b110011
    4 52 0b110100
    5 53 0b110101&apos;&apos;&apos;

r.setbit(&quot;name&quot;,6,0)#把第7位改为0，也就是3对应的变成了0b110001
print(r.get(&quot;name&quot;))#输出：145
</code></pre><p>getbit(name, offset)</p>
<pre><code>#获取name对应值的二进制中某位的值(0或1)
r.set(&quot;name&quot;,&quot;3&quot;) # 对应的二进制0b110011
print(r.getbit(&quot;name&quot;,5))   #输出:0
print(r.getbit(&quot;name&quot;,6))   #输出:1
</code></pre><p>bitcount(key, start=None, end=None)</p>
<pre><code>#获取对应二进制中1的个数
r.set(&quot;name&quot;,&quot;345&quot;)#0b110011 0b110100 0b110101
print(r.bitcount(&quot;name&quot;,start=0,end=1)) #输出:7
&apos;&apos;&apos; key:Redis的name
    start:字节起始位置
    end:字节结束位置&apos;&apos;&apos;
</code></pre><p>strlen(name)</p>
<pre><code>#返回name对应值的字节长度（一个汉字3个字节）
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.strlen(&quot;name&quot;)) #输出:8
</code></pre><p>incr(self, name, amount=1)</p>
<pre><code>#自增mount对应的值，当mount不存在时，则创建mount＝amount，否则，则自增,amount为自增数(整数)
print(r.incr(&quot;mount&quot;,amount=2))#输出:2
print(r.incr(&quot;mount&quot;))#输出:3
print(r.incr(&quot;mount&quot;,amount=3))#输出:6
print(r.incr(&quot;mount&quot;,amount=6))#输出:12
print(r.get(&quot;mount&quot;)) #输出:12
</code></pre><p>incrbyfloat(self, name, amount=1.0)</p>
<pre><code>#类似 incr() 自增,amount为自增数(浮点数)
</code></pre><p>decr(self, name, amount=1)</p>
<pre><code>#自减name对应的值,当name不存在时,则创建name＝amount，否则，则自减，amount为自增数(整数)
</code></pre><p>append(name, value)</p>
<pre><code>#在name对应的值后面追加内容
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.get(&quot;name&quot;))    #输出:&apos;zhangsan
r.append(&quot;name&quot;,&quot;lisi&quot;)
print(r.get(&quot;name&quot;))    #输出:zhangsanlisi
</code></pre><h2 id="2、Hash-操作"><a href="#2、Hash-操作" class="headerlink" title="2、Hash 操作"></a>2、Hash 操作</h2><p>redis中的Hash 在内存中类似于一个name对应一个dic来存储 </p>
<p> hset(name, key, value)</p>
<pre><code>#name对应的hash中设置一个键值对（不存在，则创建，否则，修改）
r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
</code></pre><p>hget(name,key)</p>
<pre><code>r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
#在name对应的hash中根据key获取value
print(r.hget(&quot;dic_name&quot;,&quot;a1&quot;))#输出:aa
</code></pre><p>hgetall(name)</p>
<p>#获取name对应hash的所有键值<br>print(r.hgetall(“dic_name”))<br>hmset(name, mapping)</p>
<p>#在name对应的hash中批量设置键值对,mapping:字典<br>dic={“a1”:”aa”,”b1”:”bb”}<br>r.hmset(“dic_name”,dic)<br>print(r.hget(“dic_name”,”b1”))#输出:bb<br>hmget(name, keys, *args)</p>
<h1 id="在name对应的hash中获取多个key的值"><a href="#在name对应的hash中获取多个key的值" class="headerlink" title="在name对应的hash中获取多个key的值"></a>在name对应的hash中获取多个key的值</h1><p>li=[“a1”,”b1”]<br>print(r.hmget(“dic_name”,li))<br>print(r.hmget(“dic_name”,”a1”,”b1”))<br>hlen(name)、hkeys(name)、hvals(name)</p>
<p>复制代码<br>dic={“a1”:”aa”,”b1”:”bb”}<br>r.hmset(“dic_name”,dic)</p>
<p>#hlen(name) 获取hash中键值对的个数<br>print(r.hlen(“dic_name”))</p>
<p>#hkeys(name) 获取hash中所有的key的值<br>print(r.hkeys(“dic_name”))</p>
<p>#hvals(name) 获取hash中所有的value的值<br>print(r.hvals(“dic_name”))<br>复制代码<br>hexists(name, key)</p>
<p>#检查name对应的hash是否存在当前传入的key<br>print(r.hexists(“dic_name”,”a1”))#输出:True<br>hdel(name,*keys)</p>
<p>#删除指定name对应的key所在的键值对<br>r.hdel(“dic_name”,”a1”)<br>hincrby(name, key, amount=1)</p>
<p>#自增hash中key对应的值，不存在则创建key=amount(amount为整数)<br>print(r.hincrby(“demo”,”a”,amount=2))<br>hincrbyfloat(name, key, amount=1.0)</p>
<p>#自增hash中key对应的值，不存在则创建key=amount(amount为浮点数)</p>
<p>hscan(name, cursor=0, match=None, count=None)</p>
<p>hscan_iter(name, match=None, count=None)</p>
<p>3、List 操作</p>
<p>redis中的List在在内存中按照一个name对应一个List来存储 </p>
<p>lpush(name,values)</p>
<h1 id="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"><a href="#在name对应的list中添加元素，每个新的元素都添加到列表的最左边" class="headerlink" title="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"></a>在name对应的list中添加元素，每个新的元素都添加到列表的最左边</h1><p>r.lpush(“list_name”,2)<br>r.lpush(“list_name”,3,4,5)#保存在列表中的顺序为5，4，3，2<br>rpush(name,values)</p>
<p>#同lpush，但每个新的元素都添加到列表的最右边<br>lpushx(name,value)</p>
<p>#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边<br>rpushx(name,value)</p>
<p>#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边<br>llen(name)</p>
<h1 id="name对应的list元素的个数"><a href="#name对应的list元素的个数" class="headerlink" title="name对应的list元素的个数"></a>name对应的list元素的个数</h1><p>print(r.llen(“list_name”))<br>linsert(name, where, refvalue, value))</p>
<p>复制代码</p>
<h1 id="在name对应的列表的某一个值前或后插入一个新值"><a href="#在name对应的列表的某一个值前或后插入一个新值" class="headerlink" title="在name对应的列表的某一个值前或后插入一个新值"></a>在name对应的列表的某一个值前或后插入一个新值</h1><p>r.linsert(“list_name”,”BEFORE”,”2”,”SS”)#在列表内找到第一个元素2，在它前面插入SS</p>
<p>‘’’参数：<br>     name: redis的name<br>     where: BEFORE（前）或AFTER（后）<br>     refvalue: 列表内的值<br>     value: 要插入的数据’’’<br>复制代码<br>r.lset(name, index, value)</p>
<p>#对list中的某一个索引位置重新赋值<br>r.lset(“list_name”,0,”bbb”)<br>r.lrem(name, value, num)</p>
<p>复制代码</p>
<p>#删除name对应的list中的指定值<br>r.lrem(“list_name”,”SS”,num=0)</p>
<p>‘’’ 参数：<br>    name:  redis的name<br>    value: 要删除的值<br>    num:   num=0 删除列表中所有的指定值；<br>           num=2 从前到后，删除2个；<br>           num=-2 从后向前，删除2个’’’<br>复制代码<br>lpop(name)</p>
<p>#移除列表的左侧第一个元素，返回值则是第一个元素<br>print(r.lpop(“list_name”))<br>lindex(name, index)</p>
<p>#根据索引获取列表内元素<br>print(r.lindex(“list_name”,1))<br>lrange(name, start, end)</p>
<p>#分片获取元素<br>print(r.lrange(“list_name”,0,-1))<br>ltrim(name, start, end)</p>
<p>#移除列表内没有在该索引之内的值<br>r.ltrim(“list_name”,0,2)<br>rpoplpush(src, dst)</p>
<h1 id="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"><a href="#从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边" class="headerlink" title="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"></a>从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</h1><p>#src 要取数据的列表</p>
<p>#dst 要添加数据的列表<br>brpoplpush(src, dst, timeout=0)</p>
<p>#同rpoplpush，多了个timeout, timeout：取数据的列表没元素后的阻塞时间，0为一直阻塞<br>r.brpoplpush(“list_name”,”list_name1”,timeout=0)<br>blpop(keys, timeout)</p>
<p>复制代码</p>
<p>#将多个列表排列,按照从左到右去移除各个列表内的元素<br>r.lpush(“list_name”,3,4,5)<br>r.lpush(“list_name1”,3,4,5)</p>
<p>while True:<br>    print(r.blpop([“list_name”,”list_name1”],timeout=0))<br>    print(r.lrange(“list_name”,0,-1),r.lrange(“list_name1”,0,-1))</p>
<p>‘’’keys: redis的name的集合<br>   timeout: 超时时间，获取完所有列表的元素之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞’’’<br>复制代码<br>r.brpop(keys, timeout)</p>
<p>#同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素</p>
<p>4、Set 操作</p>
<p>Set集合就是不允许重复的列表</p>
<p>sadd(name,values)</p>
<p>#给name对应的集合中添加元素<br>r.sadd(“set_name”,”aa”)<br>r.sadd(“set_name”,”aa”,”bb”)<br>smembers(name)</p>
<p>#获取name对应的集合的所有成员<br>scard(name)</p>
<p>#获取name对应的集合中的元素个数<br>r.scard(“set_name”)<br>sdiff(keys, *args)</p>
<p>#在第一个name对应的集合中且不在其他name对应的集合的元素集合<br>r.sadd(“set_name”,”aa”,”bb”)<br>r.sadd(“set_name1”,”bb”,”cc”)<br>r.sadd(“set_name2”,”bb”,”cc”,”dd”)</p>
<p>print(r.sdiff(“set_name”,”set_name1”,”set_name2”))#输出:｛aa｝<br>sdiffstore(dest, keys, *args)</p>
<p>#相当于把sdiff获取的值加入到dest对应的集合中<br>sinter(keys, *args)</p>
<h1 id="获取多个name对应集合的并集"><a href="#获取多个name对应集合的并集" class="headerlink" title="获取多个name对应集合的并集"></a>获取多个name对应集合的并集</h1><p>r.sadd(“set_name”,”aa”,”bb”)<br>r.sadd(“set_name1”,”bb”,”cc”)<br>r.sadd(“set_name2”,”bb”,”cc”,”dd”)</p>
<p>print(r.sinter(“set_name”,”set_name1”,”set_name2”))#输出:｛bb｝<br>sinterstore(dest, keys, *args)</p>
<p>#获取多个name对应集合的并集，再讲其加入到dest对应的集合中<br>sismember(name, value)</p>
<p>#检查value是否是name对应的集合内的元素<br>smove(src, dst, value)</p>
<p>#将某个元素从一个集合中移动到另外一个集合<br>spop(name)</p>
<p>#从集合的右侧移除一个元素，并将其返回<br>srandmember(name, numbers)</p>
<h1 id="从name对应的集合中随机获取numbers个元素"><a href="#从name对应的集合中随机获取numbers个元素" class="headerlink" title="从name对应的集合中随机获取numbers个元素"></a>从name对应的集合中随机获取numbers个元素</h1><p>print(r.srandmember(“set_name2”,2))<br>srem(name, values)</p>
<p>#删除name对应的集合中的某些值<br>print(r.srem(“set_name2”,”bb”,”dd”))<br>sunion(keys, *args)</p>
<p>#获取多个name对应的集合的并集<br>r.sunion(“set_name”,”set_name1”,”set_name2”)<br>sunionstore(dest,keys, *args)</p>
<p>#获取多个name对应的集合的并集，并将结果保存到dest对应的集合中<br>有序集合：</p>
<p>　　在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</p>
<p>zadd(name, *args, **kwargs)</p>
<h1 id="在name对应的有序集合中添加元素"><a href="#在name对应的有序集合中添加元素" class="headerlink" title="在name对应的有序集合中添加元素"></a>在name对应的有序集合中添加元素</h1><p>r.zadd(“zset_name”, “a1”, 6, “a2”, 2,”a3”,5)</p>
<p>#或<br>r.zadd(‘zset_name1’, b1=10, b2=5)<br>zcard(name)</p>
<p>#获取有序集合内元素的数量<br>zcount(name, min, max)</p>
<p>#获取有序集合中分数在[min,max]之间的个数<br>print(r.zcount(“zset_name”,1,5))<br>zincrby(name, value, amount)</p>
<p>#自增有序集合内value对应的分数<br>r.zincrby(“zset_name”,”a1”,amount=2)#自增zset_name对应的有序集合里a1对应的分数<br>zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)</p>
<p>复制代码</p>
<h1 id="按照索引范围获取name对应的有序集合的元素"><a href="#按照索引范围获取name对应的有序集合的元素" class="headerlink" title="按照索引范围获取name对应的有序集合的元素"></a>按照索引范围获取name对应的有序集合的元素</h1><p>aa=r.zrange(“zset_name”,0,1,desc=False,withscores=True,score_cast_func=int)<br>print(aa)<br>‘’’参数：<br>    name    redis的name<br>    start   有序集合索引起始位置<br>    end     有序集合索引结束位置<br>    desc    排序规则，默认按照分数从小到大排序<br>    withscores  是否获取元素的分数，默认只获取元素的值<br>    score_cast_func 对分数进行数据转换的函数’’’<br>复制代码<br>zrevrange(name, start, end, withscores=False, score_cast_func=float)</p>
<p>#同zrange，集合是从大到小排序的<br>zrank(name, value)、zrevrank(name, value)</p>
<p>#获取value值在name对应的有序集合中的排行位置（从0开始）<br>print(r.zrank(“zset_name”, “a2”))</p>
<p>print(r.zrevrank(“zset_name”, “a2”))#从大到小排序<br>zscore(name, value)</p>
<p>#获取name对应有序集合中 value 对应的分数<br>print(r.zscore(“zset_name”,”a1”))<br>zrem(name, values)</p>
<p>#删除name对应的有序集合中值是values的成员<br>r.zrem(“zset_name”,”a1”,”a2”)<br>zremrangebyrank(name, min, max)</p>
<p>#根据排行范围删除<br>zremrangebyscore(name, min, max)</p>
<p>#根据分数范围删除<br>zinterstore(dest, keys, aggregate=None)</p>
<p>复制代码<br>r.zadd(“zset_name”, “a1”, 6, “a2”, 2,”a3”,5)<br>r.zadd(‘zset_name1’, a1=7,b1=10, b2=5)</p>
<h1 id="获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作"><a href="#获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作" class="headerlink" title="获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作"></a>获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作</h1><h1 id="aggregate的值为-SUM-MIN-MAX"><a href="#aggregate的值为-SUM-MIN-MAX" class="headerlink" title="aggregate的值为: SUM  MIN  MAX"></a>aggregate的值为: SUM  MIN  MAX</h1><p>r.zinterstore(“zset_name2”,(“zset_name1”,”zset_name”),aggregate=”MAX”)<br>print(r.zscan(“zset_name2”))<br>复制代码<br>zunionstore(dest, keys, aggregate=None)</p>
<p>#获取两个有序集合的并集并放入dest集合，其他同zinterstore，<br>其他常用操作</p>
<p>delete(*names)</p>
<p>#根据name删除redis中的任意数据类型<br>exists(name)</p>
<p>#检测redis的name是否存在<br>keys(pattern=’*’)</p>
<p>#根据* ？等通配符匹配获取redis的name<br>expire(name ,time)</p>
<h1 id="为某个name设置超时时间"><a href="#为某个name设置超时时间" class="headerlink" title="为某个name设置超时时间"></a>为某个name设置超时时间</h1><p>rename(src, dst)</p>
<h1 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h1><p>move(name, db))</p>
<h1 id="将redis的某个值移动到指定的db下"><a href="#将redis的某个值移动到指定的db下" class="headerlink" title="将redis的某个值移动到指定的db下"></a>将redis的某个值移动到指定的db下</h1><p>randomkey()</p>
<p>#随机获取一个redis的name（不删除）<br>type(name)</p>
<h1 id="获取name对应值的类型"><a href="#获取name对应值的类型" class="headerlink" title="获取name对应值的类型"></a>获取name对应值的类型</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/18/Django论坛搭建完整版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/18/Django论坛搭建完整版/" itemprop="url">Django论坛搭建完整版</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-18T15:19:20+08:00">
                2018-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web框架/" itemprop="url" rel="index">
                    <span itemprop="name">web框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,340 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目准备<br>1 linux环境（window下可以安装虚拟机或者venv）<br>2 Django安装，使用pip install django==1.11.8</p>
<h1 id="创建第一个项目"><a href="#创建第一个项目" class="headerlink" title="创建第一个项目"></a>创建第一个项目</h1><p>创建一个用于保存自己项目的目录，打开该目录下的命令行，运行如下指令：</p>
<p><strong>django-admin startproject myproject</strong><br>执行完之后没有任何改变，那么就是对了，执行cd myproject指令就可以进入到项目目录下，后面默认的指令都是在此目录下执行。</p>
<p>在该目录下就会出现如下目录结构<br>myproject/<br>|- - myproject/<br>| |- - myproject/<br>| | |- - <strong>init</strong>.py<br>| | |- - settings.py<br>| | |- - urls.py<br>| | |- - wsgi.py<br>| +- - manage.py</p>
<ul>
<li>manage.py：使用django-admin命令行工具的快捷方式。它用于运行与我们项目相关的管理命令。我们将使用它来运行开发服务器，运行测试，创建迁移等等。</li>
<li><strong>init</strong>.py：这个空文件告诉python这个文件夹是一个python包。</li>
<li>settings.py：这个文件包含了所有的项目配置。将来我们会一直提到这个文件！</li>
<li>urls.py：这个文件负责映射我们项目中的路由和路径。例如，如果你想在访问URL / about/ 时显示某些内容，则必须先在这里做映射关系。</li>
<li>wsgi.py：该文件是用于部署的简单网关接口。你可以暂且先不用关心她的内容，就先让他在那里就好了。</li>
</ul>
<p>现在我们先不修改任何，试着运行一下该程序，进入到外层的myproject目录使用命令<strong> python3 manage.py runserver</strong>,程序正常情况下是可以运行的，此时我们去浏览器网址栏输入<a href="http://127.0.0.1:8000，就会出现如下提示信息，代表第一个项目成功了。" target="_blank" rel="noopener">http://127.0.0.1:8000，就会出现如下提示信息，代表第一个项目成功了。</a></p>
<pre><code>It worked!
Congratulations on your first Django-powered page.

Next, start your first app by running python manage.py startapp [app_label].

You&apos;re seeing this message because you have DEBUG = True in your Django settings file and you haven&apos;t configured any URLs. Get to work!
</code></pre><h1 id="创建第一个应用"><a href="#创建第一个应用" class="headerlink" title="创建第一个应用"></a>创建第一个应用</h1><h2 id="应用是什么？"><a href="#应用是什么？" class="headerlink" title="应用是什么？"></a>应用是什么？</h2><p>举例来说明一下项目和应用的关系，项目就是网易新闻的主程序，新闻里面还分了很多不同的种类，比如体育 财经 八卦等，这些不同的模块，彼此之间是会存在很大的差异，在进行维护的时候，一般都会将彼此分开进行管理。所以体育 财经 八卦等模块多少一个个的应用。</p>
<h2 id="应用可以做什么？"><a href="#应用可以做什么？" class="headerlink" title="应用可以做什么？"></a>应用可以做什么？</h2><p>1 应用可以处理相同类型的请求，比如sports类型的链接都是关于体育的,funs类型的链接都是关于娱乐八卦的<br>2 一个应用可以定义自己的主题模板，能够更加快速的编写内容<br>3 应用能够将对整体项目进行分开处理，使得整体的代码维护更加方便。</p>
<h2 id="如何创建应用"><a href="#如何创建应用" class="headerlink" title="如何创建应用"></a>如何创建应用</h2><p>使用指令<strong> djanog-admin startapp boards</strong> 这里使用的是startapp指令，此时目录结构如下：</p>
<pre><code>myproject/
|- - myproject/
| |- - boards/
| | |- - migrations/
| | | +- - __init__.py
| | |- - __init__.py
| | |- - admin.py
| | |- - apps.py
| | |- - models.py
| | |- - tests.py
| | +- - views.py
| |- - myproject/
| | |- - __init__.py
| | |- - settings.py
| | |- - urls.py
| | |- - wsgi.py
| +- - manage.py
</code></pre><p>具体功能请参照我的另外一篇文章的4.2.3章节 <a href="https://qixinyue.github.io/2018/08/17/Django%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">应用的结构组成</a> </p>
<h2 id="如何让应用生效"><a href="#如何让应用生效" class="headerlink" title="如何让应用生效"></a>如何让应用生效</h2><p>1 打开settings.py，ctrl+f搜索找到INSTALLED_APPS，在列表里面添加刚刚添加的应用的名称，我们刚刚的应用名为boards,那么在下面添加即可</p>
<p>INSTALLED_APPS = [<br>    ‘django.contrib.admin’,<br>    ‘django.contrib.auth’,<br>    ‘django.contrib.contenttypes’,<br>    ‘django.contrib.sessions’,<br>    ‘django.contrib.messages’,<br>    ‘django.contrib.staticfiles’,</p>
<pre><code>&apos;boards&apos;,  #加上逗号&apos;,&apos;吧，避免后面添加，忘了这里，造成错误的情况
</code></pre><p>]</p>
<p>2 进入到</p>
<pre><code>myproject/
    |- - myproject/
    | |- - boards/
</code></pre><p>，（无则新建，有则）打开一个名为views.py的文件，当然名字最好就是这个，业内通用的。 在文件内<strong>添加</strong>如下代码</p>
<pre><code>from django.http import HttpResponse

def boards(request):
    return HttpResponse(&apos;hello ,this is boards app!&apos;)
</code></pre><p>3 告诉Django我们创建了这么一个视图，但是还需要填写什么时候调用。 前往myproject/myproject/urls.py中，添加如下代码：<br><strong>from boards import views</strong>  和  <strong>url(r’^boards$’, views.boards, name=’boards’),</strong><br>此时该文件中的内容为</p>
<pre><code>from django.conf.urls import url
from django.contrib import admin


from boards import views

urlpatterns = [
    url(r&apos;^admin/&apos;, admin.site.urls),
    url(r&apos;^boards$&apos;, views.boards, name=&apos;boards&apos;),
]
</code></pre><p>然后在myproject目录下运行指令 python3 manage.py runserver,打开浏览器，输入网站 <a href="http://127.0.0.1:8000/boards" target="_blank" rel="noopener">http://127.0.0.1:8000/boards</a> ，结果显示为</p>
<pre><code>hello ,this is boards app!
</code></pre><p>如果没有成功的，好好检查一下是否拼写错误，或者直接此处代码。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> 好了，我们的第一个应用就这样可以根据自己心意修改内容展示在浏览器中了。</p>
<hr>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>模型是什么？<br>模型是根据数据库中的表创建出来的class（类）</p>
<p>模型的作用是什么？<br>模块可以让我们快速的操作数据库中的数据，而不是通过负责的数据库操作语言才能进行数据库的CRUD操作。</p>
<h2 id="如何使用模型操作"><a href="#如何使用模型操作" class="headerlink" title="如何使用模型操作"></a>如何使用模型操作</h2><p>我们创建的是一个论坛系统，那么肯定是需要有话题的模块了，是讨论C语言的还是讨论python的，这个使用board来表示。<br>另外肯定还要有论题了，这里叫做topic吧，需要有内容，最新更新时间，属于哪个模块的，发起者是谁等信息，后面根据需要进行扩充。<br>有人发起话题，自然需要有人评论吧，不然毫无意义了，所以需要一个评论类，这里用post来表示。<br>用户信息，可以通过admin来进行管理，所以不需要在models.py中单独建立一个类来处理。</p>
<p>修改boards/models.py文件，<strong>增加</strong>如下内容</p>
<pre><code>from django.contrib.auth.models import User


class Board(models.Model):
    name = models.CharField(max_length=30, unique=True)
    description = models.CharField(max_length=100)


class Topic(models.Model):
    subject = models.CharField(max_length=255)
    last_updated = models.DateTimeField(auto_now_add=True)
    board = models.ForeignKey(Board, related_name=&apos;topics&apos;)
    starter = models.ForeignKey(User, related_name=&apos;topics&apos;)


class Post(models.Model):
    message = models.TextField(max_length=4000)
    topic = models.ForeignKey(Topic, related_name=&apos;posts&apos;)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(null=True)
    created_by = models.ForeignKey(User, related_name=&apos;posts&apos;)
    updated_by = models.ForeignKey(User, null=True, related_name=&apos;+&apos;)
</code></pre><p>如果这段代码不是很懂的，可以Django框架找答案。</p>
<h2 id="模型中的类怎么映射到数据库"><a href="#模型中的类怎么映射到数据库" class="headerlink" title="模型中的类怎么映射到数据库"></a>模型中的类怎么映射到数据库</h2><p>通过迁移模型来实现模型到数据库的迁移。<br>执行指令： <strong>python3 manage.py makemigrations</strong> 之后运行指令<strong> python3 manage.py migrate</strong><br>命令行都是现实的OK，则表示迁移成功。</p>
<p><strong>这里可能有人会好奇，我们的类是迁移到哪个数据库，我怎么知道是否迁移成功了。</strong><br>这里告诉你答案，在myproject/myproject/settings.py文件中，有一段内容如下：</p>
<pre><code>DATABASES = {
    &apos;default&apos;: {
        &apos;ENGINE&apos;: &apos;django.db.backends.sqlite3&apos;,
        &apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;),
    }
}
</code></pre><p>这就代表了，django默认的数据库使用的sqlite3数据库，如果你的环境里面可以操作sqlite3，则你可以进入到该环境下进行查看是否有迁移的3张表。</p>
<p><strong>如果没有sqlite3的环境，怎么知晓自己是否迁移成功，数据库中的表是否正确呢？</strong><br>不用担心，执行 <strong>python3 manage.py shell</strong> 从而进入到shell环境。<br>我们先导入Board类，执行如下指<strong>令 from boards.models import Board</strong><br>然后为board创建对象，执行指令<br><strong>board = Board(name=’Python’,description=’python is the best programming language.’)</strong><br>然后保存数据到数据库<br><strong>board.save()</strong><br>然后检查一下我们的数据库中是否有刚刚保存的数据，方法如下：<br><strong>board.name</strong><br>查询到的结果为<em>Python</em><br>查询描述信息 board.description<br>查询到的结果为 python is the best programming language.</p>
<p>到此为止，模型中的数据迁移和查看迁移结果都完成了。</p>
<hr>
<h2 id="数据库中的数据操作"><a href="#数据库中的数据操作" class="headerlink" title="数据库中的数据操作"></a>数据库中的数据操作</h2><p>每个Django模型中都自带一个特殊的属性，称之为模型管理器(Model Manager).可以通过objects属性来访问这个管理器，它主要用于数据库操作。<br>以下是具体操作和运行结果</p>
<pre><code>board = Board.objects.create(name=&apos;Java&apos;,description=&apos;programming language NO1.&apos;)

board.id
2

board.name
&apos;Java&apos;

Board.objects.all()
&lt;QuerySet [&lt;Board: Board object&gt;, &lt;Board: Board object&gt;]&gt;
</code></pre><p>最后指令的结果是一个<strong>QuerySet</strong>，是一种对象列表的类型（但不是列表），但是有没有觉得这个结果很别扭呢，是的，就是我怎么知道结果是说的啥呢，都长的一样，要是来成百上千个，眼睛不得看花了，所以，需要告诉数据库，我们希望查询的时候显示什么。<br><strong>怎么做到显示需要的信息？</strong><br>进入到models.py文件中，<strong>增加</strong>一个函数，</p>
<pre><code>def __str__(self):
    return self.name
</code></pre><p>该函数告诉数据库，在查询的时候显示的是该模块的名字而不是具体描述信息。<br>再次执行shell指令，查看一下结果，看看有没有变化吧。</p>
<p><strong>QuerySet</strong>，是一种对象列表的类型，需要怎么遍历里面的内容呢？</p>
<pre><code>boards_list = Board.objects.all()
for board in boards_list:
    print(board.description)
</code></pre><p>另外有一个get()方法需要提一下，<strong>board = Board.objects.get(id=3)</strong> 这条指令是查询id=3的信息，但是目前数据库中没有id=3的信息，因此会报错，而且，如果是类似于这样一条指令 <strong>student = Student.objects.get(age=20)</strong> 那么这条指令因为有多个条件满足20岁，也会出现报错。<strong>只能在有且只有一个结果的时候才会正确返回结果，否则一律报错。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/Django框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/Django框架/" itemprop="url">Django框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T19:52:45+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web框架/" itemprop="url" rel="index">
                    <span itemprop="name">web框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,684 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前情知识"><a href="#前情知识" class="headerlink" title="前情知识"></a>前情知识</h1><ul>
<li><p>jQuery-事件</p>
<pre><code>1、事件对象 - event
    在绑定事件的时候，允许传递 event 参数来表示事件对象

    1、
        $obj.bind(&quot;click&quot;,function(event){
            //event 表示的就是事件对象
        });
    2、
        $obj.click(function(event){
            //event 表示的就是事件对象
        });
2、事件冒泡
    1、什么是事件冒泡
        在执行子元素的事件时，同时把父元素/祖先元素的对应的事件也给执行了
    2、阻止事件冒泡
        event.stopPropagation()
</code></pre></li>
<li><p>jQuery-动画</p>
</li>
</ul>
<pre><code>1、基本显示 / 隐藏
    语法：
        $obj.show() / $obj.show(执行时间)
        $obj.hide() / $obj.hide(执行时间)
2、滑动式显示 / 隐藏
    语法：
        显示:$obj.slideDown() / $obj.slideDown(执行时间)
        隐藏:$obj.slideUp() / $obj.slideUp(执行时间)
3、淡入淡出式显示 / 隐藏
    语法：
        显示:$obj.fadeIn() / $obj.fadeIn(执行时间)
        隐藏:$obj.fadeOut() / $obj.fadeOut(执行时间)
</code></pre><ul>
<li>jQuery-插件</li>
</ul>
<p>====================================================<br>静态网站：无法与服务器进行交互<br>动态网站：允许与服务器进行交互</p>
<h1 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h1><h2 id="WEB-与-服务器"><a href="#WEB-与-服务器" class="headerlink" title="WEB 与 服务器"></a>WEB 与 服务器</h2><p>1 WEB ：表示用户可以浏览的网页(HTML,CSS,JS)</p>
<p>2 服务器:能够给用户提供服务的机器</p>
<ul>
<li><p>硬件 与 软件</p>
<p>  硬件范畴：一台计算机<br>  软件范畴：一个能够接收用户请求并给出响应的程序</p>
<pre><code>1、APACHE
2、TOMCAT
3、IIS(Internet Information Service)
4、Nginx
</code></pre></li>
<li><p>作用</p>
<p>  1、存储WEB所需要的信息(HTML，图片，音频)<br>  2、能够处理用户的请求(request)并给出响应(response)<br>  3、执行服务器端的程序</p>
</li>
<li><p>WEB 与 服务器之间的关系</p>
</li>
</ul>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>1 什么是框架</p>
<p>框架是一个为了解决开放性问题而存在的一种结构。框架本身提供了一些最基本的功能。我们需要在基本的功能基础上开发属于自己的操作即可。</p>
<p>2 Python中的框架(WEB)</p>
<pre><code>1、Django ：重量级的WEB框架
2、Tornado ：异步框架
3、Flask ：轻量级框架
    ... ...
</code></pre><h2 id="Django-框架"><a href="#Django-框架" class="headerlink" title="Django 框架"></a>Django 框架</h2><h3 id="什么是Django"><a href="#什么是Django" class="headerlink" title="什么是Django"></a>什么是Django</h3><p>是一个开源框架，2005年发布，采用Python语言开发。早期是做新闻以及内容管理的网站。提供了强大的后台管理系统。</p>
<h3 id="Django的框架模式-MTV"><a href="#Django的框架模式-MTV" class="headerlink" title="Django的框架模式 - MTV"></a>Django的框架模式 - MTV</h3><p>M ：Models 层<br>    模型层，负责数据库的建模以及CRUD的操作</p>
<p>T ：Templates 层<br>    模板层，用于处理用户显示的内容的。如：html</p>
<p>V ：Views 层<br>    视图层，处理与用户交互的部分内容，从模型中获取数据再将数据发送给模板，最终再将模板显示给用户</p>
<p>自行了解：MVC - Flask采用该方法，参见本站 Flask框架<br>M ：Models 模型层<br>    负责数据库的建模以及CRUD的操作<br>V ：Views 视图层<br>    处理用户显示的内容 。如：html<br>C ：Controller 控制器<br>    处理与用户交互的部分内容。接收请求，处理请求并响应结果给客户端</p>
<p>MTV       MVC<br>M  —–  M<br>T  —–  V<br>V  —–  C</p>
<h2 id="Django-框架的使用"><a href="#Django-框架的使用" class="headerlink" title="Django 框架的使用"></a>Django 框架的使用</h2><h3 id="Django的安装"><a href="#Django的安装" class="headerlink" title="Django的安装"></a>Django的安装</h3><p>1、查看已安装的Django版本</p>
<pre><code>1、进入到终端以及python的交互模式
    python3 / ipython3
2、在交互模式中 输入 import django
    如果未报错：说明已经安装了Django
    如果报错：说明未安装Django
3、查看已安装的版本
    交互模式中：django.VERSION
</code></pre><p>2、安装</p>
<pre><code>1、在线安装 - 使用 pip / pip3
    pip : 安装到python2.7下
    pip3 : 安装到python3.5下

    1、sudo pip3 install django
        (默认安装Django的最高版本)
    2、sudo pip3 install django==1.11.8
        (指定安装1.11.8版本)

2、离线安装
    1、下载所需的Django包
        Django官网
        http://www.djangoproject.com
    2、在环境中解压Django包
        tar -xvf Django-1.11.8.tar.gz
    3、进入到目录中
        cd Django-1.11.8
    4、安装
        sudo python3 setup.py install
</code></pre><h3 id="Django文档"><a href="#Django文档" class="headerlink" title="Django文档"></a>Django文档</h3><p>1、Django官网<br>    <a href="http://www.djangoproject.com" target="_blank" rel="noopener">http://www.djangoproject.com</a><br>2、DjangoBook<br>    <a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="noopener">http://djangobook.py3k.cn/2.0/</a><br>3、离线文档</p>
<h3 id="使用Django"><a href="#使用Django" class="headerlink" title="使用Django"></a>使用Django</h3><p>1、创建目录 ：用于保存Django项目<br>    mkdir Django<br>    (准备工作)</p>
<p>2、创建Django项目</p>
<pre><code>使用 django-admin 指令 创建Django项目

django-admin startproject 项目名
</code></pre><p>3、启动服务，访问网站</p>
<pre><code>在创建好的项目中，找到 manage.py 文件
通过 manage.py启动服务

python3 manage.py runserver

访问地址：
    http://127.0.0.1:8000/
    http://localhost:8000/
</code></pre><p>4、Django的项目结构介绍</p>
<ul>
<li><p>manage.py 负责执行django中的各项操作的文件<br>如：</p>
<p>  启动服务<br>  创建应用<br>  数据库的同步操作<br>  创建后台超级管理员</p>
</li>
</ul>
<p>使用方式：</p>
<pre><code>方法1、python3 manage.py 子命令
方法2、./manage.py 子命令
</code></pre><ul>
<li><p>主文件夹(名称与项目名称相同)</p>
<p>  1、<strong>init</strong>.py</p>
<pre><code>项目初始化文件，每当服务器启动的时候，自动执行
</code></pre><p>  2、urls.py</p>
<pre><code>项目的基础路由配置文件/主路由配置文件
将请求地址映射到对应的视图上
</code></pre><p>  3、wsgi.py</p>
<pre><code>应用服务器的配置文件，暂时不用
</code></pre><p>  4、settings.py</p>
<pre><code>项目的主设置文件：模板，数据库，应用，...

1、BASE_DIR:当前项目所在的绝对路径
    /home/tarena/Django/netease

2、DEBUG:调试模式
    开发过程：推荐使用True
    上线运行：必须改为False

3、ALLOWED_HOSTS
    设置允许访问本项目的地址列表
    如果不设置的话，只有本机(127.0.0.1/localhost)能够访问

    推荐写&apos;*&apos;,任何表示该机器的地址都可以访问当前项目

    注意：如果允许被外部机器访问的话，则：
        ./manage.py runserver 0.0.0.0:8000s

4、INSTALLED_APPS
    指定已安装的应用，如果有自定义应用的话，需要在此注册

5、ROOT_URLCONF  暂时不管

6、TEMPLATES:指定模板的信息

7、DATABASES:指定数据库的信息

8、LANGUAGE_CODE:指定项目语言，允许修改为zh-Hans (简体中文)

9、TIME_ZONE:指定时区，建议修改为 Asia/Shanghai
</code></pre></li>
</ul>
<h1 id="URL的使用"><a href="#URL的使用" class="headerlink" title="URL的使用"></a>URL的使用</h1><h2 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h2><pre><code>默认是在主目录中的，主路由配置文件，包含所有的地址映射

每一个请求到达之后，都会由urls.py中的urlpatterns列表中的url()进行匹配。当url()匹配上之后，可能就会将请求转交给其他的视图(Views)或其他的urls.py去处理
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在主目录中，创建 views.py<br>作用：包含所有定义好的视图(处理程序)</p>
<h2 id="url函数详解"><a href="#url函数详解" class="headerlink" title="url函数详解"></a>url函数详解</h2><h3 id="url函数的语法"><a href="#url函数的语法" class="headerlink" title="url函数的语法"></a>url函数的语法</h3><p>url(regex,views,kwargs=None,name=None)</p>
<p>1、regex<br>    正则表达式模式，匹配请求的url，字符串类型</p>
<p>2、views<br>    当前url对应的处理的视图函数，此处写函数名即可</p>
<p>3、kwargs<br>    字典，用来向views传参的，如果没有参数可以省略</p>
<p>4、name<br>    字符串，给url()起别名，方便在模板中使用</p>
<h3 id="通过-url-向-views-传参"><a href="#通过-url-向-views-传参" class="headerlink" title="通过 url 向 views 传参"></a>通过 url 向 views 传参</h3><p>1 使用正则表达式子组传参</p>
<p>使用子组传参 - ()，一个子组是一个参数，如果想传递多个参数的话，则使用多个子组，多个参数之间使用 / 分割</p>
<pre><code>urlpatterns = [
    # 访问路径是 run/ ，交给 run_views
    url(r&apos;^run/$&apos;,run_views),
    # 访问路径是 run/两位数字，交给run_arg1_views
    url(r&apos;^run/(\d{2})/$&apos;,run_arg1_views),
    # 访问路径是 run/两位数字/四位数字，交给run_arg2_views
    url(r&apos;^run/(\d{2})/(\d{4})&apos;,run_arg2_views),
]
</code></pre><p>注意：</p>
<pre><code>1、在 url() 中，一个子组表示一个参数
2、在 views.py 中，对应的处理函数要根据url()中子组的个数，相应的定义参数(形参)。定义的参数要位于request之后

url(r&apos;^run/(\d{2})/(\d{4})&apos;,run_arg2_views)

def run_arg2_views(request,num1,num2):
    pass
</code></pre><p>2 使用url()第三个参数，字典传参</p>
<pre><code>urlpatterns = [
    url(
        r&apos;^show/$&apos;,
        show_views,
        {&apos;name&apos;:&apos;zsf&apos;,&apos;age&apos;:&apos;25&apos;}
    )
]

def show_views(request,name,age):
        pass
</code></pre><h1 id="Django中的应用"><a href="#Django中的应用" class="headerlink" title="Django中的应用"></a>Django中的应用</h1><h2 id="什么是应用"><a href="#什么是应用" class="headerlink" title="什么是应用"></a>什么是应用</h2><pre><code>应用就是网站中的一块独立的程序
在Django中，主目录一般不处理用户的具体请求，主要做的是项目的初始化以及请求的分发
</code></pre><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><h3 id="通过-指令-创建应用"><a href="#通过-指令-创建应用" class="headerlink" title="通过 指令 创建应用"></a>通过 指令 创建应用</h3><pre><code>./manage.py startapp 应用名称
ex:
    ./manage.py startapp news
</code></pre><h3 id="在-settings-py-中注册应用"><a href="#在-settings-py-中注册应用" class="headerlink" title="在 settings.py 中注册应用"></a>在 settings.py 中注册应用</h3><pre><code>在 INSTALLED_APPS 中追加应用名称
INSTALLED_APPS = [
    &apos;django.contrib.admin&apos;,
    ... ...
    &apos;news&apos;
]
</code></pre><h3 id="应用的结构组成"><a href="#应用的结构组成" class="headerlink" title="应用的结构组成"></a>应用的结构组成</h3><p>1、migrations 目录<br>    存放数据库中间文件的目录(日志文件)</p>
<p>2、<strong>init</strong>.py<br>    应用的初始化文件</p>
<p>3、admin.py<br>    应用的后台管理配置文件</p>
<p>4、apps.py<br>    应用的属性配置文件</p>
<p>5、models.py<br>    模型配置文件</p>
<p>6、tests.py<br>    测试模块</p>
<p>7、views.py<br>    视图处理文件</p>
<pre><code>练习：
    1、创建 index 应用，并注册
    2、创建 sport 应用，并注册
    3、创建 music 应用，并注册
</code></pre><h3 id="应用中的-urls"><a href="#应用中的-urls" class="headerlink" title="应用中的 urls"></a>应用中的 urls</h3><pre><code>练习
    1、访问 http://localhost:8000/news/index
        交给news应用中的urls处理(找 index_views视图)
    2、访问 http://localhost:8000/music/index
        交给music应用中的urls处理(找index_views视图)
    3、访问 http://localhost:8000/sport/index
        交给sport应用中的urls处理(找index_views视图)
    4、访问 http://localhost:8000
        交给index应用中的urls处理(找index_views视图)
    5、访问 http://localhost:8000/login
        交给index应用中的urls处理(找login_views视图)
    6、访问 http://localhost:8000/register
        交给index应用中的urls处理(找regsiter_views视图)
    7、访问 http://localhost:8000/news/
        交给news应用中的urls处理(找 index_views视图)
    8、访问 http://localhost:8000/music/
        交给music应用中的urls处理(找 index_views视图)
    9、访问 http://localhost:8000/sport/
        交给sport应用中的urls处理(找 index_views视图)
</code></pre><h1 id="Django中的模板-Tempates"><a href="#Django中的模板-Tempates" class="headerlink" title="Django中的模板(Tempates)"></a>Django中的模板(Tempates)</h1><h2 id="什么是模板"><a href="#什么是模板" class="headerlink" title="什么是模板"></a>什么是模板</h2><p>模板是要动态给用户呈现的网页<br>模板就是一个网页 - 前后端结合的网页<br>模板是通过视图(Views)呈现给用户的</p>
<h2 id="模板的设置"><a href="#模板的设置" class="headerlink" title="模板的设置"></a>模板的设置</h2><p>在 settings.py 中 TEMPLATES 变量 进行模板的设置</p>
<pre><code>TEMPLATES = [
    {
        &apos;BACKEND&apos;:&apos;... ...&apos;,
        &apos;DIRS&apos;:[],
        ... ...
    }
]
</code></pre><p>1、BACKEND：指定模板的搜索引擎，不用改动<br>2、DIRS：指定模板所存放的目录们<br>    DIRS : [‘index.temp’,’news.temp’,…]<br>    但是，如果DIRS中内容为空的话，那么Django会自动的到每个应用下去搜索一个叫 templates 的目录作为模板的存放目录。<br>    推荐：<br>        1、DIRS内容为空<br>        2、在每个应用中，创建一个 templates 目录<br>3、APP_DIRS<br>    True:首先从DIRS中指定的目录中去查找模板，没找到的话再搜索templates目录</p>
<h2 id="模板的加载方式"><a href="#模板的加载方式" class="headerlink" title="模板的加载方式"></a>模板的加载方式</h2><p>模板的加载需要在“视图”中完成<br>1、使用 loader 获取模板，通过 HttpResponse 进行响应</p>
<pre><code>from django.template import loader
from django.http import HttpResponse

def index_views(request):
    #1、通过 loader 加载模板(得到一个模板对象)
    t = loader.get_template(&quot;模板名称&quot;)
    #2、通过模板对象t，将模板渲染成字符串
    html = t.render()
    #3、通过 HttpResponse 将html响应给客户端
    return HttpResponse(html)
</code></pre><p>2、使用 render 直接加载并返回模板</p>
<pre><code>from django.shortcuts import render

def xxx_views(request):
    return render(request,&apos;模板名称&apos;)
</code></pre><h2 id="模板的语法"><a href="#模板的语法" class="headerlink" title="模板的语法"></a>模板的语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>1、作用</p>
<p>允许将后端的数据传递给模板，在模板中，会根据变量的值进行显示</p>
<p>2、Django中允许传递给模板做变量的数据类型</p>
<p>数字，字符串，列表，元组，字典，函数，对象</p>
<p>3、变量的语法</p>
<pre><code>通过一个字典，将要传递给模板的变量封装起来
dic = {
    &apos;变量1&apos;:&apos;值1&apos;,
    &apos;变量2&apos;:&apos;值2&apos;,
}
1、使用 loader 
    t = loader.get_template(&apos;模板名称&apos;)
    html = t.render(dic)
    return HttpResponse(html)
2、使用 render
    return render(request,&apos;模板名称&apos;,dic)
</code></pre><p>4、在模板中使用变量</p>
<pre><code>使用 {{变量名}}

如果变量不存在或值为空的话，此位置不显示任何内容

练习：
    在模板中显示以下内容：
    书名：《西游记》
    作者：罗贯中
    主题：1个和尚和3个宠物的故事
</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>标签是 允许将服务器端的功能嵌入到模板中</p>
<p>语法 {\% 标签内容 \%}</p>
<p>常用标签 for 语法 {\% for 变量 in 列表|元组|字典 \%}  if 语法 {\% if 条件 \%}</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><pre><code>1、作用
    在显示变量的数据之前，允许对数据进行筛选或改变

2、过滤器的语法

    {{变量|过滤器}}

3、常用过滤器

    1、{{value|upper}}
        将value变为大写字符输出
    2、{{value|lower}}
        将value变为小写字符输出
    3、{{value|floatformat:n}}
        将value四舍五入到 n 位小数
    4、{{value|truncatechars:n}}
        将字符串截取到n位字符(包含...)
</code></pre><h3 id="url-中的name参数"><a href="#url-中的name参数" class="headerlink" title="url()中的name参数"></a>url()中的name参数</h3><pre><code>url(regex,views,kwargs=None,name=None)
    name:允许为当前的url设置别名，可以在Template中使用别名找到对应的url
语法：
    url(regex,views,name=&quot;别名&quot;)
    在模板中使用别名找到对应的url
        {% url '别名' %}
</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>1、什么是静态文件</p>
<pre><code>不与用户发生动态交互的文件，称为静态文件
如：css,js,image,audio,video,html
</code></pre><p>2、Django中静态文件的处理</p>
<pre><code>需要在settings.py中设置静态文件的访问路径 和 存储路径
1、访问路径
    STATIC_URL=&apos;/static/&apos;

    作用：
        当访问路径是 localhost:8000/static/****
        一律去静态文件存储路径中搜索静态文件
2、存储路径
    STATICFILES_DIRS=(BASE_DIR,&apos;静态目录名称&apos;)

    在项目中以及各个应用中，都可以创建对应名称一个目录，来表示项目或应用中所储存静态文件的目录
</code></pre><p>3、访问静态文件</p>
<pre><code>1、直接使用 localhost:8000/static/****
    &lt;img src=&quot;http://localhost:8000/static/***&quot;&gt;
    &lt;img src=&quot;/static/***&quot;&gt;
2、使用 {% static %}访问静态文件
    {% static %}表示的就是静态文件访问路径
    1、在模板的最顶层增加
        {% load static %}
    2、在使用静态文件时
        &lt;img src=&quot;{% static '具体路径'%}&quot;&gt;
        ex:
            &lt;img src=&quot;{% static 'images/huiyuan.jpg'%}&quot;&gt;
</code></pre><h3 id="模板的继承"><a href="#模板的继承" class="headerlink" title="模板的继承"></a>模板的继承</h3><p>1、什么是模板的继承</p>
<pre><code>当多个模板(网页)具备大部分相同的内容时，就可以使用继承的方式,
将相同的内容继承过来，再增加/修改属于自己的内容即可。
</code></pre><p>2、模板的继承的语法</p>
<pre><code>1、在父模板中
    必须要标识出来哪些内容在子模板中是允许被修改的
    标签：
        {% block 名称 %}
				父模板中要显示的内容
			{% endblock %}

        block作用：
            1、在父模板中，正常显示
            2、在子模板中，如果不修改block中的内容的话则会按照父模板中的内容进行显示

2、在子模板中
    1、在最顶层增加一个标签，来表示继承关系
        {% extends '父模板的名称' %}

    2、增加 block 标签，改写属于自己的内容
        {% block 名称 %}
				子模板中的内容
			{% endblock %}
        在子模板中的block会覆盖父模板中的同名的block的内容
</code></pre><h1 id="模型-Models"><a href="#模型-Models" class="headerlink" title="模型 - Models"></a>模型 - Models</h1><h2 id="什么是模型"><a href="#什么是模型" class="headerlink" title="什么是模型"></a>什么是模型</h2><p>模型，是根据数据库中表的结构来创建出来的class。<br>每一张表映射到编程语言中就是一个class，表中的每一个列，到编程语言中就是<br>class中的一个属性。在模型中还能完成对数据的CRUD操作</p>
<h2 id="创建-和-使用模型-ORM"><a href="#创建-和-使用模型-ORM" class="headerlink" title="创建 和 使用模型 - ORM"></a>创建 和 使用模型 - ORM</h2><h3 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h3><p>ORM：Object Relational Mapping<br>简称：ORM,O/RM,O/R Mapping<br>中文：对象关系映射</p>
<p><strong>ORM 的三大特征：</strong><br><strong>1、数据表(table) 到 类(class) 的映射</strong><br>    将数据表 自动 生成一个class类<br>    将class类 自动 生成一张表</p>
<p><strong>2、数据类型的映射</strong><br>    允许将表中字段的数据类型 自动 映射成编程语言中的对应的数据类型<br>    允许将编程语言中的数据类型 自动 英社称表中字段的数据类型</p>
<p><strong>3、关系映射</strong><br>    数据库中表的关联关系：<br>    一对一，一对多，多对多<br>    将表与表之间的关系也映射到编程语言中，通过创建类与类(对象与对象)之间的关系来完成</p>
<h3 id="ORM的优点"><a href="#ORM的优点" class="headerlink" title="ORM的优点"></a>ORM的优点</h3><p>1、 提高了开发效率，能够自动完成表到对象的映射<br>2、 不用SQL编码，也能够完成对数据的CRUD操作，可以省略庞大的数据访问层</p>
<h2 id="创建和配置数据库"><a href="#创建和配置数据库" class="headerlink" title="创建和配置数据库"></a>创建和配置数据库</h2><h3 id="创建一个数据库-支持中文"><a href="#创建一个数据库-支持中文" class="headerlink" title="创建一个数据库(支持中文)"></a>创建一个数据库(支持中文)</h3><pre><code>create database 数据库名 default charset utf8 collate utf8_general_ci;

mysql 可视化开发工具 - Navicat

创建一个数据库 - webdb
</code></pre><h3 id="Django中的数据库配置"><a href="#Django中的数据库配置" class="headerlink" title="Django中的数据库配置"></a>Django中的数据库配置</h3><p>在 settings.py 中配置数据库的信息</p>
<pre><code>DATATBASES = {
    &apos;default&apos;:{
        &apos;ENGINE&apos;:&apos;...&apos;,
        &apos;NAME&apos;:&apos;...&apos;
    }
}
</code></pre><p>连接MySQL的配置：</p>
<pre><code>1、ENGINE:引擎
    django.db.backends.mysql
2、NAME:指定要连接到的数据库的名称
3、USER:指定用户名称 ，通常为 root
4、PASSWORD:指定密码，通常为 123456
5、HOST:要连接的主机地址
    本机：localhost 或 127.0.0.1
6、PORT:指定端口号，通常为 3306
</code></pre><p>**注意：在Django中连接MySQL的话依赖于 MySQLdb</p>
<p>解决方案：**</p>
<pre><code>在 主目录中的 __init__.py 中
import pymysql
pymysql.install_as_MySQLdb()
</code></pre><h2 id="数据库的同步操作"><a href="#数据库的同步操作" class="headerlink" title="数据库的同步操作"></a>数据库的同步操作</h2><p>1、./manage.py makemigrations<br>作用：将每个应用下的 models.py 文件生成一个数据库的中间文件，并保存在migrations文件夹中</p>
<p>2、./manage.py migrate<br>作用：将每个应用下的 migratioins 文件中的中间文件同步到数据库中</p>
<h2 id="编写-Models-重点"><a href="#编写-Models-重点" class="headerlink" title="编写 Models(重点)"></a>编写 Models(重点)</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><pre><code>1、Models中的每个class都称为 模型类(Models类) 或 实体类(Entry)
    实体：就是数据表中的一条记录
    实体完整性：约束表中的记录不重复
2、Models中的每个实体类，必须要继承自 models.Model
</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>在 models.py 中 
from django.db import models
# 创建 Publisher 模型类
# 表示 出版社的信息 ，并包含以下属性
# 1. name ：表示出版社名称
# 2. address ：表示出版社的地址
# 3. city ：出版社所在城市名称
# 4. country ：出版社所在国家名称
# 5. website ：表示出版社的网址

class Publisher(models.Model):
    name=models.CharField(max_length=30)
    address=models.CharField(max_length=50)
    city=models.CharField(max_length=20)
    country=models.CharField(max_length=20)
    website=models.URLField()
</code></pre><h3 id="Django中的字段类型-和-字段选项"><a href="#Django中的字段类型-和-字段选项" class="headerlink" title="Django中的字段类型 和 字段选项"></a>Django中的字段类型 和 字段选项</h3><pre><code>语法：
    属性 = models.字段类型(字段选项1,字段选项2,...)

1、字段类型(Field Type)
    1、BooleanField()
    2、CharField()
    3、DateField()
    4、DateTimeField()
    5、DecimalField()
    6、EmailField()
    7、FloatField()
    8、ImageField() #存图片的路径 - varchar
    9、IntegerField() 
    10、URLField() #存网址 - varchar
    11、TextField() # 存大量数据 - text

2、字段选项(Field Options)
    1、max_length
        在 models.CharField() 中是必选项
        设置最大长度

    2、default
        为当前的属性指定默认值

    3、null
        指定当前的属性是否允许为空，默认为 False

    4、unique
        指定当前属性的值是否为唯一，默认为 False

    5、blank
        指定当前属性的值是否允许为空字符串，默认为 False
</code></pre><h3 id="数据的版本切换"><a href="#数据的版本切换" class="headerlink" title="数据的版本切换"></a>数据的版本切换</h3><p>1、 ./manage.py migrate 执行所有应用中最新版本的数据库中间文件<br>2、 ./manage.py migrate 应用名称 版本号</p>
<pre><code>./manage.py migrate index 0002
执行 index 应用中的 版本号为0002的中间文件
</code></pre><p>3、 通过数据库自动导出Models</p>
<pre><code>./manage.py inspectdb &gt; 文件名.py
</code></pre><h2 id="模型中的CRUD"><a href="#模型中的CRUD" class="headerlink" title="模型中的CRUD"></a>模型中的CRUD</h2><h3 id="通过ORM向DB中增加数据"><a href="#通过ORM向DB中增加数据" class="headerlink" title="通过ORM向DB中增加数据"></a>通过ORM向DB中增加数据</h3><p>1、Entry.objects.create(属性=值,属性=值,…)</p>
<pre><code>ex:
    Author.objects.create(name=&apos;zsf&apos;,age=85,email=&apos;zsf@163.com&apos;)
</code></pre><p>2、创建一个Models对象，并通过 save() 完成增加</p>
<pre><code>obj = Entry(属性=值,属性=值)
obj.save()
</code></pre><p>3、使用字典构建对象，并调用其 save() 完成增加</p>
<pre><code>dic = {
    &apos;属性1&apos;:&apos;值1&apos;,
    &apos;属性2&apos;:&apos;值2&apos;,
    ... ...
}

obj = Entry(**dic)
obj.save()
</code></pre><p>练习：<br>    使用三种方式，分别向 index_book,index_publisher 中，各增加三条数据</p>
<h3 id="查询操作-重难点"><a href="#查询操作-重难点" class="headerlink" title="查询操作(重难点)"></a>查询操作(重难点)</h3><p>通过 Entry.objects 调用查询接口</p>
<p>1、 基本查询操作</p>
<p>语法：all()<br>用法：Entry.objects.all()<br>返回：QuerySet (封装了若干对象的列表)</p>
<pre><code>ex:
    authors = Author.objects.all();
    等同于：select name,age,email from [index_author]
</code></pre><p>2、 查询指定列的操作</p>
<p>语法：values(‘列1’,’列2’)<br>用法：Entry.objects.values(‘列1’,’列2’)<br>返回：QuerySet (封装了若干字典的列表)<br>注意：values() 可以用在所有返回查询结果集的方法的后面的</p>
<pre><code>Entry.objects.all().values()
</code></pre><p>3、 指定排序效果</p>
<p>语法：order_by(‘列1’,’列2’,…)<br>默认：升序排序<br>降序：在列前加 -</p>
<pre><code>ex:
    Author.objects.order_by(&apos;age&apos;)
    Author.objects.all().order_by(&apos;age&apos;)

注意：order_by()可以用在所有返回查询结果集的方法的后面
</code></pre><p>4、 对条件取反</p>
<p>语法：exclude(条件)<br>用法：Entry.objects.exclude(属性=值,属性=值)</p>
<pre><code>ex:
    1、Author.objects.exclude(id=3)
        select * from author where not (id=3)
    2、Author.objects.exclude(id=3,age=85)
        select * from author where not (id=3 and age=85)
</code></pre><p>5、 根据条件查询部分行数据(重难点)</p>
<p>语法：filter(条件)<br>用法：Entry.objects.filter(条件)</p>
<ul>
<li><p>直接使用 Entry 中的属性作为查询条件<br>如果有多个查询条件，使用 , 隔开，映射到sql语句中，使用 and 进行关联的</p>
<pre><code>1、Author.objects.filter(id=1)
    select * from author where id=1

2、Author.objects.filter(id=1,name=&apos;韩寒&apos;)
    select * from author where id=1 and name=&apos;韩寒&apos;
</code></pre></li>
<li><p>通过 Field Lookups 完成复杂条件查询</p>
<pre><code>Field Lookup ：查询表达式 (查询谓词)
    每一个查询谓词都是一个独立的查询条件，可以用在所有的 有查询条件的位置处

1、__exact
    作用:等值判断
    用法:Entry.objects.filter(属性__exact=值)
    ex:
        Author.objects.filter(id__exact=1)
        Author.objects.filter(id=1)

2、__contains
    作用：判断属性中是否包含指定关键字
    用法：Entry.objects.filter(属性__contains=值)

3、__lt
    作用：判断属性值是否小于指定的值
    用法：Entry.objects.filter(属性__lt=值)

4、__lte
    作用：判断属性值是否小于等于指定的值

5、__gt
    作用：判断属性值是否大于指定的值

6、__gte
    作用：判断属性值是否大于等于指定的值

7、__startswith
    作用：判断属性值是以指定数值开头的数据

8、__endswith
    作用：判断属性值是以指定数值结尾的数据
    ... ...
</code></pre></li>
</ul>
<p>6、查询只返回一条记录</p>
<pre><code>语法：get()
用法：Entry.objects.get(查询条件/谓词)
注意：
    该函数只能用在查询返回一条记录时使用。如果返回多条数据 或 不返回数据时，都会报错
</code></pre><p>7、查询结果集中记录数</p>
<pre><code>语法：count()
用法：
    Entry.objects.count()
    Entry.objects.filter(条件).count()
</code></pre><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>1、 修改单个数据<br>口诀：1查2改3保存</p>
<pre><code>1、通过 get() 得到要修改的数据
2、再通过实体对象的属性修改属性值
3、最后通过实体对象的save()保存回数据库

au = Author.objects.get(id__exact=1)
au.name = &apos;罗贯中&apos;
au.age = 30
au.save()
</code></pre><p>2、 批量修改数据</p>
<pre><code>调用QuerySet的update()即可
Author.objects.filter(id__gt=1).update(属性=值,属性=值)
</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>调用实体对象/查询结果集的delete()即可<br>1、删除单个对象</p>
<pre><code>obj = Author.objects.get(id=1)
obj.delete()
</code></pre><p>2、删除多个对象(结果集)</p>
<pre><code>Author.objects.all().delete()
</code></pre><h2 id="转发-amp-重定向"><a href="#转发-amp-重定向" class="headerlink" title="转发 &amp; 重定向"></a>转发 &amp; 重定向</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>在一个视图中调用了另外一个视图，再将结果响应给浏览器<br>特点：浏览器地址栏的地址始终是第一个请求的地址</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>1、什么是重定向<br>重新向新的访问地址发送一个请求(由服务器端通知客户端)</p>
<p>2、语法</p>
<pre><code>from django.http import HttpResponseRedirect

return HttpResponseRedirect(&apos;重定向地址&apos;)
</code></pre><h2 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h2><h3 id="1、F操作-和-Q操作"><a href="#1、F操作-和-Q操作" class="headerlink" title="1、F操作 和 Q操作"></a>1、F操作 和 Q操作</h3><p>1、F()</p>
<p>更新Author表中数据，所有人的年龄+10岁</p>
<pre><code>update Author set age=age+10

Author.objects.all().update(age=age+10) # 错误
</code></pre><p>作用：用于在执行中获取某列的值<br>语法：F(‘列名’)</p>
<pre><code>from django.db.models import F
Author.objects.all().update(age=F(&apos;age&apos;)+10)
</code></pre><p>2、Q()</p>
<pre><code>Author.objects.filter(id=1,age__gte=50)
select * from Author where id=1 and age&gt;=50
</code></pre><p>作用：在查询条件中，可以完成 或(or) 的操作<br>语法：</p>
<pre><code>from django.db.models import Q
Q(条件1)|Q(条件2)

Author.objects.filter(Q(id=1)|Q(age__gte=50))
select * from Author where id=1 or age &gt;= 50
</code></pre><h3 id="2、原生的数据库操作方法"><a href="#2、原生的数据库操作方法" class="headerlink" title="2、原生的数据库操作方法"></a>2、原生的数据库操作方法</h3><p>1、查询</p>
<pre><code>函数：raw(sql语句)
语法：Entry.objects.raw(sql语句)
返回：QuerySet
</code></pre><p>2、增删改</p>
<pre><code>def doSQL(request):
    with connection.cursor() as cursor:
        sql = &apos;delete from Author&apos;
        cursor.execute(sql)
        return ... ...;
</code></pre><h2 id="使用后台管理Models"><a href="#使用后台管理Models" class="headerlink" title="使用后台管理Models"></a>使用后台管理Models</h2><h3 id="1、后台的配置"><a href="#1、后台的配置" class="headerlink" title="1、后台的配置"></a>1、后台的配置</h3><p>登录地址：<a href="http://localhost:8000/admin" target="_blank" rel="noopener">http://localhost:8000/admin</a></p>
<p>创建后台管理员：</p>
<pre><code>./manage.py createsuperuser
Username:输入用户名，默认为 tarena
Email Address:电子邮件
Password:密码
Password(again):重复密码
</code></pre><h3 id="2、基本管理"><a href="#2、基本管理" class="headerlink" title="2、基本管理"></a>2、基本管理</h3><p>1、在应用中的 admin.py 中注册要管理的Models</p>
<pre><code>1、admin.py
    作用：注册需要管理的Models,只有在此注册了的Models才允许被后台管理

2、注册Models
    from .models import *

    admin.site.register(Entry1)
    admin.site.register(Entry2)
</code></pre><p>2、修改 models.py 处理显示的内容</p>
<pre><code>1、在 models.py 中的各个class追加
    def __str__(self):
        return self.xxx

2、通过 Models 类的内部类 Meta 定义更多的展现形式
    class Author(models.Model):
        ... ... ...
        ... ... ...
        ... ... ...

        class Meta:
            1、db_table
                指定该实体类对应到表的名字
                取值：字符串
                注意：需要同步数据库才能生效
            2、verbose_name
                定义该实体类在后台中的显示的名字(单数)
            3、verbose_name_plural
                效果同上(复数)
            4、ordering
                指定显示数据的排序规则
                取值：一个列表，指定排序属性，默认是升序，如果需要降序的话，属性名前加 - 
</code></pre><h3 id="3、高级管理"><a href="#3、高级管理" class="headerlink" title="3、高级管理"></a>3、高级管理</h3><p>1、在 admin.py 中创建高级管理类</p>
<pre><code>1、定义高级管理类 - EntryAdmin
    必须继承自 admin.ModelAdmin
    ex:
        class AuthorAdmin(admin.ModelAdmin):
            pass

2、注册高级管理类
    admin.site.register(Entry,EntryAdmin)
    ex:
        admin.site.register(Author,AuthorAdmin)
</code></pre><p>2、允许在 EntryAdmin 增加的属性(高级管理属性)</p>
<pre><code>1、list_display
    作用：指定在 列表页 中显示的字段们
    取值：由属性名成组成的列表或元组
    ex:
        list_display=(&apos;name&apos;,&apos;age&apos;,&apos;email&apos;)

2、list_display_links
    作用：定义在列表页中也能够连接到详情页中的字段们
    取值：由属性名成组成的列表或元组
    注意：取值必须出现在 list_display 中

3、list_editable
    作用：指定在列表页中就允许修改的字段们
    取值：由属性名成组成的列表或元组
    注意：取值不能出现在 list_display_link 中

4、search_fields
    作用：指定在列表页中允许被搜索的字段们
    取值：由属性名成组成的列表或元组

5、list_filter
    作用：在列表页的右侧增加一个过滤器，实现快速筛选
    取值：由属性名成组成的列表或元组

6、date_hierarchy
    作用：在列表页的顶部增加一个时间选择器
    取值：必须是DateField 或 DateTimeFiled的列

7、fields
    作用：在详情页面中，指定显示那些字段并按照什么样的顺序显示
    取值：由属性名成组成的列表或元组

8、fieldsets
    作用：在详情页中，对字段们进行分组显示
    注意：fieldsets 和 field 是不能共存的
    语法：
        fieldsets = (
            # 分组1
            (
                &apos;分组名称&apos;,{
                    &apos;fields&apos;:(&apos;属性1&apos;,&apos;属性2&apos;),
                }
            ),
            # 分组2
            ()
        )
</code></pre><h2 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h2><h3 id="1、一对一映射"><a href="#1、一对一映射" class="headerlink" title="1、一对一映射"></a>1、一对一映射</h3><p>1、什么是一对一</p>
<p>A表中的一条记录只能与B表中的一条记录相关联<br>典型代表：一夫一妻制<br>数据库中实现：<br>    A表：设置 主键<br>    B表：增加一列，并引用自A表的主键，再增加一个唯一约束</p>
<p>2、语法</p>
<p>在关联的两个类的任何一个类中实现下列操作：<br>属性=models.OneToOneField(Entry)</p>
<p>3、查询<br>假设有如下表</p>
<pre><code>class Wife(models.Model):
    ... ...
    author = models.OneToOneField(Author)
</code></pre><p>正向查询:通过 wife 找 author</p>
<pre><code># 获取 id为1 的 wife 的信息
wife = Wife.objects.get(id=1)
# 再通过 wife 找到对应的 author
author = wife.author
</code></pre><p>反向查询:通过 author 找 wife</p>
<pre><code># 获取 id为3 的 author 的信息
author = Author.objects.get(id=3)
# 再通过 author 找到对应的 wife
wife = author.wife

wife 是由Django通过OneToOneField在Author中默认增加的一个隐式属性
</code></pre><h3 id="2、一对多映射-1-M"><a href="#2、一对多映射-1-M" class="headerlink" title="2、一对多映射(1:M)"></a>2、一对多映射(1:M)</h3><p>1、什么是一对多</p>
<p>A表中的一条数据可以与B表中的任意多条数据关联<br>B表中的一条数据只能与A表中的一条数据关联</p>
<p>2、在数据库中的实现</p>
<p>通过 外键(Foreign Key) 来实现一对多<br>在 “多” 表中增加外键(Foreign Key)对”一”表的主键进行引用</p>
<p>3、语法</p>
<p>使用 外键(Foreign Key)<br>在 “多” 的实体中增加：<br>属性 = models.ForeignKey(Entry)</p>
<pre><code>ex:
    Book(多) 和 Publisher(一)
    class Book(models.Model):
        ... ...
        ... ...
        publisher = models.ForeignKey(Publisher)
</code></pre><p>4、查询</p>
<p>Book(多) 和 Publisher(一)<br>在多的实体中对一的实体进行引用</p>
<pre><code>class Book(models.Model):
    ... ...
    ... ...
    publisher = models.ForeignKey(Publisher)
</code></pre><p>正向查询 - 通过Book查询Publisher</p>
<pre><code>book=Book.objects.get(id=1)
publisher = book.publisher
</code></pre><p>反向查询 - 通过Publisher查询Book</p>
<pre><code>Django默认会在Publisher中增加一个隐式属性 - book_set (多表类名全小写_set)

# 查询id为1的出版社的信息
pub = Publisher.objects.get(id=1)
# 查询出版社所关联的所有书籍
bookList = pub.book_set.all()
</code></pre><h3 id="3、多对多映射-M-N"><a href="#3、多对多映射-M-N" class="headerlink" title="3、多对多映射(M:N)"></a>3、多对多映射(M:N)</h3><p>1、什么是多对多</p>
<p>A表中的一条记录可以与B表中的任意多条记录匹配<br>B表中的一条记录可以与A表中的任意多条记录匹配</p>
<p>2、在数据库中体现</p>
<p>必须创建第三张表，关联 涉及到的两张数据表</p>
<p>3、语法</p>
<p>在任何一个实体类中，增加：entry = models.ManyToManyField(Entry)</p>
<pre><code>ex:
    class Author(models.Model):
        ... ...
        book = models.ManyToManyField(Book)
</code></pre><p>4、查询</p>
<pre><code>class Author(models.Model):
    ... ...
    book = models.ManyToManyField(Book)
</code></pre><p>正向查询 - 通过 author 查询所有的 book</p>
<pre><code># 先获取 author 
author = Author.objects.get(id=1)
# 再获取 对应的所有的 book
bookList = author.book.all()

通过 关联属性.查询方法() 查询关联数据
</code></pre><p>反向查询 - 通过 book 查询所有的 author</p>
<pre><code># Django 会在 Book 实体类中增加一个隐式属性 author_set (对应实体全小写_set)

book = Book.objects.get(id=1)
auList = book.author_set.all()
</code></pre><h2 id="自定义查询对象-objects"><a href="#自定义查询对象-objects" class="headerlink" title="自定义查询对象 - objects"></a>自定义查询对象 - objects</h2><p>1、声明类 EntryManager,继承自 models.Manager</p>
<pre><code>允许在 EntryManager 中添加自定义函数

class EntryManager(models.Manager):
    def 函数名(self,自定义参数列表)：
        ... ...
        return ... ...
</code></pre><p>2、使用 EntryManager 覆盖 Models类中的 objects</p>
<pre><code>class Entry(models.Model):
    objects = EntryManager()
</code></pre><h2 id="请求对象-HttpResquest"><a href="#请求对象-HttpResquest" class="headerlink" title="请求对象 - HttpResquest"></a>请求对象 - HttpResquest</h2><p>1、HTTP协议</p>
<pre><code>1、请求
2、响应
</code></pre><h3 id="HttpRequest介绍"><a href="#HttpRequest介绍" class="headerlink" title="HttpRequest介绍"></a>HttpRequest介绍</h3><p>1 什么是HttpRequest<br>HttpRequest，在Django中就是请求对象的封装体现。封装了请求过程中的所有信息。在Django中，HttpRequest被化身成了 request 封装到了视图处理函数中作为参数，在调用视图时自动传入</p>
<p>2 HttpRequest中的主要内容</p>
<pre><code>1、request.scheme : 请求协议
2、request.body : 请求主体
3、request.path : 请求路径
4、request.get_host() : 请求的主机地址/域名
5、request.method : 请求方法
6、request.GET : get请求方法所提交的数据
7、request.POST : post请求方法所提交的数据
8、request.COOKIES : cookies中的数据
</code></pre><h3 id="获取-get-请求提交的数据"><a href="#获取-get-请求提交的数据" class="headerlink" title="获取 get 请求提交的数据"></a>获取 get 请求提交的数据</h3><p>1、form 表单提交</p>
<pre><code>&lt;form action=&quot;{% url 'xxx' %}&quot; method=&quot;get&quot;&gt;
    &lt;p&gt;
        姓名:&lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;input type=&quot;submit&quot;&gt;
    &lt;/p&gt;
&lt;/form&gt;
</code></pre><p>服务器端：request.GET[‘uname’]</p>
<p>2、通过地址发送请求</p>
<p>在地址栏上拼 查询字符串(Query String)<br>http://请求地址/?参数名=值&amp;参数名=值<br><a href="http://localhost:8000/get/?name=a&amp;pwd=b&amp;email=c" target="_blank" rel="noopener">http://localhost:8000/get/?name=a&amp;pwd=b&amp;email=c</a><br>    参数1： name ，值：a<br>    参数2： pwd  ，值：b<br>    参数3： email，值：c</p>
<h3 id="获取-post-请求提交的数据"><a href="#获取-post-请求提交的数据" class="headerlink" title="获取 post 请求提交的数据"></a>获取 post 请求提交的数据</h3><p>1、发送post的方式<br>只有在表单的 method 指定为 post 的时候，才能发送post请求</p>
<p>2、获取 post 请求提交的数据</p>
<pre><code>value = request.POST[&apos;key&apos;]
</code></pre><p>3、403 - Forbidden - csrf</p>
<p>csrf<br>    Cross-Site Request Forgery<br>    理解为：跨站点攻击</p>
<p><strong>csrf 解决方案</strong></p>
<ul>
<li>settings.py<br>  删除 CsrfViewMiddleWare 中间件</li>
<li>在处理视图上增加 @csrf_protect 装饰器</li>
<li><p><strong>在 模板中 的 <form> 下的第一句话增加</form></strong></p>
<pre><code>{% csrf_token %}
</code></pre></li>
</ul>
<h2 id="使用-forms-处理表单"><a href="#使用-forms-处理表单" class="headerlink" title="使用 forms 处理表单"></a>使用 forms 处理表单</h2><h3 id="forms-模块的作用"><a href="#forms-模块的作用" class="headerlink" title="forms 模块的作用"></a>forms 模块的作用</h3><p>通过 forms 模块，允许将表单控件与 py 文件相结合，可以在网页中自动生成表单控件</p>
<h3 id="使用-forms-模块"><a href="#使用-forms-模块" class="headerlink" title="使用 forms 模块"></a>使用 forms 模块</h3><p>1、在应用中创建 forms.py 文件<br>2、导入 forms</p>
<pre><code>from django import forms
</code></pre><p>3、创建class，一个class对应到页面上的一个表单<br>    该类必须继承自 forms.Form<br>4、在class中创建属性<br>    一个属性对应着一个表单控件<br>        (参考文档)</p>
<h3 id="在模板中，解析-forms-对象"><a href="#在模板中，解析-forms-对象" class="headerlink" title="在模板中，解析 forms 对象"></a>在模板中，解析 forms 对象</h3><p>注意：<br>    1、需要自定义<form><br>    2、需要自定义 提交按钮<br>1、手动解析</form></p>
<p>在 视图中，创建 forms.Form 对象，并发送到模板中<br>ex:</p>
<pre><code>form = RemarkForm()
return render(request,&apos;xx.html&apos;,locals())
</code></pre><p>手动解析：<br>    模板中：</p>
<pre><code>{% for field in form %}
			{{field.label}}:表示的是 label属性值
			{{field}} : 表示控件
		{% endfor %}
</code></pre><p>2、自动解析</p>
<pre><code>1、{{form.as_p}}
    将form中每个属性都解析成一个p标记，在p标记中再显示控件以及标签
2、{{form.as_ul}}
    将form中每个属性解析成一个li标记，再显示控件以及标签
    注意：需要自定义 ul 或 ol 标记的
3、{{as_table}}
    将form中每个属性解析成一个tr以及td，再显示控件以及标签
    注意：需要自定义 table 标记
</code></pre><h3 id="在视图中，通过-forms-Form-快速获取表单数据"><a href="#在视图中，通过-forms-Form-快速获取表单数据" class="headerlink" title="在视图中，通过 forms.Form 快速获取表单数据"></a>在视图中，通过 forms.Form 快速获取表单数据</h3><p>1、通过 forms.Form 的构造函数，接收post数据</p>
<pre><code>form = XXXForm(request.POST)
</code></pre><p>2、需要让 form 通过验证后，再取值</p>
<p>目的：防止数据错误提交</p>
<pre><code>form.is_valid()
</code></pre><p>返回true:通过验证<br>返回false:未通过验证，提交的数据与表单类型不匹配</p>
<p>3、获取表单提交的数据</p>
<pre><code>通过 form.cleaned_data(字典) 获取提交的数据

cd = form.cleaned_data
    value = cd[&apos;name&apos;]
</code></pre><h2 id="forms-的高级处理"><a href="#forms-的高级处理" class="headerlink" title="forms 的高级处理"></a>forms 的高级处理</h2><p>将 Models 和 Forms 结合到一起使用</p>
<ul>
<li><p>在 forms.py 中，创建 class，继承自 forms.ModelForm </p>
</li>
<li><p>创建内部类 ：Meta</p>
</li>
</ul>
<p>作用：关联 Form 和 Models 的<br>1、model : 指定要关联的Models类</p>
<pre><code>ex: model = Users
</code></pre><p>2、fields : 指定从Models类中取出哪些字段生成控件</p>
<pre><code>1、取值 &quot;__all__&quot;,全部属性都要生成表单控件
2、指定一个列表，声明允许生成表单控件的属性名
    ex: fields = [&quot;uname&quot;,&quot;upwd&quot;]
</code></pre><p>3、labels:指定每个属性要关联的label，取值为 字典</p>
<pre><code>ex:
    labels = {
        &apos;属性名&apos;:&apos;label文本&apos;,
        &apos;属性名&apos;:&apos;label文本&apos;,
        }
</code></pre><h2 id="内置小部件"><a href="#内置小部件" class="headerlink" title="内置小部件"></a>内置小部件</h2><h3 id="什么是小部件"><a href="#什么是小部件" class="headerlink" title="什么是小部件"></a>什么是小部件</h3><p>小部件(Widget),表示的是生成到页面中的控件的类型以及其他属性</p>
<h3 id="常用小部件"><a href="#常用小部件" class="headerlink" title="常用小部件"></a>常用小部件</h3><p>1、TextInput : type=”text”<br>2、NumberInput : type=”number”<br>3、EmailInput : type=”email”<br>4、URLInput : type=”url”<br>5、PasswordInput : type=”password”<br>6、HiddenInput : type=”hidden”<br>7、CheckboxInput : type=”checkbox”<br>8、Textarea : <textarea></textarea><br>9、Select : <select></select></p>
<h3 id="小部件的使用"><a href="#小部件的使用" class="headerlink" title="小部件的使用"></a>小部件的使用</h3><ul>
<li>1、继承自 forms.Form</li>
</ul>
<p>基本版</p>
<pre><code>属性 = forms.CharField(
    label=&apos;xxx&apos;,
    widget=forms.小部件类型
)

ex:
    upwd = forms.CharField(
        label=&apos;用户密码&apos;,
        widget=forms.PasswordInput
    )

    age = forms.CharField(
        label=&apos;用户年纪&apos;,
        widget=forms.NumberInput
    )
</code></pre><p>高级版</p>
<pre><code>属性 = forms.CharField(
    label=&apos;标签&apos;,
    widget=forms.小部件类型(
        attrs={
            &apos;属性名1&apos;:&apos;属性值1&apos;,
            &apos;属性名2&apos;:&apos;属性值2&apos;,
        }
    )
)

ex:
    upwd = forms.CharField(
        label=&apos;用户密码&apos;,
        widget=forms.PasswordInput(
            attrs={
                &apos;placeholder&apos;:&apos;请输入密码&apos;,
                &apos;class&apos;:&apos;form-control&apos;,
                &apos;max-length&apos;:&apos;26&apos;,
            }
        )
    )
</code></pre><ul>
<li><p>2、继承自 forms.ModelForm</p>
<pre><code>class WidForm2(forms.ModelForm):
    class Meta:
        model=Users
        fields=&quot;__all__&quot;
        labels={
            &apos;属性1&apos;:&apos;标签1&apos;,
            &apos;属性2&apos;:&apos;标签2&apos;,
        }
        widgets={
            &apos;属性1&apos;:forms.小部件类型(
                attrs={
                    &apos;属性&apos;:&apos;值&apos;,
                }
            )
        }
</code></pre></li>
</ul>
<h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><h3 id="什么是cookies"><a href="#什么是cookies" class="headerlink" title="什么是cookies"></a>什么是cookies</h3><p>cookies 是一种数据存储技术<br>将一段文本数据保存在客户端(浏览器)的一种技术，并可以长时间保存</p>
<h3 id="cookies的使用场合"><a href="#cookies的使用场合" class="headerlink" title="cookies的使用场合"></a>cookies的使用场合</h3><p>1、保存登录信息<br>2、保存需要长期使用的数据</p>
<h3 id="django-中使用-cookies"><a href="#django-中使用-cookies" class="headerlink" title="django 中使用 cookies"></a>django 中使用 cookies</h3><p>1、设置 cookies(将数据保存到客户端)<br>cookies的设置，在服务器端是由响应对象发起的<br>语法：<br>    响应对象.set_cookie(key,value,expires)<br>        key:cookie的名字<br>        value:cookie的值<br>        expires:保存时间，以s为单位</p>
<ul>
<li><p>不使用模板 - HttpResponse<br>  resp = HttpResponse(‘给客户端一句话’)<br>  resp.set_cookie(‘key’,’value’,expires)<br>  return resp</p>
</li>
<li><p>使用模板 - render()<br>  resp = render(request,’xx.html’)<br>  resp.set_cookie(‘key’,’value’,expires)<br>  return resp</p>
</li>
<li><p>使用重定向 - HttpResponseRedirect()<br>  resp = HttpResponseRedirect(‘/地址/‘)<br>  resp.set_cookie(‘key’,’value’,expires)<br>  return resp</p>
</li>
</ul>
<p>2、获取 cookies(从客户端获取数据)<br>注意：<br>    每次请求时，请求对象(request)会将当前路径下的所有的cookies都带到服务器<br>语法：<br>    request.COOKIES</p>
<hr>
<p>结束语：Django的内容还是很多的，接下来是通过实例操作来练习Django的使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/人工智能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/人工智能/" itemprop="url">数据分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T09:22:44+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能/" itemprop="url" rel="index">
                    <span itemprop="name">人工智能</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,752 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  40 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>matlab matfor python<br>numpy数据分析+scipy建模+matplotlib可视化+pandas数据清洗<br>scikit-learn机器学习工具包+tensorflow深度学习（google）</p>
<h2 id="numpy的特点"><a href="#numpy的特点" class="headerlink" title="numpy的特点"></a>numpy的特点</h2><p>1 擅长数字计算<br>2 足够高的运算性能<br>3 支持矢量化运算<br>4 完全免费的 开源的</p>
<p>代码： vector.py</p>
<pre><code>import time

n = 100000

start = time.time()
A, B = [x**2 for x in range(n)], [x**3 for x in range(n)]

C = [x + y for x, y in zip(A, B)]
end = time.time()
print(end - start)


运行时间：
0.13362669944763184
</code></pre><h2 id="Numpy的数组"><a href="#Numpy的数组" class="headerlink" title="Numpy的数组"></a>Numpy的数组</h2><p>1 numpy中的数组是ndarray类型的对象<br> 将实际数据和元数据分开存放，独立操作，以此提高性能。<br> 元数据就是对实际数据的描述，比如姓名 性别 年龄等来描述一个人，实际数据就是描述所指向的实际的人。<br> 修改元数据的指向关系，实际数据不改变，这样就可以做到修改了顺序但是数据并没有真正的修改，从而提高性能。</p>
<p>2 numpy数组元素类型必须相同–同质性</p>
<p>3 numpy数组的元素可以通过基于0 的下标单独访问，<br>  size个元素的数组，合理的下标范围 [0~size-1]或者[-size,-1](闭区间）</p>
<p>4 numpy数组通过dtype和shape属性表示元素的类型和纬度，其中纬度的类型为元组，按照从高到低的顺序排列每一维的大小<br>比如数组为</p>
<pre><code>1 2 3
4 5 6
</code></pre><p>则 shape：(2,3) 2行 3列<br>dtype为int32 有符号的32位整型数据<br>字符串的dtype为 &lt;UX,X是数组中最长的字符串的长度， &lt;代表小端字节序 U代码unicode编码<br>如下数组</p>
<pre><code>1 2 3

4 5 6

7 8 9
</code></pre><p>shape：(3,1,3) 3页，每页1行，每行3个元素</p>
<p>5 数组的创建的方法：<br> numpy.arange(start=0,end,step=1) start起始值，缺省默认为0 end终止值必须有  step步长默认为1<br> numpy.array(literable)  literable是可迭代对象，是任意可以被解释为数组的序列</p>
<p>代码： shape.py</p>
<pre><code>import numpy as np

a = np.arange(1, 3)

print(a)
print(a.shape)

b = np.array([[1, 2, 3], [4, 5, 6]])

print(b)
print(b.shape)

c = np.array([[np.arange(1, 5), np.arange(5, 9), np.arange(9, 13)],
              [np.arange(13, 17), np.arange(17, 21), np.arange(21, 25)]])
print(c)
print(c.shape)

d = b.reshape(3, 2) #如果参数为-1则表示该行自动计算
print(d)

运行结果：
(2,)
[[1 2 3]
 [4 5 6]]
(2, 3)
[[[ 1  2  3  4]
  [ 5  6  7  8]
  [ 9 10 11 12]]

 [[13 14 15 16]
  [17 18 19 20]
  [21 22 23 24]]]
(2, 3, 4)

[[1 2]
 [3 4]
 [5 6]]
</code></pre><p>上面代码中shape不能敲错误了，这里是调用的属性。  reshape用来修改纬度，但是必须要保证修改后的纬度的元素个数和修改前的纬度的个数一致<br>也就是参数 x<em>y = b.x </em> b.y b是代表上面的数组，如果不相等则会报错。</p>
<p>遍历上面的3维数组c的方法：</p>
<pre><code>for i in range(c.shape[0]):
    for j in range(c.shape[1]):
        for k in range(c.shape[2]):
            print(c[i][j][k])
            #print(c[i，j,k])

数组的下标可以通过[i,j,k]来表示，当然，python的[i][j][k]都是可以的
</code></pre><h2 id="numpy内置的数据类型"><a href="#numpy内置的数据类型" class="headerlink" title="numpy内置的数据类型"></a>numpy内置的数据类型</h2><h3 id="1-布尔"><a href="#1-布尔" class="headerlink" title="1 布尔"></a>1 布尔</h3><p>bool_</p>
<h3 id="2-整数"><a href="#2-整数" class="headerlink" title="2 整数"></a>2 整数</h3><p>1 有符号整数<br>int8 int16 int32 int64<br>2 无符号整数<br>uint8 uint16 uint32 uint64</p>
<h3 id="3-浮点"><a href="#3-浮点" class="headerlink" title="3 浮点"></a>3 浮点</h3><p>float16 float32 float64</p>
<h3 id="4-复数"><a href="#4-复数" class="headerlink" title="4 复数"></a>4 复数</h3><p>complex64(float32+float32) complex128(float64+float64)</p>
<h3 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5 字符串"></a>5 字符串</h3><p>str_ 加下划线是为了和python进行区别</p>
<h2 id="显式使用数据类型"><a href="#显式使用数据类型" class="headerlink" title="显式使用数据类型"></a>显式使用数据类型</h2><p>1  默认数据类型不满足需求时，需要人为指定<br>2  复合类型，在一个元素中含有多个字段。 numpy.array(…,dtype=类型）</p>
<pre><code>import numpy as np

age = np.array([20, 22, 28, 25, 19])  # 存放年龄
print(age.dtype)
# 这种情况下存放的是int32,但是人的年龄不超过200岁吧

age1 = np.array([20, 22, 28, 25, 19], dtype=np.uint8)
#这里可以用np.的方式来定义类型，也可以用 &apos;uint8&apos; &apos;u1&apos;
print(age1.dtype)

# u3代表3个字符的字符串，3U1代表的是3个整型数据的数组
a = np.array([(&apos;abc&apos;, (1, 2, 3))], dtype=&apos;U3,3U1&apos;)
print(a[0][&apos;f0&apos;], a[0][&apos;f1&apos;])#默认是f0-fN

#自定义字段名fa fb和指定数据类型
b = np.array([(&apos;abc&apos;, (1, 2, 3))], dtype=[
             (&apos;fa&apos;, np.str_, 3), (&apos;fb&apos;, np.uint8, 3)])
print(b[0][&apos;fa&apos;], b[0][&apos;fb&apos;])

c = np.array([(&apos;abc&apos;, (1, 2, 3))], dtype={
     &apos;names&apos;: [&apos;fa&apos;, &apos;fb&apos;], &apos;formats&apos;: [&apos;U3&apos;, &apos;3U1&apos;]})

#这里的0是偏移量，字符串是从下标0开始的，前面3个字符占用了12个字节，所以数字1是从第12字节开始存放的
d = np.array([(&apos;abc&apos;, (1, 2, 3))], dtype={
     &apos;fa&apos;: (&apos;U3&apos;, 0), &apos;fb&apos;: (&apos;3U1&apos;, 12)})



result：
int32
uint8
abc [&apos;1&apos; &apos;2&apos; &apos;3&apos;]
abc [1 2 3]
abc [&apos;1&apos; &apos;2&apos; &apos;3&apos;]
abc [&apos;1&apos; &apos;2&apos; &apos;3&apos;]
</code></pre><p>3  用不同类型访问同一个元素</p>
<p>  接上面的代码</p>
<pre><code>e = np.array(0x1234)
print(e)  # 默认为16进制的数，打印出10进制的值

f = np.array([0x1234], dtype=(&apos;u2&apos;, {&apos;lo&apos;: (&apos;u1&apos;, 0), &apos;hi&apos;: (&apos;u1&apos;, 1)}))
print(f[0], f[&apos;lo&apos;][0], f[&apos;hi&apos;][0])  # 默认是小端输出，所以先打印0x34 再打印0x12,想改输出的时候只需要将&apos;u2&apos;改为&apos;&gt;u2&apos;

result：
4660
4660 52 18
</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片语法： 数组[start:end:step,…]</p>
<p>start可以缺省，缺省时起始值为首元素/尾元素(步长为负数的时候从尾开始)<br>end可以缺省，缺省时终止值为尾元素/首元素(步长为负数的时候到开头结束)<br>step缺省默认为1.</p>
<pre><code>a = np.arange(1, 10)
print(a[:3])
print(a[3:6])
print(a[6:])
print(a[::-1])
print(a[:-4:-1])    

result：
[1 2 3]
[4 5 6]
[7 8 9]
[9 8 7 6 5 4 3 2 1]
[9 8 7]

[[[ 1  2  3  4]
  [ 5  6  7  8]
  [ 9 10 11 12]]


b = np.arange(1, 25).reshape(2, 3, 4)
print(b)
-&gt; [[13 14 15 16]
  [17 18 19 20]
  [21 22 23 24]]]

print(b[:, 0, 0])  # 取每页 0行0列元素
print(b[0, 1, :2])  # 取第0页 第一行 步长为2的取列
print(b[..., 1])  # 列数为1的元素
print(b[::-1, ::-1])  # 每页 每行调换顺序
print*b[-1, 1:, 2:]  # 最后1页的第一行到后面的所有行，第二列开始的所有列

[ 1 13]
[5 6]
[[ 2  6 10]
 [14 18 22]]
[[[21 22 23 24]
  [17 18 19 20]
  [13 14 15 16]]

 [[ 9 10 11 12]
  [ 5  6  7  8]
  [ 1  2  3  4]]]
[[19 20]
 [23 24]]
</code></pre><h2 id="改变维度"><a href="#改变维度" class="headerlink" title="改变维度"></a>改变维度</h2><h3 id="视图变维"><a href="#视图变维" class="headerlink" title="视图变维"></a>视图变维</h3><p>根据所指定的新维度，构造新的元数据，实际数据共享。<br>一份数据存放在内存中，通过建立不同的指针指向该数据，而这些指针是不同的维度来操作数据。</p>
<pre><code>源数组.reshape(新维度) -&gt; 目标数组
\______________________________/
        共享实际数据
 ___________________________
/                           \
  源数组.ravel()-&gt;一维目标数组
</code></pre><h3 id="复制变维"><a href="#复制变维" class="headerlink" title="复制变维"></a>复制变维</h3><p>flatten()是将数据拷贝了一份，拷贝的源数据的修改不影响该拷贝数据的内容</p>
<pre><code>源数组.flatten() -&gt; 一维目标数组
  |                     |
实际数据 &lt;- 非共享 -&gt; 实际数据副本
</code></pre><h3 id="就地变维"><a href="#就地变维" class="headerlink" title="就地变维"></a>就地变维</h3><p>源数组.shape = 新维度<br>源数组.resize(新维度)</p>
<p>copy()函数是可以将实际数据拷贝一份，新生成的数据的修改与原始实际数据没有关系。</p>
<pre><code>import numpy as np

a = np.arange(1, 9)
print(a)
b = a.reshape(2, 4)
print(b)
c = b.reshape(2, 2, 2)
print(c)
d = c.ravel()
print(d)
e = c.flatten()
print(e)

a += 10
print(&quot;after a += 10 --------------&quot;)
print(b)
print(c)
print(d)
print(e)

[1 2 3 4 5 6 7 8]
[[1 2 3 4]
 [5 6 7 8]]
[[[1 2]
  [3 4]]

 [[5 6]
  [7 8]]]
[1 2 3 4 5 6 7 8]
[1 2 3 4 5 6 7 8]
after a += 10 --------------
[[11 12 13 14]
 [15 16 17 18]]
[[[11 12]
  [13 14]]

 [[15 16]
  [17 18]]]
[11 12 13 14 15 16 17 18]
[1 2 3 4 5 6 7 8]

a.resize(4, 2)
print(a)
[[11 12]
 [13 14]
 [15 16]
 [17 18]]
</code></pre><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><p>源数组.transpose() -&gt;转置视图</p>
<pre><code>f = a.transpose()
print(f)

[[11 13 15 17]
 [12 14 16 18]]
</code></pre><h2 id="合并与拆分"><a href="#合并与拆分" class="headerlink" title="合并与拆分"></a>合并与拆分</h2><h3 id="垂直合分"><a href="#垂直合分" class="headerlink" title="垂直合分"></a>垂直合分</h3><p>vstack((上，下)) -&gt;垂直合并  等价于<br>concatenate((上，下),axis=0) axis表示的是轴向</p>
<p>vsplit(数组，等分份数）-&gt;垂直拆分  等价于<br>split(数组，等分份数，axis=0)</p>
<pre><code>import numpy as np #后面都省略

a = np.arange(11, 20).reshape(3, 3)
print(a)
print(&quot;--------------&quot;)
b = a + 10
print(b)
print(&quot;--------------&quot;)
c = np.vstack((a, b))
print(c)
print(&quot;--------------&quot;)
d = np.concatenate((a, b), axis=0)
print(d)
print(&quot;--------------&quot;)
e, f, g = np.vsplit(c, 3)
print(e, f, g, sep=&quot;\n&quot;)
print(&quot;--------------&quot;)

[[11 12 13]
 [14 15 16]
 [17 18 19]]
--------------
[[21 22 23]
 [24 25 26]
 [27 28 29]]
--------------
[[11 12 13]
 [14 15 16]
 [17 18 19]
 [21 22 23]
 [24 25 26]
 [27 28 29]]
--------------
[[11 12 13]
 [14 15 16]
 [17 18 19]
 [21 22 23]
 [24 25 26]
 [27 28 29]]
--------------
[[11 12 13]
 [14 15 16]]
[[17 18 19]
 [21 22 23]]
[[24 25 26]
 [27 28 29]]
</code></pre><h3 id="水平合分"><a href="#水平合分" class="headerlink" title="水平合分"></a>水平合分</h3><p>hstack((上，下)) -&gt;水平合并  等价于<br>concatenate((上，下),axis=1) axis表示的是轴向</p>
<p>hsplit(数组，等分份数）-&gt;水平拆分  等价于<br>split(数组，等分份数，axis=1)</p>
<p>用法和垂直合分一样，这里不举例了</p>
<h3 id="深度合分"><a href="#深度合分" class="headerlink" title="深度合分"></a>深度合分</h3><p>dstack((前，后)) -&gt;深度合并<br>dsplit(数组，等分份数）-&gt;深度拆分</p>
<pre><code>a = np.arange(11, 20).reshape(3, 3)
b = a + 10
c = np.dstack((a, b))
print(c)
print(&quot;-------------&quot;)

d, e = np.dsplit(c, 2)
print(d)
print(e)


[[[11]
  [12]
  [13]]

 [[14]
  [15]
  [16]]

 [[17]
  [18]
  [19]]]
[[[21]
  [22]
  [23]]

 [[24]
  [25]
  [26]]

 [[27]
  [28]
  [29]]]

print(d.T[0].T)#T是转置数组，是一种属性
print(e.T[0].T)
[[11 12 13]
 [14 15 16]
 [17 18 19]]
[[21 22 23]
 [24 25 26]
 [27 28 29]]
</code></pre><h3 id="行列合并"><a href="#行列合并" class="headerlink" title="行列合并"></a>行列合并</h3><p>row_stack((上，下)) -&gt; 行合并<br>column_stack((左，右)) -&gt; 列合并</p>
<pre><code>a = np.array([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
b = np.array([&quot;d&quot;, &quot;e&quot;, &quot;f&quot;])
c = np.row_stack((a, b))
print(c)
d = np.column_stack((a, b))
print(d)

[[&apos;a&apos; &apos;b&apos; &apos;c&apos;]
 [&apos;d&apos; &apos;e&apos; &apos;f&apos;]]
[[&apos;a&apos; &apos;d&apos;]
 [&apos;b&apos; &apos;e&apos;]
 [&apos;c&apos; &apos;f&apos;]]
</code></pre><h2 id="ndarray对象的属性"><a href="#ndarray对象的属性" class="headerlink" title="ndarray对象的属性"></a>ndarray对象的属性</h2><p>dtype - 元素数据类型<br>shape - 数组维度 （3,4）<br>ndim - 数组维数 2<br>size - 元素数 12  len返回的是3<br>itemsize - 每个元素的字节数<br>nbytes - 所有元素的总字节数 =size * timesize<br>T -转置视图<br>real/imag -复数的实部 虚部<br>flat -扁平迭代器</p>
<pre><code>a = np.array([[1 + 2j, 2 + 3j, 3 + 4j], [11 + 12j, 12 + 13j,\
                                         13 + 14j], [11 + 12j, 12 + 13j, 13 + 14j]])
print(a.dtype)
print(a.shape)
print(a.ndim)
print(a.size, a.shape[0] * a.shape[1])
print(a.itemsize, int(128 / 8))
print(a.nbytes, a.size * a.itemsize)
print(a.T, a.transpose(), sep=&apos;\n&apos;)
print(a.real, a.imag, sep=&apos;\n&apos;)
for ele in a.flat:
    print(ele)

complex128
(3, 3)
2
9 9
16 16
144 144
[[  1. +2.j  11.+12.j  11.+12.j]
 [  2. +3.j  12.+13.j  12.+13.j]
 [  3. +4.j  13.+14.j  13.+14.j]]
[[  1. +2.j  11.+12.j  11.+12.j]
 [  2. +3.j  12.+13.j  12.+13.j]
 [  3. +4.j  13.+14.j  13.+14.j]]
[[  1.   2.   3.]
 [ 11.  12.  13.]
 [ 11.  12.  13.]]
[[  2.   3.   4.]
 [ 12.  13.  14.]
 [ 12.  13.  14.]]
(1+2j)
(2+3j)
(3+4j)
(11+12j)
(12+13j)
(13+14j)
(11+12j)
(12+13j)
(13+14j)
</code></pre><p>numpy 与 python结构直接转换<br>a = np.arrar(lst)<br>b = list(a)<br>c = tuple(a)<br>d = set(a)</p>
<h2 id="数据可视化-matplotlib"><a href="#数据可视化-matplotlib" class="headerlink" title="数据可视化 matplotlib"></a>数据可视化 matplotlib</h2><p>1 缺省样式<br>曲线图 plot(水平坐标数组，垂直坐标数组)</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

x = np.linspace(-np.pi, np.pi, 1000)

cos_y = np.cos(x) / 2
sin_y = np.sin(x)
mp.plot(x, cos_y)
mp.plot(x, sin_y)
mp.show()#窗口不关闭的情况下，后面的代码是不执行的
#运行结果这里不添加了，是图形化界面
</code></pre><p>2 线型 线宽 和 颜色<br>plot(…,linestyle=线型,linewidth=线宽,color=颜色)<br>linestyle=线型 可选的有 ‘–’虚线  ‘:’点号  ‘-.’<br>linewidth=线宽<br>color 就用常见的几种颜色的英文</p>
<p>3 设置坐标范围<br>mp.xlim(最小水平坐标，最大水平坐标）<br>mp.ylim(最小垂直坐标，最大垂直坐标）</p>
<pre><code>mp.xlim(x.min(), x.max())
mp.ylim(sin_y.min(), sin_y.max())
</code></pre><p>4 设置刻度标签<br>mp.xticks(刻度位置数组，刻度文本数组=None)<br>mp.yticks(刻度位置数组，刻度文本数组=None)</p>
<pre><code>mp.xticks([-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi],\
          [r&apos;$-\pi$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$0$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$-\pi$&apos;])
mp.yticks([-1, -0.5, 0, 0.5, 1])
</code></pre><p>5 十字坐标轴<br>ax = mp.gca() 获得当前坐标图<br>ax.spines[‘left’].set_position(坐标系，位置坐标)<br>ax.spines[‘left’].set_color(颜色)</p>
<pre><code>ax = mp.gca()
ax.spines[&apos;left&apos;].set_position((&apos;data&apos;, 0))
ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))
ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)
ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)
</code></pre><p>6 图例<br>plot(…label=图例文本)<br>legend(loc=位置) loc可以不指定，系统自动选择，但是函数必须调用</p>
<p>7 特殊点<br>scatter(水平坐标数组，垂直坐标数组）</p>
<p>8 备注<br>annotate(<br>备注文本，<br>xy=目标坐标，<br>xycoords=目标坐标系，<br>xytext=备注位置，<br>textcoords=备注坐标系,<br>fontsize=字体大小,<br>arrowprops=箭头属性<br>）</p>
<p><strong>以上8个用例完整代码：</strong></p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

x = np.linspace(-np.pi, np.pi, 1000)

cos_y = np.cos(x) / 2
sin_y = np.sin(x)

xo = np.pi / 2
yo_cos = np.cos(xo) / 2
yo_sin = np.sin(xo)

mp.xlim(x.min() * 1.1, x.max() * 1.1)  # 留一点空白区域
mp.ylim(sin_y.min() * 1.1, sin_y.max() * 1.1)
mp.plot(x, cos_y, linestyle=&apos;-&apos;, color=&apos;orangered&apos;, label=r&apos;$cos(x)$&apos;)
mp.xticks([-np.pi, -np.pi / 2, 0, np.pi / 2, np.pi],
          [r&apos;$-\pi$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$0$&apos;, r&apos;$-\pi/2$&apos;, r&apos;$-\pi$&apos;])
mp.yticks([-1, -0.5, 0, 0.5, 1])

ax = mp.gca()
ax.spines[&apos;left&apos;].set_position((&apos;data&apos;, 0))
ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))
ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)
ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)

mp.plot(x, sin_y, linestyle=&apos;-&apos;, linewidth=0.5,
        color=&apos;green&apos;, label=r&apos;$sin(x)/2$&apos;)

mp.plot([xo, xo], [yo_cos, yo_sin], linestyle=&apos;--&apos;, color=&apos;limegreen&apos;)
mp.scatter([xo, xo], [yo_cos, yo_sin], s=60,
           edgecolor=&apos;limegreen&apos;, facecolor=&apos;white&apos;, zorder=3)
mp.annotate(r&apos;$sin(\pi/2)=1$&apos;,
            xy=(xo, yo_sin),
            xycoords=&apos;data&apos;,
            xytext=(40, 40),
            textcoords=&apos;offset points&apos;,
            fontsize=14,
            arrowprops=dict(arrowstyle=&apos;-&gt;&apos;, connectionstyle=&apos;arc3,rad=0.2&apos;)
            )
mp.legend(loc=&apos;upper left&apos;)
mp.show()  # 窗口不关闭的情况下，后面的代码是不执行的
</code></pre><hr>
<h2 id="图形对象"><a href="#图形对象" class="headerlink" title="图形对象"></a>图形对象</h2><p>figure(对象名(窗口标题)，figsize=大小,dpi=分辨率，facecolor=颜色)  -&gt; 图形窗口对象（不存在则创建，存在则设置为当前窗口）</p>
<p>代码：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

x = np.linspace(-np.pi, np.pi, 1000)
cos_y = np.cos(x) / 2
sin_y = np.sin(x)
mp.figure(&apos;Sin&apos;, figsize=(6, 4), dpi=120, facecolor=&apos;dodgerblue&apos;)
mp.title(&apos;Sin&apos;, fontsize=20)  # 设置窗体内部的标签
mp.xlabel(&apos;x&apos;, fontsize=14)  # 设置坐标轴的标签
mp.ylabel(&apos;y&apos;, fontsize=14)
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)


mp.figure(&apos;Cos&apos;, figsize=(6, 4), dpi=120, facecolor=&apos;limegreen&apos;)
mp.title(&apos;Cos&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;, fontsize=14)
mp.ylabel(&apos;y&apos;, fontsize=14)
mp.tick_params(labelsize=10)
mp.grid()
mp.figure(&apos;Sin&apos;)
mp.plot(x, sin_y, label=r&apos;$y=sin(x)$&apos;)
mp.legend()
mp.figure(&apos;Cos&apos;)
mp.plot(x, cos_y, label=r&apos;$y=cos(x)$&apos;)
mp.legend()
mp.show()
</code></pre><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>subplot(总行数，总列数，图号）<br>subplot(总行数总列数图号的连写，如223代表两行2列的第三张图）<br>代码：</p>
<pre><code>import matplotlib.pyplot as mp

mp.figure(&apos;Subplot&apos;, figsize=(6, 4), dpi=120, facecolor=&apos;lightgray&apos;)
mp.subplot(221)
mp.xticks(())
mp.yticks(())
# 在中间显示数字1，字体大小和透明度
mp.text(0.5, 0.5, &apos;1&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(222)
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;2&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(223)
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;3&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(224)
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;4&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

# 设置几个子图更加紧凑一些
mp.tight_layout()
mp.show()
</code></pre><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><p>import matplotlib.gridspec as mg<br>gs = mg.GridSpec(行数，列数）<br>subplot(gs[切片])</p>
<p>实现如下布局的4个区域块</p>
<pre><code>！！！！！！！！！！！
&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;##########
&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;@@@@@@@@@@
</code></pre><p>代码如下：</p>
<pre><code>import matplotlib.pyplot as mp
import matplotlib.gridspec as mg
mp.figure(&apos;gridspec&apos;, facecolor=&apos;lightgray&apos;)
gs = mg.GridSpec(3, 2)
mp.subplot(gs[0, :])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;1&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(gs[1:, 0])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;2&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(gs[1, 1])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;3&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.subplot(gs[2, 1])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;4&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.tight_layout()
mp.show()
</code></pre><h2 id="自由布局"><a href="#自由布局" class="headerlink" title="自由布局"></a>自由布局</h2><p>axes([左，底，宽度，高度)  宽度和高度都是比例，0-1之间</p>
<p>画一个图中的矩形图，边框左右：3% 上下：4%，则宽到为 94% 92%<br>代码如下：</p>
<pre><code>import matplotlib.pyplot as mp
mp.figure(&apos;axes&apos;, facecolor=&apos;lightgray&apos;)
mp.axes([0.03, 0.04, 0.94, 0.92])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;N.O.1!&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.axes([0.70, 0.06, 0.25, 0.25])
mp.xticks(())
mp.yticks(())
mp.text(0.5, 0.5, &apos;N.O.2!&apos;, ha=&apos;center&apos;, va=&apos;center&apos;, size=36, alpha=0.5)

mp.show()
</code></pre><h2 id="坐标刻度"><a href="#坐标刻度" class="headerlink" title="坐标刻度"></a>坐标刻度</h2><p>xxxLocator(参数) -&gt; 坐标定位器对象<br>ax = mp.gca()<br>设置水平轴主刻度定位器<br>ax.xaxis.set_major_locator(坐标定位器对象)<br>设置垂直轴次刻度定位器<br>ax.yaxis.set_minor_locator(坐标定位器对象)<br>代码如下所示：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp
mp.figure(&apos;locator&apos;)
locators = [
    &apos;mp.NullLocator()&apos;,#空定位器对象
    &apos;mp.MaxNLocator(nbins=3,steps=[1,3,5,7,9])&apos;,#最大值定位器对象
    &apos;mp.FixedLocator(locs=[0, 2.5, 5, 7.5, 10])&apos;,#固定定位器对象
    &apos;mp.AutoLocator()&apos;,#自动定位器对象
    &apos;mp.IndexLocator(offset=0.5,base=1.5)&apos;,#偏移0.5，自增长长度1.5
    &apos;mp.MultipleLocator()&apos;,#多功能定位器
    &apos;mp.LinearLocator(numticks=21)&apos;,  # 20等分
    &apos;mp.LogLocator(base=2,subs=[1.0])&apos;#2为底的对数
]
n_locators = len(locators)
for i, locator in enumerate(locators):
    mp.subplot(n_locators, 1, i + 1)#设置画图的子图
    mp.xlim(0, 10)
    mp.ylim(-1, 1)
    mp.yticks(())
    ax = mp.gca()
    ax.spines[&apos;left&apos;].set_color(&apos;none&apos;)
    ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)
    ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)
    ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))
    ax.xaxis.set_major_locator(eval(locator))
    ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))
    mp.plot(np.arange(0, 11), np.zeros(11), c=&apos;none&apos;)
    mp.text(5, 0.3, locator[3:], ha=&apos;center&apos;, size=12)#去掉了mp.之后显示为标题内容居中显示
mp.tight_layout()
mp.show()
</code></pre><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>scatter(水平坐标，垂直坐标，s=大小，c=颜色，cmap=颜色映射，marker=点型，alpha=透明度,label=标签)</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>40</td>
<td>1</td>
</tr>
<tr>
<td>20</td>
<td>30</td>
<td>2</td>
</tr>
<tr>
<td>30</td>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>40</td>
<td>10</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>scatter([10,20,30,40,[40,30,20,10].c=[1,2,3,4],cmap=’jet’)<br>实现正态分布的散点图代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp
n = 1000
x = np.random.normal(0, 1, n)  # 平均值0 1标准差的正态分布图
y = np.random.normal(0, 1, n)
z = np.sqrt(x**2 + y**2)  # 每个点到原点的距离
mp.figure(&apos;scatter&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;scatter&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;)
mp.xlabel(&apos;y&apos;)
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)
mp.scatter(x, y, s=60, c=z, cmap=&apos;jet_r&apos;, alpha=0.5)
mp.axis(&apos;equal&apos;)
mp.show()
</code></pre><h2 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h2><p>fill_between(水平坐标，起始垂直坐标，终止垂直坐标，填充条件，color=颜色，alpha=透明度）<br>示例代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp
n = 1000
x = np.linspace(0, 8 * np.pi, n)  # 平均值0 1标准差的正态分布图
sin_y = np.sin(x)
cos_y = np.cos(x) / 2


mp.figure(&apos;Fill&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;Fill&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;)
mp.xlabel(&apos;y&apos;)
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)

mp.plot(x, sin_y, c=&apos;dodgerblue&apos;, label=r&apos;$y=sin(x)$&apos;)
mp.plot(x, cos_y, c=&apos;orangered&apos;, label=r&apos;$y=cos(x)/2$&apos;)

mp.fill_between(x, cos_y, sin_y, cos_y &lt; sin_y, color=&apos;dodgerblue&apos;, alpha=0.5)
mp.fill_between(x, cos_y, sin_y, cos_y &gt; sin_y, color=&apos;orangered&apos;, alpha=0.5)

mp.legend()
mp.show()
</code></pre><h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><p>bar（水平坐标，高度(可以负数)，ec=边颜色，fc=填充色，label=标签）<br>高度为负数的时候，矩形图会画在0轴下方<br>示例代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp
n = 12
x = np.arange(n) 
y1 = (1 - x / n) * np.random.uniform(0.5, 1.0)  # 最小值 最大值
y2 = (1 - x / n) * np.random.uniform(0.5, 1.0)


mp.figure(&apos;Bar&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;Bar&apos;, fontsize=20)
mp.ylim(-1.25, 1.25)
mp.xlabel(&apos;x&apos;)
mp.xlabel(&apos;y&apos;)
mp.tick_params(labelsize=10)
mp.grid(axis=&apos;y&apos;, linestyle=&apos;:&apos;)  # 只在y方向画线
mp.xticks(x, x + 1)
mp.bar(x, y1, ec=&apos;orangered&apos;, fc=&apos;dodgerblue&apos;, label=&apos;y1&apos;)
for _x, _y in zip(x, y1):
    mp.text(_x, _y, &apos;%.2f&apos; % _y, ha=&apos;center&apos;, va=&apos;center&apos;, alpha=0.5)

mp.bar(x, -y2, ec=&apos;orangered&apos;, fc=&apos;dodgerblue&apos;, label=&apos;y2&apos;, alpha=0.5)
for _x, _y in zip(x, y2):
    mp.text(_x, -_y, &apos;%.2f&apos; % _y, alpha=0.5)


mp.legend()
mp.show()
</code></pre><h2 id="等高线"><a href="#等高线" class="headerlink" title="等高线"></a>等高线</h2><p>contour画等高线<br>contourf(点阵水平坐标，点阵垂直坐标，点阵直立坐标，高差份数，colors=颜色，linewidths=线宽）<br>contourf 画等高线，而且用指定颜色填充<br>contourf(点阵水平坐标，点阵垂直坐标，点阵直立坐标，高差份数，cmap=颜色映射）</p>
<p>加标签<br>clabel(等高线图对象，inline_spacing=线内空白，fmt=格式化串，fontsize=字体大小)<br>代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

n = 1000
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))
z = (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 - y**2)

mp.figure(&apos;contourf&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;contourf&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;)
mp.ylabel(&apos;y&apos;)
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)  # 只在y方向画线

cont = mp.contourf(x, y, z, 8, cmap=&apos;jet&apos;)
mp.clabel(cont, inline_spacing=1, fmt=&apos;%.2f&apos;, fontsize=12)

mp.legend()
mp.show()
</code></pre><h2 id="热成像图"><a href="#热成像图" class="headerlink" title="热成像图"></a>热成像图</h2><p>mp.imshow(矩阵，cmap=颜色映射，origin=纵轴方向)</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

n = 1000
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))
z = (1 - x / 2 + x**6 + y**4) * np.exp(-x**2 - y**2)

mp.figure(&apos;contourf&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;contourf&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;)
mp.ylabel(&apos;y&apos;)
mp.xticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))
mp.yticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)  # 只在y方向画线
mp.imshow(z, cmap=&apos;jet&apos;, origin=&apos;low&apos;)
mp.legend()
mp.show()
</code></pre><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><p>pie(值，间隙，标签，颜色，格式，shadow=阴影，startangle=起始角度<br>代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

values = [26, 17, 21, 29, 11]
spaces = [0, 0, 0, 0, 0]
labels = [&apos;python&apos;, &apos;java&apos;, &apos;c++&apos;, &apos;c&apos;, &apos;js&apos;]
colors = [&apos;dodgerblue&apos;, &apos;orangered&apos;, &apos;limegreen&apos;, &apos;violet&apos;, &apos;gold&apos;]


n = 1000
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))
z = (1 - x / 2 + x**6 + y**4) * np.exp(-x**2 - y**2)

mp.figure(&apos;pie&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;pie&apos;, fontsize=20)
mp.pie(values, spaces, labels, colors, &apos;%d%%&apos;, shadow=True, startangle=90)

mp.legend()
mp.show()
</code></pre><h2 id="坐标线"><a href="#坐标线" class="headerlink" title="坐标线"></a>坐标线</h2><p>grid(which=’major/minor’,axis=’x,y,both’,linewidths=线宽,linestyle=线型,color=颜色）<br>示例代码：</p>
<pre><code>import matplotlib.pyplot as mp


mp.figure(&apos;grid&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;grid&apos;, fontsize=20)
mp.xlabel(&apos;x&apos;)
mp.ylabel(&apos;y&apos;)

ax = mp.gca()
# ax.xaxis.set_major_locator(mp.MultipleLocator(20))
ax.xaxis.set_major_locator(mp.MultipleLocator(1.0))
ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))
ax.yaxis.set_major_locator(mp.MultipleLocator(1.0))
ax.yaxis.set_minor_locator(mp.MultipleLocator(0.1))


# mp.xticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))
# mp.yticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))
mp.tick_params(labelsize=10)

mp.grid(which=&apos;major&apos;, axis=&apos;both&apos;, linewidth=0.75,
        linestyle=&apos;:&apos;, color=&apos;lightgray&apos;)
mp.grid(which=&apos;minor&apos;, axis=&apos;both&apos;, linewidth=0.75,
        linestyle=&apos;-&apos;, color=&apos;lightgray&apos;)

mp.legend()
mp.show()
</code></pre><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p>mp.gca(projection=’polar’)<br>mp.plot/scatter(极角，极径）<br>代码如下：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as mp

t = np.linspace(0, 2 * np.pi, 1000)
r_spiral = 0.8 * t
r_rose = 5 * np.sin(6 * t)  # 6元玫瑰线


mp.figure(&apos;polar&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;polar&apos;, fontsize=20)
mp.xlabel(r&apos;$\theta$&apos;)
mp.ylabel(r&apos;$\rho$&apos;)

ax = mp.gca(projection=&apos;polar&apos;)
# ax.xaxis.set_major_locator(mp.MultipleLocator(20))


mp.tick_params(labelsize=10)

mp.grid(linestyle=&apos;:&apos;)
mp.plot(t, r_spiral, c=&apos;dodgerblue&apos;, label=r&apos;$\rho$ = 0.8$\theta$&apos;)
mp.plot(t, r_rose, c=&apos;orangered&apos;, label=r&apos;$\rho$ = sin($\theta$)&apos;)

mp.legend()
mp.show()
</code></pre><h2 id="三维曲面"><a href="#三维曲面" class="headerlink" title="三维曲面"></a>三维曲面</h2><p>from mpl_toolkits.mplot3d import axes3d<br>ax = mp.gca(projection=’3d’)<br>ax.set_xlabel(…)<br>ax.sety_label()<br>ax.set_zlabel()<br>ax.plot_surface(水平坐标 垂直坐标，直立坐标，rstride=行距，cstride=列距,cnap=颜色映射)<br>ax.plot_wireframe(水平坐标 垂直坐标，直立坐标，rstride=行距，cstride=列距,linewidth=线宽,color=颜色)</p>
<p>代码如下：</p>
<pre><code>from mpl_toolkits.mplot3d import axes3d
import numpy as np
import matplotlib.pyplot as mp

n = 1000
x, y = np.meshgrid(np.linspace(-3, 3, n), np.linspace(-3, 3, n))
z = (1 - x / 2 + x**6 + y**3) * np.exp(-x**2 - y**2)

mp.figure(&apos;3D&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;3D&apos;, fontsize=20)

ax = mp.gca(projection=&apos;3d&apos;)
ax.set_xlabel(&apos;x&apos;)
ax.set_ylabel(&apos;y&apos;)
ax.set_zlabel(&apos;z&apos;)
mp.tick_params(labelsize=10)


mp.xlabel(&apos;x&apos;)
mp.ylabel(&apos;y&apos;)
mp.xticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))
mp.yticks(np.linspace(0, 1000, 7), np.linspace(-3, 3, 7).astype(int))

# ax.plot_surface(x, y, z, rstride=10, cstride=10, cmap=&apos;jet&apos;)
# ax.plot_surface(x, y, z, rstride=10, cstride=10, cmap=&apos;gist_rainbow&apos;)

ax.plot_wireframe(x, y, z, rstride=20, cstride=20,
                  linewidth=0.5, color=&apos;orangered&apos;)

mp.show()
</code></pre><p>注释部分可以取消就会显示不同的效果。</p>
<h2 id="三维散点图"><a href="#三维散点图" class="headerlink" title="三维散点图"></a>三维散点图</h2><p>代码如下：</p>
<pre><code>from mpl_toolkits.mplot3d import axes3d
import numpy as np
import matplotlib.pyplot as mp

n = 1000
x = np.random.normal(0, 1, n)
y = np.random.normal(0, 1, n)
z = np.random.normal(0, 1, n)
d = np.sqrt(x**2 + y**2 + z**2)


mp.figure(&apos;3D scatter&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;3D scatter&apos;, fontsize=20)

ax = mp.gca(projection=&apos;3d&apos;)
ax.set_xlabel(&apos;x&apos;)
ax.set_ylabel(&apos;y&apos;)
ax.set_zlabel(&apos;z&apos;)
mp.tick_params(labelsize=10)

ax.scatter(x, y, z, s=60, c=d, cmap=&apos;jet&apos;)


mp.show()
</code></pre><h2 id="半对数坐标"><a href="#半对数坐标" class="headerlink" title="半对数坐标"></a>半对数坐标</h2><p>semilogy(参数同plot)<br>示例代码如下</p>
<pre><code>from mpl_toolkits.mplot3d import axes3d
import numpy as np
import matplotlib.pyplot as mp

y = np.array([1, 10, 100, 1000, 100, 10, 1])

mp.figure(&apos;normal and log&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;normal and log&apos;, fontsize=20)
mp.subplot(211)
mp.ylabel(&apos;y&apos;)
ax = mp.gca()
ax.xaxis.set_major_locator(mp.MultipleLocator(1))
ax.xaxis.set_minor_locator(mp.MultipleLocator(0.1))
ax.yaxis.set_major_locator(mp.MultipleLocator(250))
ax.yaxis.set_minor_locator(mp.MultipleLocator(50))
mp.tick_params(labelsize=10)

ax.grid(which=&apos;minor&apos;, axis=&apos;both&apos;, linewidth=0.25,
        linestyle=&apos;-&apos;, color=&apos;orangered&apos;)
ax.grid(which=&apos;major&apos;, axis=&apos;both&apos;, linewidth=0.25,
        linestyle=&apos;-&apos;, color=&apos;orangered&apos;)
mp.plot(y)
mp.subplot(212)
mp.semilogy(y)

mp.legend()
mp.show()
</code></pre><h2 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h2><p>import matplotlib.animation as ma<br>ma.FuncAnimation(图形对象，更新函数，[生成器函数，]interval=间隔毫秒) 每间隔interval毫秒，调用一次更新函数</p>
<p>生成气泡代码：<br>position x(float) y(float)<br>size 大小 (float)<br>growth  增速 (float)<br>color r g b颜色(float) 0-1之间的数 alpha</p>
<pre><code>import matplotlib.animation as ma
import numpy as np
import matplotlib.pyplot as mp

nbubbles = 100

# 生成100个气泡
bublles = np.zeros(nbubbles, dtype=[
    (&apos;position&apos;, float, 2),
    (&apos;size&apos;, float),
    (&apos;growth&apos;, float),
    (&apos;color&apos;, float, 4),
])

# 填充数据
bublles[&apos;position&apos;] = np.random.uniform(0, 1, (nbubbles, 2))
bublles[&apos;size&apos;] = np.random.uniform(50, 750, nbubbles)
bublles[&apos;growth&apos;] = np.random.uniform(30, 150, nbubbles)
bublles[&apos;color&apos;] = np.random.uniform(0, 1, (nbubbles, 4))

mp.figure(&apos;Bubbles&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;Bubbles&apos;)
mp.xticks(())
mp.yticks(())
sc = mp.scatter(bublles[&apos;position&apos;][:, 0], bublles[&apos;position&apos;]
                [:, 1], s=bublles[&apos;size&apos;], c=bublles[&apos;color&apos;])


def update(number):
    bublles[&apos;size&apos;] += bublles[&apos;growth&apos;]
    burst = number % nbubbles
    bublles[&apos;position&apos;][burst] = np.random.uniform(0, 1, 2)
    bublles[&apos;size&apos;][burst] = 0
    bublles[&apos;growth&apos;][burst] = np.random.uniform(30, 150)
    # bublles[&apos;size&apos;][burst] = 0
    bublles[&apos;color&apos;][burst] = np.random.uniform(0, 1, 4)
    # bublles[&apos;size&apos;][burst] = 0

    sc.set_sizes(bublles[&apos;size&apos;])


# 这里需要保证这个对象存在，必须增加变量保存
anim = ma.FuncAnimation(mp.gcf(), update, interval=10)
mp.show()
</code></pre><p>AttributeError: ‘NoneType’ object has no attribute ‘attributes’</p>
<p>使用生成器来画图：</p>
<pre><code>import matplotlib.animation as ma
import numpy as np
import matplotlib.pyplot as mp


mp.figure(&apos;signal&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;signal&apos;)
mp.xlabel(&apos;Time&apos;)
mp.ylabel(&apos;signal&apos;)

ax = mp.gca()
ax.set_ylim(-3, 3)
ax.set_xlim(0, 10)
mp.tick_params(labelsize=10)
mp.grid(linestyle=&apos;:&apos;)
pl = mp.plot([], [], c=&apos;orangered&apos;)[0]  # 建立缓冲区
pl.set_data([], [])  # 清理内部缓存内容


def update(data):
    # 得到数据之后，将数据添加到列表
    t, v = data
    x, y = pl.get_data()
    x.append(t)
    y.append(v)
    # 如果当前的t大于最大值，坐标轴也需要进行更新
    x_min, x_max = ax.get_xlim()
    if t &gt; x_max:
        ax.set_xlim(t - x_max + x_min, t)
        ax.figure.canvas.draw()
    pl.set_data(x, y)


def generator():
    t = 0
    while 1:
        v = np.sin(2 * np.pi * t) * np.exp(np.sin(0.2 * np.pi * t))
        yield t, v
        t += 0.05
anim = ma.FuncAnimation(mp.gcf(), update, generator, interval=5)
mp.show()
</code></pre><hr>
<h2 id="numpy的通用函数"><a href="#numpy的通用函数" class="headerlink" title="numpy的通用函数"></a>numpy的通用函数</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>文件格式</p>
<p>XXX XXX XXX XXX<br>XXX XXX XXX XXX<br>XXX XXX XXX XXX</p>
<p>loadtxt(<br>文件名，<br>delimiter=分割符,<br>usecols=选择列， 有的列不需要，选择自己需要的内容显示<br>unpack=True/False是否列展开，<br>dtype=目标类型,<br>converters=转换器<br>)<br>读取的内容需要是矩阵类型<br>返回值为 一维数组的元组，每个元素都是一个列 或者 二维数组，取决于unpack的值<br>实现股票K线图效果代码如下：</p>
<pre><code>import datetime as dt
import numpy as np
import matplotlib.pyplot as mp

import matplotlib.dates as md


def dmy2ymd(dmy):  # 将&apos;11-03-2011&apos;转换为&apos;2011-03-11&apos;
    dmy = str(dmy, encoding=&apos;utf-8&apos;)  # 格式为&apos;11-03-2011&apos;
    # print(dmy)
    date = dt.datetime.strptime(dmy, &apos;%d-%m-%Y&apos;).date()  # python解析日期时间
    ymd = date.strftime(&apos;%Y-%m-%d&apos;)
    return ymd

dates, opening_prices, highest_price, lowest_price, closing_price = np.loadtxt(
    &apos;./data/aapl.csv&apos;,
    delimiter=&apos;,&apos;,
    usecols=(1, 3, 4, 5, 6),
    unpack=True,  # 对列进行展开
    # dtype=np.dtype(&apos;U10&apos;),#运行后类型为U10
    dtype=np.dtype(&apos;M8[D],f8,f8,f8,f8&apos;),  # 运行后类型为datetime64[D]
    converters={1: dmy2ymd}  # 对第一列进行转换显示
)


print(dates.dtype, dates, sep=&apos;\n&apos;)
print(opening_prices.dtype, opening_prices, sep=&apos;\n&apos;)
print(highest_price.dtype, highest_price, sep=&apos;\n&apos;)
print(lowest_price.dtype, lowest_price, sep=&apos;\n&apos;)
print(closing_price.dtype, closing_price, sep=&apos;\n&apos;)


# 数据打印出来了，现在是需要显示的了

mp.figure(&apos;Candlestick&apos;, facecolor=&apos;lightgray&apos;)
mp.title(&apos;Candlestick&apos;, fontsize=20)
mp.xlabel(&apos;Date&apos;, fontsize=14)
mp.ylabel(&apos;Price&apos;, fontsize=14)

ax = mp.gca()
ax.xaxis.set_major_locator(
    md.WeekdayLocator(byweekday=md.MO)  # 以星期一为首日
)
ax.xaxis.set_minor_locator(
    md.DayLocator()  # 以天为单位显示
)
ax.xaxis.set_major_formatter(md.DateFormatter(&apos;%d %b %y&apos;))


mp.tick_params(labelsize=20)
mp.grid(linestyle=&quot;:&quot;)
dates = dates.astype(md.datetime.datetime)  # 转换为matplot可以识别的类型
# print(dates)
rise = (closing_price - opening_prices &gt;= 0.01)  # 收盘价-开盘价&gt;=0.01
fall = (opening_prices - closing_price &gt;= 0.01)  # 收盘价-开盘价&gt;=0.01
# print(rise)
&quot;&quot;&quot;
[False  True  True False False  True  True  True  True False  True  True
  True  True  True False False  True False  True  True False  True  True
 False False  True False False  True]

b = [T, F, T, F, T]
a = [10, 20, 30, 40, 50]
a[b] -&gt; [10, 30, 50]
&quot;&quot;&quot;

fc = np.zeros(dates.size, dtype=&apos;3f4&apos;)  # 3个 4字节浮点数
ec = np.zeros(dates.size, dtype=&apos;3f4&apos;)
fc[rise] = (1, 1, 1)  # 白色填充
fc[rise] = (0, 0.5, 0)

ec[rise] = (1, 0, 0)  # 红色
ec[rise] = (0, 0.5, 0)

mp.bar(dates, highest_price - lowest_price, 0,
       lowest_price, color=fc, edgecolor=ec)  # 画引线
mp.bar(dates, closing_price - opening_prices, 0.8,
       opening_prices, color=fc, edgecolor=ec)  # 画实体
mp.gcf().autofmt_xdate()  # 设置下面日期倾斜显示
mp.show()
</code></pre><h3 id="算术平均值"><a href="#算术平均值" class="headerlink" title="算术平均值"></a>算术平均值</h3><p>样本 s = [s1,s2,…sn]<br>算术平均数avg = sum(s)/n<br><strong>numpy.mean(S）</strong> -&gt; avg<br>算术平均值就是对真值得无偏估计</p>
<pre><code>import numpy as np        

closing_price = np.loadtxt(
    &apos;./data/aapl.csv&apos;,
    delimiter=&apos;,&apos;,
    usecols=(6),
    unpack=True,  # 对列进行展开
    dtype=np.dtype(&apos;f8&apos;),  # 运行后类型为datetime64[D]
)

mean = 0
for cp in closing_price:
    mean += cp
mean /= closing_price.size
print(mean)

mean = np.mean(closing_price)
print(mean)
</code></pre><p>其中aapl.csv里面的内容是：</p>
<pre><code>AAPL    28-01-2011      344.17  344.4   333.53  336.1   21144800
AAPL    31-01-2011      335.8   340.04  334.3   339.32  13473000
AAPL    01-02-2011      341.3   345.65  340.98  345.03  15236800
AAPL    02-02-2011      344.45  345.25  343.55  344.32  9242600
AAPL    03-02-2011      343.8   344.24  338.55  343.44  14064100
AAPL    04-02-2011      343.61  346.7   343.51  346.5   11494200
AAPL    07-02-2011      347.89  353.25  347.64  351.88  17322100
AAPL    08-02-2011      353.68  355.52  352.15  355.2   13608500
AAPL    09-02-2011      355.19  359 354.87  358.16  17240800
AAPL    10-02-2011      357.39  360 348 354.54  33162400
AAPL    11-02-2011      354.75  357.8   353.54  356.85  13127500
AAPL    14-02-2011      356.79  359.48  356.71  359.18  11086200
AAPL    15-02-2011      359.19  359.97  357.55  359.9   10149000
AAPL    16-02-2011      360.8   364.9   360.5   363.13  17184100
AAPL    17-02-2011      357.1   360.27  356.52  358.3   18949000
AAPL    18-02-2011      358.21  359.5   349.52  350.56  29144500
AAPL    22-02-2011      342.05  345.4   337.72  338.61  31162200
AAPL    23-02-2011      338.77  344.64  338.61  342.62  23994700
AAPL    24-02-2011      344.02  345.15  338.37  342.88  17853500
AAPL    25-02-2011      345.29  348.43  344.8   348.16  13572000
AAPL    28-02-2011      351.21  355.05  351.12  353.21  14395400
AAPL    01-03-2011      355.47  355.72  347.68  349.31  16290300
AAPL    02-03-2011      349.96  354.35  348.4   352.12  21521000
AAPL    03-03-2011      357.2   359.79  355.92  359.56  17885200
AAPL    04-03-2011      360.07  360.29  357.75  360 16188000
AAPL    07-03-2011      361.11  361.67  351.31  355.36  19504300
AAPL    08-03-2011      354.91  357.4   352.25  355.76  12718000
AAPL    09-03-2011      354.69  354.76  350.6   352.47  16192700
AAPL    10-03-2011      349.69  349.77  344.9   346.67  18138800
AAPL    11-03-2011      345.4   352.32  345 351.99  16824200
</code></pre><h3 id="加权平均值"><a href="#加权平均值" class="headerlink" title="加权平均值"></a>加权平均值</h3><p>样本 s = [s1,s2,…sn]<br>权重 w = [w1,w2,…wn]<br>加权平均值 a = (s1<em>w1 + s2</em>w2 +… sn*wn)/sum(w)<br>numpy.average(s,weights=w) -&gt; a<br>算术平均值就是各个样本权重相等时的加权平均值</p>
<p><strong>成交量加权平均值</strong><br>代码如下：</p>
<pre><code>import numpy as np
closing_price, volumes = np.loadtxt(
    &apos;./data/aapl.csv&apos;,
    delimiter=&apos;,&apos;,
    usecols=(6, 7),
    unpack=True,  # 对列进行展开
    dtype=np.dtype(&apos;f8,f8&apos;),  # 运行后类型为datetime64[D]
)

vwap = 0
for cp, vol in zip(closing_price, volumes):
    vwap += cp * vol
vwap /= volumes.sum()
print(vwap)

vwap = np.average(closing_price, weights=volumes)
print(vwap)
</code></pre><p><strong>时间加权平均值</strong></p>
<pre><code>import datetime as dt
import numpy as np

def dmy2days(dmy):  # 将&apos;11-03-2011&apos;转换为&apos;2011-03-11&apos;
    dmy = str(dmy, encoding=&apos;utf-8&apos;)  # 格式为&apos;11-03-2011&apos;
    date = dt.datetime.strptime(dmy, &apos;%d-%m-%Y&apos;).date()  # python解析日期时间
    days = (date - dt.date.min).days
    return days

days, closing_price = np.loadtxt(
    &apos;./data/aapl.csv&apos;,
    delimiter=&apos;,&apos;,
    usecols=(1, 6),
    unpack=True,  # 对列进行展开
    # dtype=np.dtype(&apos;f8,f8&apos;),  # 运行后类型为datetime64[D]
    # dtype=np.dtype(&apos;M8[D],f8,f8,f8,f8&apos;),  # 运行后类型为datetime64[D]
    converters={1: dmy2days}  # 对第一列进行转换显
)
print(days)
twap = 0
for day, cp in zip(days, closing_price):
    twap += cp * day
twap /= days.sum()
print(twap)

twap = np.average(closing_price, weights=days)
print(twap)
</code></pre><h3 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h3><p>max/min 在一个数组中寻找最大值/最小值<br>argmax/argmin 寻找一个数组中的最大值/最小值的下标<br>maximum/minimum 在两个数组的对应位置元素中寻找最大值/最小值<br>代码如下：</p>
<pre><code>import numpy as np
a = np.random.randint(10, 100, 9).reshape(3, 3)  # 产生的数据范围[10,100)，9个数据
print(a)
b = np.max(a)
c = np.min(a)
print(b, c)
d = np.argmax(a)
e = np.argmin(a)
print(d, e)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/python知识详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/python知识详解/" itemprop="url">python知识详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T08:35:53+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12,077 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  48 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>python由荷兰人Guido于1989编写</p>
<p>python2.x   python3.x<br>最新版本是2.7  3.7<br>版本2.x 和3.x是不兼容的，2.x在2020年将不再维护，所以本站所以内容都是基于3.6的环境来说的。（3.7版本已出，但是稳定性待测）</p>
<p>官网： <a href="http://www.python.org" target="_blank" rel="noopener">www.python.org</a>  查看文档，下载第三方包，下载python</p>
<h1 id="第一章-python介绍"><a href="#第一章-python介绍" class="headerlink" title="第一章 python介绍"></a>第一章 python介绍</h1><h2 id="python特点"><a href="#python特点" class="headerlink" title="python特点"></a>python特点</h2><p>1 简单 简洁<br>2 功能强大 （自动化脚本，爬虫，网站后端，算法，人工智能接口）<br>3 运行效率低，开发效率高<br>4 代码开放（开源）<br>5 python是一个胶水语言，可以很好的跟其他编程语言交互<br>6 python有很好的跨平台性能<br>7 python是解释型的，高级的，面向对象的编程语言</p>
<ul>
<li>解释型 ： 需要解释器对程序解释为计算机能识别的内容</li>
<li><p>编译型 ： 先通过编译器对程序进行编译，然后将编译结果进行执行即可</p>
</li>
<li><p>面向过程：以语句为中心按步骤办事</p>
</li>
<li>面向对象：以数据为中心调用对象办事</li>
</ul>
<h2 id="python干什么"><a href="#python干什么" class="headerlink" title="python干什么"></a>python干什么</h2><p>自动化运维<br>数据挖掘工程师<br>python web工程师<br>平台开发<br>大数据处理<br>人工智能开发</p>
<h2 id="python的安装"><a href="#python的安装" class="headerlink" title="python的安装"></a>python的安装</h2><ul>
<li><p>linux 下无需安装 </p>
</li>
<li><p>windows 下<br>1.下载想要安装的版本<br>2.双击安装<br>3.找到python.exe安装路径,添加到环境变量<br>如何添加环境变量详见 <a href="http://www.runoob.com/python/python-install.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-install.html</a></p>
</li>
</ul>
<h2 id="python的运行"><a href="#python的运行" class="headerlink" title="python的运行"></a>python的运行</h2><ul>
<li>在交互模式下运行<br>进入 ：  python3    ipython3<br>退出 ：  quit()     quit</li>
</ul>
<p>简单的python语句直接显示结果</p>
<h2 id="运行python程序"><a href="#运行python程序" class="headerlink" title="运行python程序"></a>运行python程序</h2><p>.py 为后缀的文件即为python程序<br>文件命名方法习惯使用英语单词<br>用数字字母下划线组成（首字母不要为数字，但是首字母数字运行也不会报错，此文件不能作为模块被其他程序导入）</p>
<p>第一种方法</p>
<ol>
<li>通过sublime编写python程序并保存 ，比如文件叫 hello.py</li>
<li>在响应的程序目录下通过 python3 hello.py 的形式运行程序</li>
</ol>
<p>第二种方法<br>1 在程序的第一行加上解释器位置</p>
<pre><code>#！/usr/bin/python3
</code></pre><p>2 将程序文件修改为有可行性权限</p>
<pre><code>chmod  766  hello.py
</code></pre><p>3 通过指明程序的路径即可运行</p>
<pre><code>./hello.py
</code></pre><p>更多方法<br>使用集成工具，例如pycharm spyder等，初学者还是老老实实的用sublime 或者 editplus 或者Notepad等偏文本编辑工具编写程序。</p>
<h2 id="python程序组成"><a href="#python程序组成" class="headerlink" title="python程序组成"></a>python程序组成</h2><p>数据 —&gt; 语句 —&gt;语句块 —&gt;模块 —-&gt;工程<br>1        x = 1    x = 1 y=2  hello.py  hello(文件夹）</p>
<p>程序 =  算法 + 数据结构</p>
<h2 id="python支持的数据类型-："><a href="#python支持的数据类型-：" class="headerlink" title="python支持的数据类型 ："></a>python支持的数据类型 ：</h2><p>数字 （整数  小数  复数）<br>字符串 （字串 单个字符）<br>布尔数据 （True  False）<br>列表  元组  字典   集合  Nonetype<br>文件  类类型   对象  </p>
<h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><h2 id="整型-int"><a href="#整型-int" class="headerlink" title="整型  int"></a>整型  int</h2><p>1 2 3  -100  0</p>
<h2 id="浮点型（小数）-float"><a href="#浮点型（小数）-float" class="headerlink" title="浮点型（小数）  float"></a>浮点型（小数）  float</h2><p>1.2  1.3  -3.4    1.2e+23 2.3e-23</p>
<h2 id="复数-complex"><a href="#复数-complex" class="headerlink" title="复数 complex"></a>复数 complex</h2><p>复数分为实部和虚部，虚部后面加j， j*j = -1</p>
<pre><code>&gt;&gt;&gt; (1+2j)*(3+4j)
(-5+10j)
</code></pre><p>运算表达式</p>
<p>表达式： 由一个数字或者数字和运算符构成</p>
<h2 id="算数运算符："><a href="#算数运算符：" class="headerlink" title="算数运算符："></a>算数运算符：</h2><pre><code>+   加法
-   减法
*   乘法
/   除法  得到浮点数  真除法
//  除法  取整数商    地板除
%   取余  
**  幂运算
</code></pre><ul>
<li>当高精度数据和低精度数据进行运算的时候结果自动转换为高精度</li>
</ul>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><pre><code>**

/  //  *  %  

+  -
</code></pre><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><strong>首先，python是通过缩进来表示层次关系的，在同一缩进层代表是平级关系。<br>在代码中严禁用空格和tab快捷键组合使用来进行缩进的</strong></p>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>自定义的标识符，用来代表某个值</p>
<p>标识符，即在编程中自己给需要起名的地方起的名字如：<br>变量名，类名，函数名等<br>1 数字字母下划线组成，$也是合法的<br>2 不能以数字开头<br>3 不能和python保留字（关键字）重复</p>
<p>合法变量举例：<br>a   a_b  a1  aaaa  get_name  _var<br>a$  a  A   1a</p>
<p>python关键字<br>if   for   is   not  True  …….</p>
<p>=  赋值符号 左侧为变量，右侧为要为变量赋予的值</p>
<h3 id="变量赋值规则"><a href="#变量赋值规则" class="headerlink" title="变量赋值规则"></a>变量赋值规则</h3><p>1  python中变量不需要提前定义，何时使用何时直接赋值就可以，初次赋值即称为变量的初始化<br>2  变量可以被多次赋值，后赋值内容会覆盖前面内容<br>3  python中变量没有固定类型，赋值什么类型的数据即为什么类型的变量</p>
<pre><code>a = 1
a = 1 + 1
b = a 
b = a * 3
c = b = a = 4
a,b = 1,2

a b 交换   c = a  a = b  b = c
           a,b = b,a
</code></pre><p>删除一个变量 del</p>
<pre><code>e.g.   del  a   
</code></pre><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>不可改变的量</p>
<pre><code>1 2 3  1.1   1.2  “hello”
[1,2,3]  (1,2,3)  {&apos;a&apos;:1,&apos;b&apos;:2}
</code></pre><h2 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型 bool"></a>布尔类型 bool</h2><p>True（逻辑真）   False（逻辑假） <strong>这里的首字母大写了</strong></p>
<h3 id="逻辑比较语句"><a href="#逻辑比较语句" class="headerlink" title="逻辑比较语句"></a>逻辑比较语句</h3><p>返回值都是bool类型</p>
<blockquote>
<p>  大于<br>&lt;   小于<br>=  大于等于<br>&lt;=  小于等于<br>==  逻辑相等<br>!=  不等于</p>
</blockquote>
<ul>
<li>a &lt; b &lt; c  python 中支持比较运算符的连续书写</li>
</ul>
<p>in<br>not in<br>is<br>is not</p>
<p>python 中关于True  和 False的其他规定</p>
<p>以下都是返回的False<br>0   0.0   0+0j<br>None值<br>空的字符串 “”<br>空的列表 []<br>空的集合 set()<br>空的元组 ()<br>空的字典 {}</p>
<p><strong> “ “不是False的真值表达式，返回的True,请注意中间有一个空格，其长度为0. </strong></p>
<h2 id="Nonetype"><a href="#Nonetype" class="headerlink" title="Nonetype"></a>Nonetype</h2><p>值 ： None<br>作用 ： 无意义，用作占位<br>        函数无返回值则返回一个None表示<br>    有时候用作形参的默认值</p>
<h2 id="复合运算符号"><a href="#复合运算符号" class="headerlink" title="复合运算符号"></a>复合运算符号</h2><pre><code>+=
y += x  ===&gt; y = y + x
-=
*=
/=
y /= x  ===&gt; y = y / x   
//=
%= 
**=
</code></pre><p>换行符<br>\  在书写中连接换行位置</p>
<p>e.g.<br>print\<br>(“I love China and I love Xidada”)</p>
<h2 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h2><p>注释 ： 对代码的解释说明在运行过程中不参与程序的运行</p>
<p>python中使用#引起单行注释，注释通常写在被标注代码的上方或者右侧</p>
<p>python中三引号可以当作多行注释使用</p>
<p>说明：良好的代码风格一般注释在15%以上</p>
<h2 id="内建函数的使用"><a href="#内建函数的使用" class="headerlink" title="内建函数的使用"></a>内建函数的使用</h2><p>内建函数 ： python提供的已经实现的函数，可以直接使用</p>
<ul>
<li>abs()  求绝对值内建函数</li>
</ul>
<p>abs(-9)  —-&gt; 9</p>
<ul>
<li><p>round(number,[ndigits])<br>默认对number四舍六入到整数，五根据实际情况处理。<br>ndigits 表示保留小数点后几位<br>round(1.234567,3) —&gt;1.235</p>
</li>
<li><p>float()  强制转换为浮点型</p>
</li>
<li>int() 强制转换为整型 （舍去精度）</li>
<li><p>bool() 强制转换为布尔类型</p>
<pre><code>In [125]: float(3)
Out[125]: 3.0

In [126]: int(1.234)
Out[126]: 1

In [127]: int(1.666)
Out[127]: 1

In [128]: bool(123)
Out[128]: True

In [129]: bool(0)
Out[129]: False
</code></pre></li>
</ul>
<ul>
<li>id()  查看一个变量的内存地址<br>1T = 1024 G<br>1G = 1024 M<br>1M = 1024 K<br>1K = 1024 byte（字节）<br>1字节 = 8 bit （位）</li>
</ul>
<p>如果id(a)和id(b)相同 则 a is b一定为True</p>
<ul>
<li><p>type()  查看一个变量/常量的类型 type是元类，关于元类这里不做解释。</p>
<pre><code>In [140]: type(a)
Out[140]: float
</code></pre></li>
<li><p><strong>help()</strong> 查看python内建函数或者模块的帮助<br>help（abs） q退出<br>help()函数在后面会经常用到的，是一个非常强大的函数，可以查看几乎所有的函数的说明。</p>
</li>
</ul>
<h2 id="基本输入输出"><a href="#基本输入输出" class="headerlink" title="基本输入输出"></a>基本输入输出</h2><h3 id="基本输入函数-input"><a href="#基本输入函数-input" class="headerlink" title="基本输入函数 input"></a>基本输入函数 input</h3><p>  作用<br>    从标准输入设备上读取一个字符串(末尾的换行符会被删除)<br>  格式:<br>    input(‘提示字符串’)<br>  说明：<br>  　　返回输入的字符串(仅python3)<br>    ‘提示字符串’ 可以为空</p>
<pre><code>n = input(&apos;please input a number: &apos;)
含义是从命令行输入一个数字，用变量n保存，保存格式为字符串，如果需要变为数字可以强制转换。
</code></pre><h3 id="基本输出函数-print"><a href="#基本输出函数-print" class="headerlink" title="基本输出函数　print"></a>基本输出函数　print</h3><p>  作用：<br>  　　将一系列的值以字符串形式输出到标准输出设备上，默认为终端<br>  格式<br>    print(value, …, sep=’ ‘, end=’\n’)<br>  选项的关键字参数为:<br>    sep 两个值之间的分隔符，默认为一个空格<br>    end 输出完毕后在流末尾自动追加一个字符，默认为换行符’\n’</p>
<h1 id="python流程控制语句-part1"><a href="#python流程控制语句-part1" class="headerlink" title="python流程控制语句 part1"></a>python流程控制语句 part1</h1><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><ul>
<li>作用：<br>　　让程序根据条件选择性的执行某条语句或某些语句</li>
<li>说明：<br>　　if 语句又叫条件语句，也叫分支语句</li>
<li><p>语法:</p>
<p> if 真值表达式1:<br>   　　语句块1<br> elif 真值表达式2:</p>
<pre><code>语句块2
</code></pre><p> elif 真值表达式3:</p>
<pre><code>语句块3
</code></pre><p> …<br> else:</p>
<pre><code>语句块4
</code></pre><ul>
<li>语法说明:<br>elif子句可以有0个,１个或多个<br>else子句可以有0个或1个且只能放在此if语句的最后</li>
<li>要求:<br>if语句内部的语句通常要以4个空格的缩进来表示包含关系，相同的缩进格式代表相同的所属级别</li>
</ul>
</li>
</ul>
<p>练习：<br>  任意输入一个数:</p>
<ol>
<li>判断这个数是否大于100</li>
<li>判断这个数是否小于0</li>
<li>判断这个数是否在20 ~ 50之间</li>
</ol>
<p>练习:</p>
<ol>
<li><p>输入个季度 1~4 输出这个季度有哪儿几个月，如果输入不是1~4的数，提示用户您的输入有误！</p>
</li>
<li><p>输入一年中的月份(1~12), 输出这个月在哪儿个季度，如果输入的是其它数，提示您的输入有误!</p>
</li>
</ol>
<p>if 语句的真值表达式</p>
<pre><code>if 100:
    print(&quot;真值&quot;)
# 等同于
if bool(100):
    print(&quot;真值&quot;)
</code></pre><p>bool(x) 返回假的情况:<br>  x为:<br>    0, 0.0, 0+0j, False, None,<br>    ‘’(空字符串)<br>    [] 空列表<br>    {} 空字典<br>    set() 空集合<br>    () 空元组<br>    ….</p>
<p>补充说明，字符串的空和空格字符串是不一样的，这里一定要区分开</p>
<pre><code>&gt;&gt;&gt; bool(&apos;&apos;)
False
&gt;&gt;&gt; bool(&apos; &apos;)
True
</code></pre><p><strong>补充说明：python没有switch case语句，所以只能通过if…elif…elif…else来实现多分支</strong></p>
<p><strong>elif 的写法也与大部分的语言中的else if不一样</strong></p>
<p>if语句嵌套<br>  if语句本身是由多条子句组成的一条复合语句<br>  if语句可以作为语句嵌套到另一个语句的内部</p>
<p>练习：<br>  输入一个学生的成绩(0~100),<br>  判断这个学生的成绩是优（90~100），良(80~89)，及格(60~79)，不及格，成绩不合法5种状态<br>  (建议使用if语句嵌套)</p>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>  语法:<br>    表达式1 if 真值表达式 else 表达式2<br>  作用：<br>    如果真值表达式的布尔环境值为True,则执行表达式1并返回结果的引用，否则执行表达式2并返回结果的引用</p>
<p>练习：<br>  写程序，输入一个数<br>    1) 用if语句计算出这个数的绝对值并打印出来<br>    2) 用条件表达式计算出这个数的绝对值并打印出来</p>
<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>  作用：<br>    通常用来填充语法空白<br>    pass 语句又名空语句<br>  语法:<br>    pass<br>  示例见:<br>    code/07_pass.py</p>
<h3 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算:"></a>布尔运算:</h3><p>  运算符:<br>    not   and    or</p>
<ul>
<li><p>布尔非操作 not<br>语法:<br>  not x<br>作用：<br>  对 x进行布尔取值,如 bool(x) 为True,则返回False, 否则返回True<br>示例:<br>  not True  # False<br>  not False  # True<br>  not 100  # False</p>
</li>
<li><p>布尔与操作 and<br>语法:<br>  x and y<br>  注: x, y代表表达式<br>作用：<br>  优先返回假值对象<br>  当bool(x)的值为False时，返回x,否则返回y<br>示例:</p>
<pre><code>True and True    # True
True and False   # False
False and True   # False
False and False  # False

&gt;&gt;&gt; 100 and 200
200
&gt;&gt;&gt; 0.0 and 200
0.0
&gt;&gt;&gt; 0 and 0.0
0
</code></pre></li>
</ul>
<ul>
<li><p>布尔或操作<br>语法:<br>  x or y<br>作用：<br>  优先返回真值对象,<br>  当x为True时返回x, 否则返回y<br>示例:</p>
<pre><code>True or True   # True
True or False  # True
False or True  # True
False or False # False
100 or 200   # 100
100 or 0.0   # 100
0 or 200     # 200
0 or 0.0     # 0.0
</code></pre></li>
</ul>
<p>思考以下代码是做什么用的:<br>  score = input(“请输入成绩: “) or ‘0’<br>  score = int(score)<br>  if score &lt; 0 or score &gt; 100:<br>      print(“您的成绩不合法!!!”)<br>  else:<br>      print(“您输入的成绩是:”, score)</p>
<h3 id="正负号运算符"><a href="#正负号运算符" class="headerlink" title="正负号运算符:"></a>正负号运算符:</h3><pre><code>+(正号) -(负号)
</code></pre><p>  语法:</p>
<pre><code>+ 表达式
- 表达式
</code></pre><p>  示例:<br>    a = 5<br>    b = -a<br>    c = +a</p>
<p>练习：</p>
<p>  1  北京出租车计费<br>    收费标准:<br>      3公里以内收费13元<br>      超过3公里后基本单价为 2.3元/公里<br>      空驶费: 超过15公里后，每公里加收基本单价的50%作为返程的空驶费(3.45元/公里)<br>    要求：<br>      输入公里数，打印出费用的金额(以元为单位进行四舍五入)</p>
<p>  2  输一个学生的三科成绩：</p>
<pre><code>1. 打印出最高分是多少分
2. 打印出最低分是多少分
3. 打印出平均分是多少分
</code></pre><p>  3  给出一个年份，判断是否为闰年并打印结果<br>    闰年规则: 每四年一闰，每百年不闰，四百年又是一个闰年<br>    例:<br>      2016年 闰年<br>      2100年 不是闰年<br>      2400年 是闰年</p>
<p>  4 BMI 指数(Body Mass Index) 以称身体质量指数<br>    BMI值计算公式:<br>         BMI = 体重(公斤)/ 身高(米)的平方<br>    例如:<br>       一个69公斤的人，身高是 173公分<br>       BMI = 69 / 1.73 ** 2 = 23.05<br>    标准表:<br>       BMI &lt; 18.5        体重过轻<br>       18.5 &lt;= BMI &lt;= 24 正常范围<br>       BMI &gt; 24          体重过重（超标)<br>    输入身高和体重，打印BMI值，并打印体重状况</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>python中的循环语句有2种，分别为while 语句 for 语句</p>
<h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><p>问题:<br>  输入一个数用n绑定,打印出n行的”hello world!”<br>  print(“hello world!”)</p>
<p>while 语句:<br>作用：<br>    根据一定条件，重复的执行一条语句或多条语句<br>语法:<br>while 真值表达式:<br>  语句块<br>else:<br>  语句块</p>
<p>示例:</p>
<pre><code>while n &gt; 0:
    print(&quot;hello world!&quot;)
    n -= 1
</code></pre><p>练习：<br>  编写程序，用while语句解决下面的问题<br>  问题:<br>    输入一个数用n绑定,打印出n行的”hello world!”</p>
<p>练习：</p>
<ol>
<li><p>输入一个整数,用end变量绑定，打印出 1~end的所有整数，(包含end)</p>
</li>
<li><p>写程序，输入二个整数，第一个用begin绑定，第二个用end变量绑定，打印出 begin~end的所有的整数</p>
</li>
</ol>
<p>while 语句语法说明:</p>
<p>1  先执行真值表达式，判断True/False<br>2  如果为True则执行语句块1,然后跳转到第1步<br>3  如果为 False则执行else子句部分的语句块2.然后结束此while语句的执行.如果没有else子句，则直接结束此while语句<br>4  else 子句部分可以省略(同if语句类似)</p>
<p>while 注意事项:</p>
<p>1  要控制真值表达式来访问死循环<br>2  通常用真值表达式内的变量来控制循环条件<br>3  通常要在循环语句块内改变循环变量来控制循环的次数和变量的走向</p>
<p>练习:</p>
<ol>
<li>打印 1~ 20的整数，打印在一行内显示，每个数字之间用一个空格分隔开<br>如:<br> 1 2 3 4 5 6 … 18 19 20<br>(提示:print(…. , end=’ ‘) 可以不换新行)</li>
<li>打印 1~ 20的整数，每行5个，打印四行，如:<br>1 2 3 4 5<br>6 7 8 9 10<br>….<br>….<br>(注: while语句内可以嵌入if语句)</li>
<li>用while语句打印 10 ~ 1的所有整数(包含1)</li>
</ol>
<p>练习:</p>
<ol>
<li><p>写程序，用while循环来计算<br>1 + 2 + 3 + 4 + ….+ 99 + 100的和</p>
</li>
<li><p>用while 语句实现打印三角形,输入一个整数，表示三角形的宽度和高度，打印出相应的直角三角形<br>如:<br>请输入三角形宽度: 4<br>打印如下:<br>*<br>**</p>
<hr>
<hr>
</li>
</ol>
<p><strong>while 语句嵌套</strong><br>  while 语句本身是语句，和其它语句一样，可以放在其它复合语句的内部<br>while 嵌套示意<br>  while 真值表达式:<br>      …<br>      while 真值表达式2:<br>          …<br>      else:<br>          …<br>      …<br>  else:<br>      …</p>
<p>问题:<br>  打印1~20 之间的整数打印在一行<br>   1 2 3 4 …. 18 19 20<br>  把以上的数据打印10行 </p>
<p>练习:<br>  输入一个数，打印指定宽度的正方形<br>  如:<br>    请输入: 5<br>  打印如下正方形:<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>  如:<br>    请输入: 4<br>  打印如下:<br>    1 2 3 4<br>    1 2 3 4<br>    1 2 3 4<br>    1 2 3 4</p>
<h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h3><p>  作用：<br>    用于循环语句(while,for语句)中，用来终止当前循环语句的执行</p>
<p>break说明</p>
<p>1  当break语句执行后，此循环语句break之后的语句将不再执行<br>2  break语句通常和if语句组合使用<br>3  break语句终止循环时，循环语句的else子句的语句将不会执行<br>4  break语句只能终止当前循环语句的执行，如果有循环嵌套时，不会跳出嵌套的外重循环<br>5  break 语句只能在循环语句(while或for语句)内部使用</p>
<p><strong>死循环:</strong></p>
<p>  死循环是指循环条件一直成立的循环<br>  死循环通常用break语句来终止循环<br>  死循环的else子句永远不会执行</p>
<p>示例:</p>
<pre><code>while True:
  n = int(input(&quot;请输入: &quot;))
  if n == 0:
      break
  print(n)
</code></pre><p>练习:</p>
<pre><code>1. 任意输入一些整数，
每次输入一个,当输入负数时结束输入,当输入完成后，打印您输入的这些数的和
2. 写程序用while实现打印三角形。
要求输入一个整数表示三角形的宽度和高度,打印出如下的三种直角三角形
1)
    *
   **
  ***
 ****
2)
 ****
  ***
   **
    *
3) 
 ****
 ***
 **
 *
3. 写程序求多项式的和:
1/1 - 1/3 + 1/5 - 1/7 + 1/9 ... + 1/(2*n-1) 的和
n最大取： 1000000
1) 打印这个和
2) 打印这个和乘以4的值?(看看这个数眼熟不?)
</code></pre><h2 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h2><p>作用：<br>  　用来遍历可迭代对象的数据元素</p>
<p>可迭代对象是指能依次获取数据元素的对象<br><strong>可迭代对象包括:</strong><br>  字符串 str<br>  —以下后再会讲—-<br>  列表 list<br>  元组 tuple<br>  字典 dict<br>  集合set<br>  …</p>
<h3 id="for-语句语法"><a href="#for-语句语法" class="headerlink" title="for 语句语法"></a>for 语句语法</h3><p>  for 变量列表　in 可迭代对象:<br>      语句块1<br>  else:<br>      语句块2</p>
<p>练习:<br>  任意输入一个字符串，判断这个字符串中有几个空 格’ ‘<br>  (要求不允许用S.count方法)<br>  建议使用for语句实现</p>
<h3 id="for-语法说明"><a href="#for-语法说明" class="headerlink" title="for 语法说明"></a>for 语法说明</h3><ol>
<li>可迭代对象每次提供一个元素依次赋值给变量列表中的变量，赋值完毕后执行语句块1,重复执行此步骤，直到可迭代对象不能提供数据为止</li>
<li>可迭代对象提供完所有元素后，执行else子句部分的语句块２，然后退出此for语句</li>
<li>else子句部可以省略（同while语句类似)</li>
<li>当在循环内部用break终止循环时，else子句部分语句不会执行</li>
</ol>
<h3 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h3><p>  格式见:<br>    &gt;&gt;&gt; help(range)</p>
<p>函数:<br>  range(stop)  从零开始，每次生成一个整数后加１操作，直到stop为止（不包含stop)<br>  range(start, stop[, step]) 从start开始，每次生成一个整数后移动step，直到stop为止(不包含stop,且step可以是负整数)<br>作用:<br>  用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)<br>说明:<br>  range返回的对象是可迭代对象.可以用于for语句中<br>示例:<br>  range(4)         # 生成0,1,2,3<br>  range(3, 6)      # 生成 3, 4, 5<br>  range(1, 10, 2)  # 生成 1,3,5,7,9<br>  range(5, 0, -2)  # 生成 5,3,1<br>  range(4, 0)      # 空</p>
<p>练习:<br>  用for语句打印 1~20的整数，打印在一行<br>  1 2 3 4 5 6 … 18 19 20</p>
<p>练习:</p>
<ol>
<li><p>求 100 以内有哪儿些整数与　自身 + 1 的乘积再对11 求余结果等于8?</p>
</li>
<li><p>计算 1 + 3 + 5 + 7 +…. + 99的和<br>用while 和 for语句两种方法来实现</p>
</li>
</ol>
<h3 id="for语句嵌套"><a href="#for语句嵌套" class="headerlink" title="for语句嵌套"></a>for语句嵌套</h3><p>  for语句内部可以放任意语句,包含for语句和while语句</p>
<p>示例:<br>  for x in “ABC”:<br>      for y in ‘123’:<br>          print(x + y)</p>
<p>  思考 count 的值是多少？<br>  count = 0<br>  for x in range(5):<br>      for y in range(10):<br>          count += 1<br>  print(count)  # 50<br>  print(x, y)  # x,y的值是多少?<br>练习:<br>  1 写程序．输入一个整数n 代表正方形的宽度和高度．<br>  打印数字组成的正方形:<br>   如<br>     输入: 5<br>   打印:<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>    1 2 3 4 5<br>   　　输入: 4<br>   打印:<br>    1 2 3 4<br>    1 2 3 4<br>    1 2 3 4<br>    1 2 3 4</p>
<p>  2 写程序．输入一个整数n 代表正方形的宽度和高度．<br>  打印数字组成的正方形:<br>   如<br>     输入: 5<br>   打印:<br>    1 2 3 4 5<br>    2 3 4 5 6<br>    3 4 5 6 7<br>    4 5 6 7　8<br>    5 6 7　8 9<br>   　　输入: 4<br>   打印:<br>    1 2 3 4<br>    2 3 4 5<br>    3 4 5 6<br>    4 5 6 7</p>
<h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h3><p>  作用:<br>    用于循环语句(while, for语句)中，不再执行本次循环内continue之后的语句，重新开始一次新的循环<br>  说明:<br>    1.　在while语句中，执行continue语句将会直接跳转到while语句的真值表达式处重新判断循环条件</p>
<pre><code>2. 在for语句中，执行 continue语句，将会从可迭代对象中取下一个元素，绑定变量后再次进行循环
</code></pre><p>  示例:<br>    见: code/03_continue.py<br>    for x in range(5):<br>        if x == 2:<br>            continue<br>        print(x)</p>
<p>练习:<br>  输入一个整数用begin绑定，再输入一个整数用end绑定，打印出从begin~end(包含end)的所有偶数<br>    (建议用continue语句跳过奇数)</p>
<p>用while循环，实现打印10以内的偶数<br>  i = 0<br>  while i &lt; 10:<br>     print(i)<br>     i += 2<br>  用continue 和 while语句的实现方法:<br>  见: code/04_while_continue.py</p>
<p>练习:<br>  求 1 ~ 100(包含100) 之间所有不能被5,7,11整除的数的和是多少?<br>    (建议用continue语句实现)</p>
<h3 id="循环总结"><a href="#循环总结" class="headerlink" title="循环总结"></a>循环总结</h3><p>  while 语句<br>  for 语句</p>
<pre><code>- 字符串
- range() 函数
</code></pre><p>  break 语句<br>  continue 语句</p>
<p>练习:<br>  输入一个整数n, 判断这个整数是否是素数(prime)<br>    (素数是指只能被1 和自身整除的数)<br>    如:<br>      2 3 5 7 11…<br>    方法：<br>      用排除法.一但n能被2~n-1的数整除就不是素数，否则就一定是素数</p>
<hr>
<h1 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串 str"></a>字符串 str</h1><h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p>作用：<br>用来记录文本（文字）信息</p>
<p>字符串的表示方法：<br>在非注释中，凡是用引号括起来的部分都是字符串<br>‘   单引号<br>“   双引号<br>‘’’ 三单引号<br>“”” 三双引号</p>
<p>空字符串的字面值表示方式<br>‘’<br>“”<br>‘’’’’’<br>“”””””</p>
<p>非空字符串的字面值表示方式<br>‘hello’<br>“hello”<br>‘’’hello’’’<br>“””hello”””</p>
<p>单引号和双引号的区别:<br>单引号内的双引号不算结束符<br>双引号内的单引号不算结束符</p>
<p>三引号字符串:<br>作用：<br>  三引号字符串的换行会自动转换为换行符’\n’<br>  三引号内可以包含单引号和双引号<br>如何表示:<br>‘welcome to beijing\nI like python!\nI am studing!’<br>s = ‘’’welcome to beijing<br>I like python!<br>I am studing!’’’</p>
<p>用转义序列代表特殊字符<br>  字符串字面值中，用字符反斜杠() 后跟一些字符代表一个字符</p>
<p>字符串中的转义字符表</p>
<pre><code>\&apos;    代表一个单引号
\&quot;    一个双引号
\\    代表一个反斜杠
\n    换行
\r    返回光标至行首
\f    换页
\t    水平制表符
\v    垂直制表符
\b    倒退
\0    空字符，字符值为0
\0oo  oo 为两位八进制表示的字符
\xXX  XX为两位十六进制表示的字符
\uXXXX  Unicode16的十六进制表示的字符
\UXXXXXXXX Unicode32的十六进制表示的字符
</code></pre><p>ASCII编码:<br>  查看ASCII 字符表<br>  $ man ascii</p>
<p>常用ASCII编码:<br>字符   十进制   十六进制<br>‘0’     48      0x30<br>‘A’     65      0x41<br>‘a’     97      0x61</p>
<h2 id="raw-字符串-原始字符串"><a href="#raw-字符串-原始字符串" class="headerlink" title="raw 字符串(原始字符串)"></a>raw 字符串(原始字符串)</h2><p>  字面值格式:</p>
<pre><code>r&apos;字符串内容&apos;
r&quot;字符串内容&quot;
r&apos;&apos;&apos;字符串内容&apos;&apos;&apos;
r&quot;&quot;&quot;字符串内容&quot;&quot;&quot;
</code></pre><p>  作用：让转义字符 \ 无效</p>
<p>  示例:</p>
<pre><code>a = &apos;C:\newfile\test.py&apos;
print(a)
print(len(a))  # 得到字符串的长度
a = r&apos;C:\newfile\test.py&apos;
print(a)
print(len(a))
</code></pre><h2 id="字符串的运算"><a href="#字符串的运算" class="headerlink" title="字符串的运算:"></a>字符串的运算:</h2><p>  算术运算符:</p>
<pre><code>+  +=  *  *= 
</code></pre><p>  + 加号运算符用于字符串的拼接</p>
<p>  例:</p>
<pre><code>x = &apos;abcd&apos; + &apos;efg&apos;
print(x)  # abcdefg
x += &apos;123&apos;
print(x)  # abcdefg123
</code></pre><p>  * 运算符用于生成重复的字符串</p>
<pre><code>x = &apos;123&apos;
y = x * 2  # y = &apos;123123&apos;

x *= 3   # x = &apos;123123123&apos;
x = 3
x *= &apos;123&apos; # x = &apos;123123123&apos;
</code></pre><p>练习：<br>  写一个程序，打印一个高度为4的矩形方框<br>  要求输入一个整数，此整数代表矩形的宽度，输出此矩形<br>  如:<br>   请输入宽度: 10<br>   打印如下:</p>
<pre><code>##########
#        #
#        #
##########
</code></pre><h2 id="字符串的比较运算"><a href="#字符串的比较运算" class="headerlink" title="字符串的比较运算"></a>字符串的比较运算</h2><p>运算符:</p>
<pre><code>&gt;  &gt;=  &lt;  &lt;=  ==  != 
</code></pre><p>示例:</p>
<pre><code>&apos;A&apos; &lt; &apos;B&apos;      # True
&apos;B&apos; &lt; &apos;a&apos;      # True
&apos;ABC&apos; &gt; &apos;AB&apos;   # True
&apos;AD&apos; &lt; &apos;ABC&apos;   # False
&apos;ABC&apos; == &apos;abc&apos; # False
</code></pre><h2 id="in-not-in-运算符"><a href="#in-not-in-运算符" class="headerlink" title="in / not in 运算符"></a>in / not in 运算符</h2><p>作用: in 用于序列，字典，集合中，用于判断某个值是否存在于容器中，如果存在则返回True, 否则返回False<br>格式: 对象 in 容器<br>示例:</p>
<pre><code>s = &apos;welcome to tarena!&apos;
&apos;to&apos; in s  # True
&apos;weimingze&apos; in s  # False
</code></pre><h2 id="字符串的索引操作"><a href="#字符串的索引操作" class="headerlink" title="字符串的索引操作"></a>字符串的索引操作</h2><p>  python 字符串str是不可以改变的字符序列</p>
<h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h3><p>索引语法:字符串[整数表达式]<br>说明</p>
<ul>
<li>python 序列都可以用索引(index) 来访问序列中的对象(元素)</li>
<li>python 序列的正向索引是从0开始的，第二个索引为1,最后一个索引为len(s) -1</li>
<li>python 序列的反向索引是从-1开始的，-1代表最后一个，-2代表倒数第二个，第一个是-len(s)</li>
</ul>
<p>示例:</p>
<pre><code>s = &apos;ABCDE&apos;
print(s[0])  # A
print(s[1])  # B
print(s[4])  # E
</code></pre><h3 id="切片-slice"><a href="#切片-slice" class="headerlink" title="切片 slice"></a>切片 slice</h3><p>从字符串序列中取出相应的元素重新组成一个字符串序列</p>
<p>语法:s[(开始索引b):(结束索引e)(:(步长s))]<br>注:小括号() 括起的部分代表可省略</p>
<p>语法说明:<br>开始索引是切片开始切下的位置0代表第1个，<br>结束索引是切片的终止索引（但不包含终止点)<br>步长是切片每次获取完当前元素后移动的方向和偏移量</p>
<p>  1 没有步长，相当于取值完成后向右移动一个索引的位置（默认为1)<br>  2 当步长为正数时，取正向切片:<br>    步长默认为1,开始索引默认为0, 结束索引默认为len(s)<br>  3 当步长为负整数时，取反向切片<br>     反向切片时。默认的起始位置为最后一个元素，终止位置是第一个元素的前一个位置</p>
<p>示例:</p>
<pre><code>s = &apos;ABCDE&apos;
a = s[1:4]  # a--&gt; &apos;BCD&apos;
a = s[:4]   # a--&gt; &apos;ABCD&apos;
a = s[2:]   # a--&gt; &apos;CDE&apos;
a = s[0:2]  # a--&gt; &apos;AB&apos;
a = s[1:1]  # a--&gt; &apos;&apos;
a = s[3:1]  # a--&gt; &apos;&apos;  空字符串
a = s[::2]  # a--&gt; &apos;ACE&apos;
a = s[2::2] # a--&gt; &apos;CE&apos;
a = s[::-1] # a--&gt; &apos;EDCBA&apos; 
a = s[3::-2] # a--&gt; &apos;DB&apos;
</code></pre><p>练习：<br>　　1. 输入一个字符串，打印如下内容<br>     1) 打印这个字符串的第一个字符<br>     2) 打印这个字符串的最后一个字符<br>     3) 如果这个字符串长度是奇数，打印中间这个字符<br>     (注: 求字符串长度的函数是 len(s))</p>
<ol start="2">
<li>输入任意一个字符串，判断这个字符串是否是回文<br>　　回文是指中心对称的文字<br>如:<br> 上海自来水来自海上<br> ABCCBA</li>
</ol>
<h2 id="Python3中常用的函数"><a href="#Python3中常用的函数" class="headerlink" title="Python3中常用的函数"></a>Python3中常用的函数</h2><ul>
<li>len(seq)  返回序列的长度</li>
<li>max(x)    返回序列的最大值元素</li>
<li>min(x)    返回序列的最小值元素</li>
</ul>
<p>示例:</p>
<pre><code>s = &quot;ABCD&quot;
print(len(s))  # 4
print(max(s))  # D
print(min(s))  # A
</code></pre><p><strong>字符串编码转换函数</strong></p>
<ul>
<li>ord(c)  返回一个字符串的Unicode编码值</li>
<li>chr(i)  返回i这个值所对应的字符</li>
</ul>
<p>示例:</p>
<pre><code>print(ord(&apos;A&apos;))  # 65
print(ord(&apos;中&apos;)) # 

#以下语句是通过循环打印26个字母
for x in range(26):
    print(chr(ord(&apos;a&apos;)+x))
</code></pre><p>练习：</p>
<ol>
<li><p>写一个程序，输入一段字符串，如果字符串不为空，则把第一个字符的编码打印出来</p>
</li>
<li><p>写一个程序，输入一个整数值(0~65535)，打印出这个数值所对应的字符</p>
</li>
</ol>
<p><strong>整数转换为字符串函数</strong></p>
<ul>
<li>hex(i)  将整数转换为十六进制的字符串</li>
<li>oct(i)  将整数转换为八进制字符串</li>
<li>bin(i)  将整数转换为二进制字符串</li>
</ul>
<p><strong>字符串的构造(创建)函数 str</strong></p>
<ul>
<li>str(obj=’’)  将对象转换为字符串</li>
</ul>
<p>示例:</p>
<pre><code>s = 123
print(str(s) + &apos;456&apos;)  # 123456
</code></pre><p>练习:<br>  1.　用字符串<em> 运算符打印三角形<br>    要求输入一个整数，此整数代表此三角形离左侧的字节数<br>    如:<br>      $ python3 tri_angle.py<br>      请输入离左侧的距离: 3<br>      则打印:
          </em><br>         <strong><em><br>        **</em></strong><br>       <strong>***</strong></p>
<ol start="2">
<li>输入三行文字，让这三行文字在一个方框居中显示<br>如输入(不要输入中文):<br>hello tarena!<br>my name is weimingze<br>python<br>显示如下:<br>+———————-+<br>|    hello tarena!     |<br>| my name is weimingze |<br>|        python        |<br>+———————-+</li>
</ol>
<h2 id="常用的字符串方法"><a href="#常用的字符串方法" class="headerlink" title="常用的字符串方法:"></a>常用的字符串方法:</h2><p>字符串方法的调用语法<br>对象.方法名(方法传参)<br>注:<br>  方法的调用属于表达式，通常可以返回一个值或None</p>
<p><strong>字符串中反斜杠字符表</strong></p>
<table>
<thead>
<tr>
<th>转义格式</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\’</td>
<td>单引号(‘)</td>
</tr>
<tr>
<td>\”</td>
<td>双引号(“)</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠(\ )</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>返回光标至行首</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符</td>
</tr>
<tr>
<td>\v</td>
<td>重直制表符</td>
</tr>
<tr>
<td>\b</td>
<td>倒退</td>
</tr>
<tr>
<td>\0</td>
<td>空字符，字符值为零</td>
</tr>
<tr>
<td>\0oo</td>
<td>oo为两位八进制表示的字符</td>
</tr>
<tr>
<td>\xXX</td>
<td>XX为两位十六进制表示的字符</td>
</tr>
<tr>
<td>\uXXXX</td>
<td>Unicode 16的十六进制表示的字符</td>
</tr>
<tr>
<td>\UXXXXXXXX</td>
<td>Unicode 32的十六进制表示的字符</td>
</tr>
</tbody>
</table>
<p><strong>常用字符串方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S.isdigit()</td>
<td>判断字符串中的字符是否全为数字</td>
</tr>
<tr>
<td>S.isalpha()</td>
<td>判断字符串是否全为英文字母</td>
</tr>
<tr>
<td>S.islower()</td>
<td>判断字符串所有字符是否全为小写英文字母</td>
</tr>
<tr>
<td>S.isupper()</td>
<td>判断字符串所有字符是否全为大写英文字母</td>
</tr>
<tr>
<td>S.isspace()</td>
<td>判断字符串是否全为空白字符</td>
</tr>
<tr>
<td>S.center(width[,fill])</td>
<td>将原字符串居中，左右默认填充空格</td>
</tr>
<tr>
<td>S.count(sub[, start[,end]])</td>
<td>获取一个字符串中子串的个数</td>
</tr>
<tr>
<td>S.find(sub[, start[,end]])</td>
<td>获取字符串中子串sub的索引,失败返回-1</td>
</tr>
<tr>
<td>S.strip()</td>
<td>返回去掉左右空白字符的字符串</td>
</tr>
<tr>
<td>S.lstrip()</td>
<td>返回去掉左侧空白字符的字符串</td>
</tr>
<tr>
<td>S.rstrip()</td>
<td>返回去掉右侧空白字符的字符串</td>
</tr>
<tr>
<td>S.upper()</td>
<td>生成将英文转换为大写的字符串</td>
</tr>
<tr>
<td>S.lower()</td>
<td>生成将英文转换为小写的字符串</td>
</tr>
<tr>
<td>S.replace(old, new[, count])</td>
<td>将原字符串的old用new代替，生成一个新的字符串</td>
</tr>
<tr>
<td>S.startswith(prefix[, start[, end]])</td>
<td>返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False,</td>
</tr>
<tr>
<td>S.endswith(suffix[, start[, end]])</td>
<td>返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False</td>
</tr>
<tr>
<td>S.title()</td>
<td>生成每个英文单词的首字母大写字符串</td>
</tr>
<tr>
<td>S.isnumeric()</td>
<td>判断字符串是否全为数字字符</td>
</tr>
</tbody>
</table>
<p><strong>空白字符</strong><br>是指空格,水平制表符(\t),换行符(\n)等不可见的字符</p>
<p><strong>格式化字符串中的占位符和类型码</strong></p>
<table>
<thead>
<tr>
<th>占位符类型码</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%r</td>
<td>字符串，使用repr 而不是str</td>
</tr>
<tr>
<td>%c</td>
<td>整数转为单个字符</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数(字符a-f小写)</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制整数(字符A-F大写)</td>
</tr>
<tr>
<td>%e</td>
<td>指数型浮点数(e小写),如2.9e+10</td>
</tr>
<tr>
<td>%E</td>
<td>指数型浮点数(E大写),如2.9E+10</td>
</tr>
<tr>
<td>%f, %F</td>
<td>浮点十进制形式</td>
</tr>
<tr>
<td>%g, %G</td>
<td>十进制形式浮点或指数浮点自动转换</td>
</tr>
<tr>
<td>%%</td>
<td>等同于一个%字符</td>
</tr>
</tbody>
</table>
<p>字符串的格式化表达式<br>作用:<br>生成一定格式的字符串<br>运算符 %<br>语法格式<br>格式字符串 % 参数值<br>格式字符串 % (参数值1, 参数值2, …)<br>说明:<br>格式化字符串中以%开头的为占位符,占位符的位置将用参数值替换<br>% 右侧为参数值，当有多个参数值时用括号() 括起来，之间用逗号(,) 分隔<br>示例:</p>
<pre><code>fmt = &quot;姓名: %s, 年龄: %d&quot;  
name = &apos;tarena&apos;
age = 15
print(fmt % (name, age))
</code></pre><p>占位符和类型码之间的格式语法<br> % [格式语法] 类型码<br>   格式语法：</p>
<pre><code>- 左对齐
+ 显示正号
0 补零
宽度(整数)
宽度.精度(整数)
</code></pre><p>  示例:</p>
<pre><code>&apos;%10d&apos; % 123   # &apos;       123&apos;
&apos;%-10d&apos; % 123  # &apos;123       &apos;
&apos;%10s&apos; % &apos;abc&apos; # &apos;       abc&apos; 
&apos;%-5s&apos; % &apos;abc&apos; # &apos;abc  &apos;
&apos;%05d&apos; % 123   # &apos;00123&apos;
&apos;%7.3f&apos; % 3.1415926  # &apos;003.142&apos;
</code></pre><p>练习:<br>  输入三行文字，让这些文字依次以20字符的宽度右对齐输出.<br>  如:<br>  请输入第1行: hello world<br>  请输入第2行: abcd<br>  请输入第3行: a<br>  输出结果为:</p>
<pre><code>hello world
       abcd
          a
</code></pre><p>  做完上面的题后再思考:<br>    能否以最长字符串的长度进行右对齐显示(左侧填充空格)</p>
<h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h1><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>  列表是由一系列特定元素组成的，元素和元系之间没有任何关联关系，但他们之间有先后顺序关系<br>  列表是一种容器<br>  列表是序列的一种<br>  列表是可以被改变的序列</p>
<p>python中的序列类型简介(sequence)<br>  字符串 str<br>  列表 list<br>  元组 tuple<br>  字节串 bytes<br>  字节数组 bytearray</p>
<h2 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h2><p>创建空列表的字面值<br>  L = []  # L绑定空列表</p>
<p>创建非空列表:<br>  L = [1, 2, 3, 4]<br>  L = [“北京”, “上海”, “重庆”]<br>  L = [1, ‘two’, 3, ‘四’]<br>  L = [1, 2, [3.1, 3.2, 3.3], 4] </p>
<h2 id="列表的构造-创建-函数list"><a href="#列表的构造-创建-函数list" class="headerlink" title="列表的构造(创建)函数list"></a>列表的构造(创建)函数list</h2><p>  list()  生成一个空的列表 等同于[]<br>  list(iterable)  用可迭代对象创建一个列表<br>示例:<br>  L = list()  L 为空列表,等同于 L = []<br>  L = list(“ABCD”)  # L-&gt;[‘A’,’B’,’C’,’D’]<br>  L = list(range(1, 10, 2))</p>
<h2 id="列表的运算"><a href="#列表的运算" class="headerlink" title="列表的运算:"></a>列表的运算:</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>+ += <em> </em>=<br>+ 用于拼接列表</p>
<pre><code>x = [1,2,3]
y = [4,5,6]
z = x + y  # z = [1,2,3,4,5,6]
</code></pre><p>+=用于原列表与左侧可迭代对象进行拼接,生成新的列表</p>
<pre><code>x = [1,2,3]
x += [4,5,6]  # x = [1,2,3,4,5,6]
x = [1,2,3]
x += &apos;ABC&apos;  # += 右侧必须是可迭代对象
</code></pre><p>* 生成重复的列表</p>
<pre><code>x = [1,2,3] * 2  # x = [1,2,3,1,2,3]
</code></pre><p>*= 用于生成重复的列表，同时用变量绑定新列表</p>
<pre><code>x = [1, 2]
x *= 3  # x = [1,2,1,2,1,2]
</code></pre><h3 id="列表的比较运算"><a href="#列表的比较运算" class="headerlink" title="列表的比较运算:"></a>列表的比较运算:</h3><p>运算符:</p>
<pre><code>&lt; &lt;= &gt; &gt;= == !=
</code></pre><p>示例:</p>
<pre><code>x = [1,2,3]
y = [2,3,4]
x != y     # True
x &gt; [1,2]  # True
x &lt; y      # True
[1,3,2] &gt; [1,2,3] # True
[&apos;AB&apos;, &apos;CD&apos;] &gt; [&apos;AC&apos;, &apos;BD&apos;]  # False
[1, &apos;two&apos;] &gt; [&apos;two&apos;, 1]  # TypeError
</code></pre><p>练习:</p>
<ol>
<li><p>输入一个整数，代表树干的高度.</p>
<p>   打印一棵”圣诞树”<br>   如:</p>
<pre><code>输入:2
</code></pre><p>   打印</p>
<pre><code> *
***
 *
 *
输入:3
</code></pre><p>   打印</p>
<pre><code>  *
 ***
*****
  *
  *    
  *
</code></pre></li>
<li><p>用循环语句生成如下字符串</p>
<p>   ‘ABC…..XYZ’<br>   ‘AaBbCc……XxYyZz’<br>   提示:</p>
<pre><code>用ord和chr函数结合循环语句实现
</code></pre></li>
<li><p>算出 100 ~ 999 以内的水仙花数(Narcissistic number)</p>
<p>   水仙花数是指百位的3次方加上十位的3次方加上个位的3次方等于原数的数字<br>   例如:</p>
<pre><code>153 等于 1**3 + 5**3 + 3**3
</code></pre><p>   参考答案:<br>   153, 370, …</p>
</li>
</ol>
<h2 id="列表的-in-not-in"><a href="#列表的-in-not-in" class="headerlink" title="列表的 in / not in"></a>列表的 in / not in</h2><ol>
<li>判断一个数据元素是否存在于容器(列表)内，如果存在返回True, 否则返回False</li>
<li>not in 的返回值与 in运算符相反</li>
</ol>
<p>示例:</p>
<pre><code>x = [1, &apos;Two&apos;, 3.14, &apos;四&apos;]
1 in x        # True
2 in x        # False
3 not in x    # True
&apos;四&apos; not in x # False
</code></pre><h2 id="列表的-索引-index-切片-slice"><a href="#列表的-索引-index-切片-slice" class="headerlink" title="列表的 索引 index / 切片 slice"></a>列表的 索引 index / 切片 slice</h2><p>列表的索引语句:<br>    列表[整数表达式]<br>用法:<br>    列表的索引取值与字符串的索引取值规则完全相同<br>    列表的索引为分正向索引和反向索引<br>示例:</p>
<pre><code>L = [&apos;A&apos;, 2, &apos;B&apos;, 3]
print(L[1])  # 2
x = L[2]   # x = &apos;B&apos;
</code></pre><h2 id="列表的索引赋值"><a href="#列表的索引赋值" class="headerlink" title="列表的索引赋值"></a>列表的索引赋值</h2><p>列表是可变的序列，可以通过索引赋值改变列表中的元素<br>语法:<br>  列表[索引] = 表达式</p>
<p>示例:</p>
<pre><code>x = [1,2,3,4]
x[2] = 3.14  # 改变了第三个元素的值
</code></pre><h2 id="列表的切片"><a href="#列表的切片" class="headerlink" title="列表的切片"></a>列表的切片</h2><p>  列表[:]<br>  列表的[::]<br>  列表的切片取值返回一个列表，规则等同于字符串的切片规则</p>
<p>  示例:<br>    x = list(range(9))<br>    y = x[1:9:2]  # y = [1,3,5,7]</p>
<h3 id="列表的切片赋值语法"><a href="#列表的切片赋值语法" class="headerlink" title="列表的切片赋值语法:"></a>列表的切片赋值语法:</h3><p>列表[切片] = 可迭代对象<br>说明:<br>  切片赋值的赋值运算符的右侧必须是一个可迭代对象<br>示例:</p>
<pre><code>L = [2,3,4]
L[0:1] = [1.1, 2.2]
print(L)  # [1.1, 2.2, 3, 4]
L = [2,3,4]
L[:] = [7,8]
L = [2,3,4]
L[1:2] = [3.1, 3.2, 3.3]
          # [2,3.1, 3.2, 3.3,4]
L = [2,3,4]
L[1:1] = [2.1, 2.2]  # [2, 2.1, 2.2, 3, 4]
L = [2,3,4] 
L[0:0] = [0, 1]   # L=[0, 1, 2,3,4]   
L = [2,3,4] 
L[3:3] = [5,6]  # L=[2,3,4, 5,6]
L = [2,3,4]
L[1:2] = []
</code></pre><h3 id="切片步长不为1的切片赋值"><a href="#切片步长不为1的切片赋值" class="headerlink" title="切片步长不为1的切片赋值"></a>切片步长不为1的切片赋值</h3><pre><code>L = list(range(1, 9))
L[1::2] = [2.2, 4.4, 6.6, 8.8]
print(L)  # 
</code></pre><h3 id="切片注意事项"><a href="#切片注意事项" class="headerlink" title="切片注意事项"></a>切片注意事项</h3><p>对于步长不等于1的切片赋值，赋值运算符的右侧的可迭代对象提供元素的个数一定要等于切片切出的段数<br>如:</p>
<pre><code>L = [1,2,3,4,5,6]
L[::2] = &apos;ABCD&apos;  # 错的
L[::2] = &apos;ABC&apos;   # 对的
</code></pre><h3 id="del-语句用于删除列表元素"><a href="#del-语句用于删除列表元素" class="headerlink" title="del 语句用于删除列表元素"></a>del 语句用于删除列表元素</h3><p>语法:<br>    del 列表[索引]<br>    del 列表[切片]<br>  示例:</p>
<pre><code>L = [1,2,3,4,5,6]
del L[0]  # L = [2,3,4,5,6]
del L[-1]  # L = [2,3,4,5]
L = [1,2,3,4,5,6]
del L[::2]  # L = [2, 4, 6]
</code></pre><p><strong>注意事项：这里一定不能这样操作来删除列表元素</strong></p>
<pre><code>l = [1,2,3,5,4]
for x in l:
    if x == 5:
        del x #删除不删除都一样，下一个循环的时候x指向了4
</code></pre><p>这段代码从字面上来看，就是遍历列表，查找每个元素是否与5相等，如果相等，则删除该元素，但是此写法删除的只是变量x，并不是列表中的元素，所以操作完之后列表中元素不变。 另外，for循环的时候，内部变量在for循环结束的时候本身就会被系统回收掉.</p>
<h2 id="python3中常用的序列函数"><a href="#python3中常用的序列函数" class="headerlink" title="python3中常用的序列函数"></a>python3中常用的序列函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>len(x)</td>
<td>返回序列的长度</td>
</tr>
<tr>
<td>max(x)</td>
<td>返回序列的最大值元素</td>
</tr>
<tr>
<td>min(x)</td>
<td>返回序列中最小值元素</td>
</tr>
<tr>
<td>sum(x)</td>
<td>返回序列中所有元素的和(元素必须是数值类型)</td>
</tr>
<tr>
<td>any(x)</td>
<td>真值测试, 如果列表中其中一个值为真值则返回True,否则返回False</td>
</tr>
<tr>
<td>all(x)</td>
<td>真值测试，如果列表中所有值为真值，则返回True,只要有一个为假，则返回False</td>
</tr>
</tbody>
</table>
<p>练习:<br>  1.已知有列表<br>    L = [3, 5]<br>    用索引和切片操作，将列表改为:<br>    L = [1,2,3,4,5,6]<br>    将列表反转(前后对调), 然后删除最后一个元素<br>    print(L)  # [6,5,4,3,2]</p>
<ol start="2">
<li>写程序，让用户循环输入一些整数，当输入-1时结束输入，将这些整数存于列表L中<br>1) 打印您共输入了几个有效的数?<br>2) 打印您输入的数的最大数是多少?<br>3) 打印您输入的数的最小数是多少?<br>4) 打印您输入这些数的平均值</li>
</ol>
<h2 id="Python3中常用的列表方法"><a href="#Python3中常用的列表方法" class="headerlink" title="Python3中常用的列表方法"></a>Python3中常用的列表方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>L.index(v [, begin[, end]])</td>
<td>返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误</td>
</tr>
<tr>
<td>L.insert(index, obj)</td>
<td>将某个元素插放到列表中指定的位置</td>
</tr>
<tr>
<td>L.count(x)</td>
<td>返回列表中元素的个数</td>
</tr>
<tr>
<td>L.remove(x)</td>
<td>从列表中删除第一次出现在列表中的值</td>
</tr>
<tr>
<td>L.copy()</td>
<td>复制此列表（只复制一层，不会复制深层对象)</td>
</tr>
<tr>
<td>L.append(x)</td>
<td>向列表中追加单个元素</td>
</tr>
<tr>
<td>L.extend(lst)</td>
<td>向列表追加另一个列表</td>
</tr>
<tr>
<td>L.clear()</td>
<td>清空列表,等同于 L[:] = []</td>
</tr>
<tr>
<td>L.sort(reverse=False)</td>
<td>将列表中的元素进行排序，默认顺序按值的小到大的顺序排列</td>
</tr>
<tr>
<td>L.reverse()</td>
<td>列表的反转，用来改变原列表的先后顺序</td>
</tr>
<tr>
<td>L.pop([index])</td>
<td>删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系</td>
</tr>
</tbody>
</table>
<h2 id="字符串文本解析方法-split-和-join"><a href="#字符串文本解析方法-split-和-join" class="headerlink" title="字符串文本解析方法 split 和 join"></a>字符串文本解析方法 split 和 join</h2><p>S.split(sep=None)  将字符串，使用sep作用为隔符分割S字符串，返回分割后的字符串的列表，当不给定参数时，用空白字符作为分隔符进行分割<br>S.join(iterable)  用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串</p>
<p>为什么在列表中说字符串的函数？<br>因为这2个函数往往是跟列表进行组合使用的，将一个特定格式的字符串，通过L=s.split(‘ ‘)进行分割，得到每个元素组成的列表。<br>然后将得到的列表经过一系列运算，形成新的列表，再通过s=’ ‘.join(L),这样就得到了字符串经过一定运算后得到的新字符串。</p>
<h2 id="深拷贝-deep-copy-和-浅拷贝-shallow-copy"><a href="#深拷贝-deep-copy-和-浅拷贝-shallow-copy" class="headerlink" title="深拷贝 deep copy 和 浅拷贝 shallow copy"></a>深拷贝 deep copy 和 浅拷贝 shallow copy</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>是指在复制过程中只复制一层变量，不会复制深层变量绑定的对象的复制过程</p>
<pre><code>L = [3.1, 3.2]
L1 = [1, 2, L]
L2 = L1.copy()  # 等同于 L1[:]  浅拷贝
print(L1)  # [1, 2, [3.1, 3.2]]
print(L2)  # [1, 2, [3.1, 3.2]]
L2[2][0] = 3.14
print(L1)  # [1, 2, [3.14, 3.2]]
print(L2)  # [1, 2, [3.14, 3.2]]
</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code>import copy  # 导入copy模块
L = [3.1, 3.2]
L1 = [1, 2, L]
L2 = copy.deepcopy(L1) # 深拷贝
print(L1)  # [1, 2, [3.1, 3.2]]
print(L2)  # [1, 2, [3.1, 3.2]]
L2[2][0] = 3.14
print(L1)  # [1, 2, [3.1, 3.2]]
print(L2)  # [1, 2, [3.14, 3.2]]
</code></pre><p>注:<br>  深拷贝通常只对可变对象进行复制，不可变对象通常不变</p>
<h2 id="列表推导式-list-comprehension"><a href="#列表推导式-list-comprehension" class="headerlink" title="列表推导式 list comprehension"></a>列表推导式 list comprehension</h2><p>列表推导式是用可迭代对象依次生成带有多个元素的列表的表达式<br>作用：<br>  用简易方法生成列表<br>语法:<br>  [表达式 for 变量 in 可迭代对象]<br>或<br>  [表达式 for 变量 in 可迭代对象 if 真值表达式]</p>
<p>示例:</p>
<pre><code># 以下生成一个数值为1~9的平方的列表 
L = [x*x for x in range(1, 10)]
</code></pre><p>练习:<br>  用列表推导式生成 1~100内的奇数的列表<br>    结果 [1,3,5,7,…. 99]</p>
<p>  示例:</p>
<pre><code># 以上练习可以改写为:
L = [x for x in range(1, 
                  100) if x % 2 == 1]
</code></pre><h2 id="列表推导式的嵌套"><a href="#列表推导式的嵌套" class="headerlink" title="列表推导式的嵌套"></a>列表推导式的嵌套</h2><p>  语法:<br>   [ 表达式1<br>    for 变量1 in 可迭代对象1 if 真值表达式1<br>     for 变量2 in 可迭代对象2 if 真值表达式2<br>      …]<br>  示例:</p>
<pre><code>L1 = [2, 3, 5]
L2 = [7, 11, 13]
# 将L1中的全部元素与L2中的全部元素依次相乘后放到列表L3中
L3 = [x * y for x in L1 for y in L2] #生成一维列表的 3*3 矩阵
print(L3)
</code></pre><p>练习:</p>
<ol>
<li><p>用字符串s = “ABC” 和 s2 = “123” 生成如下列表:<br>[‘A1’, ‘A2’, ‘A3’, ‘B1’, ‘B2’, ‘B3’, ‘C1’, ‘C2’, ‘C3’, ]</p>
</li>
<li><p>有一些数存在于列表L 中,如:<br>L = [1,3,2,1,6,4,2,…. 98, 82]<br>  (此数据自己定义)<br>将列表L中的数存入于另一个列表L2中（要求,重复出现多次的数字只在L2列表中保留一份)</p>
</li>
<li>生成前40个斐波那契数(Fibonacci)<br>1 1 2 3 5 8 13….<br>(自第三个起，之后的所有数为前两个数之和)<br>要求，将这些数保存在列表中，最后打印列表中的这些数<br>  提示: 用循环、列表和变量组合可以实现</li>
</ol>
<h1 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h1><p>元组是不可改变的序列。同list一样，元组可以存放任意类型的元素，一但元组生成，则它不可以改变。<br><strong>但是有一点，元组内部的元素如果是可变元素，比如t=(0,[1,2,3],4,5,6) t[1].append(4)是可以改变t的内容的</strong></p>
<pre><code>&gt;&gt;&gt; t=(0,[1,2,3],4,5,6)
&gt;&gt;&gt; t[1].append(4)
&gt;&gt;&gt; t
(0, [1, 2, 3, 4], 4, 5, 6)
</code></pre><p>元组的个数不会被改变，元组的内存地址不会改变，内部每个元素的数据类型也不会改变，但是单个元素的值是可能改变的</p>
<h2 id="元组的表示方式"><a href="#元组的表示方式" class="headerlink" title="元组的表示方式"></a>元组的表示方式</h2><p>  用小括号()括起来，单个元素括起来用逗号(,)区分是单个对象还是元组</p>
<h3 id="创建空元组的字符值"><a href="#创建空元组的字符值" class="headerlink" title="创建空元组的字符值"></a>创建空元组的字符值</h3><p>  t = ()</p>
<h3 id="创建非空元组的字面值"><a href="#创建非空元组的字面值" class="headerlink" title="创建非空元组的字面值"></a>创建非空元组的字面值</h3><pre><code>t = 200,
t = (20,) #一个元素的元组，后面一定要加逗号,  否则会被解释器认为是 (20) ，这样的一个表达式传递的信息是整型数据 20，而并不是元组。
t = (1,2,3)
t = 100, 200, 300
x, y, z = 100, 200, 300  #  序列赋值
x, y, z = &apos;ABC&apos;
x, y, z = [10, 20, 30]
</code></pre><p><strong>元组的错误示例:</strong></p>
<pre><code>t = (20)  # t 绑定整数
</code></pre><h2 id="元组的构造函数-tuple"><a href="#元组的构造函数-tuple" class="headerlink" title="元组的构造函数 tuple"></a>元组的构造函数 tuple</h2><p>tuple() 生成一个空的元组，等同于()<br>tuple(iterable)  用可迭代对象生成一个元组<br>示例:</p>
<pre><code>t = tuple()
t = tuple(range(10))
t = tuple(&apos;hello&apos;)
t = tuple([1,2,3,4])
</code></pre><p>元组的算术运算:<br>        +  +=  <em>  </em>= </p>
<p>用法与列表的用法完全相同</p>
<p>元组的比较运算:</p>
<pre><code>&lt; &lt;= &gt; &gt;= == != 
</code></pre><p>规则与列表完全相同</p>
<h2 id="in-not-in"><a href="#in-not-in" class="headerlink" title="in/ not in"></a>in/ not in</h2><p><strong>索引取值<br>切片取值<br>  规则与列表完全相同</strong></p>
<p><strong>区别:<br>  元组是不可变对象，不支持索引赋值和切片赋值</strong></p>
<p>元组的方法:<br>  见: &gt;&gt;&gt; help(tuple)<br>   T.index(v[,begin[,end]]) 用于获取元组中v所在的索引位置<br>   T.count(v)  用于获取元组中v的个数<br>1<br>   (以上方法同list中的index,count方法)</p>
<p>可以用于序列的函数:<br>  len, max, min, sum, all, any<br>三个构造函数:<br>  str(obj)<br>  list(iterable)<br>  tuple(iterable)<br>  用于创建相应的对象</p>
<p>其它函数:<br>  reversed(seq) 返回反向顺序的可迭代对象<br>  sorted(iterable, reversed=False)  返回已排序的列表</p>
<p>示例:</p>
<pre><code>for x in reversed(&quot;ABCD&quot;):
    print(x)  # D C B A
L = [8, 6, 3, 5, 7]
L2 = sorted(L)
print(L2)  # [3, 5, 6, 7, 8]
L3 = sorted(L, reversed=True)
print(L3)  # [8, 7, 6, 5, 3]
print(L)  # 保持不变
</code></pre><h1 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h1><ol>
<li>字典是一种可变的容器，可以存储任意类型的数据</li>
<li>字典中的每个数据都是用’键’(key) 进行索引，而不像序列可以用下标来进行索引</li>
<li>字典的数据没有先后顺序关系，字典的存储是无序的</li>
<li>字典中的数据以键(key)-值(value)对进行映射存储</li>
<li>字典的键不能重复，且只能用不可变类型作为字典的键。</li>
</ol>
<h2 id="字典的字面值表示方式"><a href="#字典的字面值表示方式" class="headerlink" title="字典的字面值表示方式:"></a>字典的字面值表示方式:</h2><p>  用 {} 括起来，以冒号(:) 分隔键-值对, 各键值对用分号分隔开</p>
<h3 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h3><p>  d = {}</p>
<h3 id="创建非空的字典"><a href="#创建非空的字典" class="headerlink" title="创建非空的字典"></a>创建非空的字典</h3><p>  d = {‘name’: ‘tarena’, ‘age’: 15}<br>  d = {‘姓名’: ‘小张’}<br>  d = {1:’壹’, 2:’贰’}</p>
<h2 id="字典的构造函数-dict"><a href="#字典的构造函数-dict" class="headerlink" title="字典的构造函数 dict"></a>字典的构造函数 dict</h2><p>  dict()  创建一个空字典,等同于 {}<br>  dict(iterable)  用可迭代对象初始化一个字典<br>  dict(**kwargs)  关键字传参形式生成一个字典</p>
<p>示例:</p>
<pre><code>d = dict()
d = dict([(&apos;name&apos;, &apos;tarena&apos;), (&apos;age&apos;,15)])
d = dict(name=&apos;tarena&apos;, age=15)
</code></pre><p>不可变类型：</p>
<p>  int,float,complex,bool,str,tuple,frozenset(固定集合), bytes(字节串)(后面会讲)</p>
<p>可变类型:</p>
<p>  list, dict, set(集合), bytearray(字节数组)</p>
<h2 id="字典的键索引"><a href="#字典的键索引" class="headerlink" title="字典的键索引"></a>字典的键索引</h2><p>用[] 运算符可以获取字典内’键’所对应的’值’<br>语法:<br>  字典[键]</p>
<h3 id="获取数据元素"><a href="#获取数据元素" class="headerlink" title="获取数据元素"></a>获取数据元素</h3><pre><code>d = dict(name=&apos;tarena&apos;, age=15)
print(d[&apos;age&apos;])  # 15
</code></pre><h3 id="添加-修改字典元素"><a href="#添加-修改字典元素" class="headerlink" title="添加/修改字典元素"></a>添加/修改字典元素</h3><p>字典[键] = 表达式</p>
<p>示例:</p>
<pre><code>d = {}
d[&apos;name&apos;] = &apos;tarena&apos;  # 创建一个新的键值对
d[&apos;age&apos;] = 15  # 创建键值对
d[&apos;age&apos;] = 16  # 修改键值对
</code></pre><h3 id="del-语句删除字典的元素"><a href="#del-语句删除字典的元素" class="headerlink" title="del 语句删除字典的元素"></a>del 语句删除字典的元素</h3><p>语法:<br>    del 字典[键]<br>示例:</p>
<pre><code>d = {&apos;name&apos;: &apos;china&apos;, &apos;pos&apos;: &apos;asia&apos;}
del d[&apos;pos&apos;]
print(d)
del d[&apos;name&apos;]
print(d)   # {}
</code></pre><h2 id="字典的-in-not-in-运算符"><a href="#字典的-in-not-in-运算符" class="headerlink" title="字典的 in / not in 运算符"></a>字典的 in / not in 运算符</h2><p>可以用 in 运算符来判断一个’键’是否存在于字典中,如果存在则返回True, 否则返回False<br>not in 与 in 返回值相反</p>
<p>示例:</p>
<pre><code>d = {&apos;a&apos;: 1, &apos;b&apos;: 2}
&apos;a&apos; in d     # True
1 in d       # False
100 not in d # True
2 not in d   # True
</code></pre><h2 id="字典的迭代访问"><a href="#字典的迭代访问" class="headerlink" title="字典的迭代访问"></a>字典的迭代访问</h2><p>字典是可迭代对象，字典只能对键进行迭代访问</p>
<pre><code>d = {&apos;name&apos;: &apos;tarena&apos;, (2002, 1, 1): &apos;生日&apos;}
for x in d:
    print(x)
</code></pre><p>可以用于字典的内建函数</p>
<p>  len(x)  返回字典键-值对的个数<br>  max(x)  返回字典的键的最大值<br>  min(x)  返回字典的键的最小值<br>  sum(x)  返回字典所有键的和<br>  any(x)  真值测试，只对键测试,如果其中一个键为True,结果为True<br>  all(x)  真值测试，全部键为True时，结果才为True</p>
<p>字典的方法:<br>D代表字典对象</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>D.clear()</td>
<td>清空字典</td>
</tr>
<tr>
<td>D.pop(key)</td>
<td>移除键，同时返回此键所对应的值</td>
</tr>
<tr>
<td>D.copy()</td>
<td>返回字典D的副本,只复制一层(浅拷贝)</td>
</tr>
<tr>
<td>D.update(D2)</td>
<td>将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值</td>
</tr>
<tr>
<td>D.get(key, default)</td>
<td>返回键key所对应的值,如果没有此键，则返回default</td>
</tr>
<tr>
<td>D.keys()</td>
<td>返回可迭代的 dict_keys 集合对象</td>
</tr>
<tr>
<td>D.values()</td>
<td>返回可迭代的 dict_values 值对象</td>
</tr>
<tr>
<td>D.items()</td>
<td>返回可迭代的 dict_items 对象</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/14/julia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/julia/" itemprop="url">Julia知识详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-14T19:05:04+08:00">
                2018-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Julia/" itemprop="url" rel="index">
                    <span itemprop="name">Julia</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,351 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  35 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>编程界的新宠Julia发布1.0正式版本，多种优势集于一身</p>
<p>源编程语言 Julia 迎来 1.0 正式版本。在 8 月 9 日的于伦敦举行的 JuliaCon 2018 会议上，Julia1.0 版本正式发布，这对 Julia 来说是自 2012 年 2 月公司成立以来最重要的时刻。Julia 是一种面向科学、数值计算的简单、高效的开源编程语言。而此次发布的Julia 1.0 是第一个完善、稳定和向前兼容的 Julia 版本。Julia 的联合创始人 Jeff Bezanson，Stefan Karpinski，Viral Shah 和 Alan Edelman 在会上对新版本进行了介绍。从问世至今的六年半时间里，Julia 的累积下载次数超过 200 万，已被应用于自动驾驶汽车、机器人、3D 打印、精准医疗、增强现实、基因组学、能源交易、机器学习、金融风控和太空任务设计等多个领域。此次 Julia 1.0 版本的发布，更是将商业用户越来越看重的稳定性与原有的快速、高生产力的特性结合起来，足以媲美 Python，R，C++和 Java 等编程语言。众多来自科技、咨询和金融等行业的公司都有采用 Julia 语言并雇佣 Julia 开发人员，其中包括：亚马逊、苹果、贝莱德集团、博思艾伦咨询公司、Capital One、康卡斯特、迪斯尼、安永、脸书、美国联邦航空管理局、纽约联储银行、福特、谷歌、IBM、英特尔、毕马威、微软、NASA、甲骨文、普华永道和优步。除了商业公司，目前还有超过 700 所大学、研究机构和实验室使用 Julia，其中不乏 MIT、哈佛、加州理工、劳伦斯·伯克利国家实验室、橡树岭国家实验室等知名大学和实验室。Julia 社区已有超过 700 名贡献者，开发了超过 1900 个扩展包。截至目前，Julia 已被下载超过 200 多万次，在 GitHub 上获得超过 41000 个星星，下载量年增长率超过 101%。Julia 兼具 Python 和 R 等高级语言的易用性和 C++的运行速度。它是目前唯一经过千万亿次量级计算考验的高级编程语言。在世界排名第 6 的超级计算机上，Julia 在 9300 个英特尔 Knights Landing (KNL) 计算节点上调用 65 万个核与 130 万个线程，对 1.88 亿个天体进行编目，仅耗时 14.6 分钟。外在金融风控模型和天文学图像分析等应用领域，Julia 对速度和性能的提升可达到 1000 倍以上。不论是在笔记本电脑还是在超级计算机上，不管采用 1 个还是数千个具备多线程、GPU 和并行计算能力的节点，Julia 均可保持出色的表现。对美国联邦航空管理局的飞机防撞系统（Aircraft Collision Avoidance System (ACAS-X)）、贝莱德集团的阿拉丁分析平台（Aladdin analytics platform）和纽约联储银行的动态随机通用平衡 (DSGE) 宏观经济学模型等项目，Julia 都被应用在其中且发挥了重要作用。</p>
<h1 id="julia环境的搭建"><a href="#julia环境的搭建" class="headerlink" title="julia环境的搭建"></a>julia环境的搭建</h1><p>1 在linux下执行sudo pip install julia,前提是pip是可以使用的</p>
<p>2 windows下到官网<a href="https://julialang.org/downloads/" target="_blank" rel="noopener">https://julialang.org/downloads/</a> 进行下载</p>
<p>3 进行测试环境是否ok</p>
<pre><code>linux下命令行输入julia,出现如下界面则表示安装成功
桌面/$ julia
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type &quot;?&quot; for help, &quot;]?&quot; for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)
 _/ |\__&apos;_|_|_|\__&apos;_|  |  Official https://julialang.org/ release
|__/                   |


julia&gt; 
</code></pre><p>4 第一行julia代码运行</p>
<pre><code>julia&gt; print(&apos;hello julia&apos;)
ERROR: syntax: invalid character literal

julia&gt; print(&quot;hello julia&quot;)
hello julia
julia&gt; print(&apos;a&apos;)
a
在这里需要注意的是julia对单引号&apos;&apos;的操作不能像python一样，而是和c语言的char现象一致
</code></pre><p>5 第一个jl文件的运行</p>
<pre><code>新建一个名为hello.jl的文件，在里面写一段代码：
println(&quot;hello julia in .jl file&quot;)

在控制台进行运行，结果如下
/桌面/julia$ julia hello.jl 
hello julia in .jl file
</code></pre><p>6 将执行指令写入并保存到.jl文件中，如下指令</p>
<pre><code>/桌面/julia$ julia -e &apos;println(&quot;hello julia&quot;); for x in ARGS; println(x); end&apos; foo bar
hello julia
foo
bar

echo &apos;println(PROGRAM_FILE); for x in ARGS; println(x); end&apos; &gt; script.jl

然后在控制台运行 
julia script.jl foo bar
</code></pre><p>7 julia运行程序的表达式</p>
<p>表达式： julia [switches] – [programfile] [args…]</p>
<table>
<thead>
<tr>
<th>开关</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-v， –version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-h， –help</td>
<td>打印此邮件</td>
</tr>
<tr>
<td>-J， –sysimage <file></file></td>
<td>启动给定的系统映像文件</td>
</tr>
<tr>
<td>-H， –home <dir></dir></td>
<td>设置julia可执行文件的位置</td>
</tr>
<tr>
<td>–startup-file={yes/no}</td>
<td>加载 ~/.julia/config/startup.jl</td>
</tr>
<tr>
<td>–handle-signals={yes/no}</td>
<td>启用或禁用Julia的默认信号处理程序</td>
</tr>
<tr>
<td>–sysimage-native-code={yes/no}</td>
<td>如果可用，请使用系统映像中的本机代码</td>
</tr>
<tr>
<td>–compiled-modules={yes/no}</td>
<td>启用或禁用模块的增量预编译</td>
</tr>
<tr>
<td>-e， –eval <expr></expr></td>
<td>评估 <expr></expr></td>
</tr>
<tr>
<td>-E， –print <expr></expr></td>
<td>评估<expr>并显示结果</expr></td>
</tr>
<tr>
<td>-L， –load <file></file></td>
<td><file>立即加载所有处理器</file></td>
</tr>
<tr>
<td>-p，–procs {N/auto}</td>
<td>整数值N启动N个额外的本地工作进程; auto启动与本地CPU线程数（逻辑核心数）一样多的工作程序</td>
</tr>
<tr>
<td>–machine-file <file></file></td>
<td>在上面列出的主机上运行进程 <file></file></td>
</tr>
<tr>
<td>-i</td>
<td>互动模式; REPL运行并且isinteractive()是真的</td>
</tr>
<tr>
<td>-q， –quiet</td>
<td>安静的启动：没有横幅，抑制REPL警告</td>
</tr>
<tr>
<td>–banner={yes/no/auto}</td>
<td>启用或禁用启动横幅</td>
</tr>
<tr>
<td>–color={yes/no/auto}</td>
<td>启用或禁用彩色文本</td>
</tr>
<tr>
<td>–history-file={yes/no}</td>
<td>加载或保存历史记录</td>
</tr>
<tr>
<td>–depwarn={yes/no/error}</td>
<td>启用或禁用语法和方法弃用警告（error将警告转换为错误）</td>
</tr>
<tr>
<td>–warn-overwrite={yes/no}</td>
<td>启用或禁用方法覆盖警告</td>
</tr>
<tr>
<td>-C， –cpu-target <target></target></td>
<td>限制cpu功能的使用，最高为<target>; 设置为help查看可用选项</target></td>
</tr>
<tr>
<td>-O， –optimize={0,1,2,3}</td>
<td>设置优化级别（如果未指定，则默认级别为2;如果不使用级别，则默认级别为3）</td>
</tr>
<tr>
<td>-g， -g <level></level></td>
<td>启用/设置调试信息生成的级别（如果未指定，则默认级别为1;如果不使用级别，则默认级别为2）</td>
</tr>
<tr>
<td>–inline={yes/no}</td>
<td>控制是否允许内联，包括覆盖@inline声明</td>
</tr>
<tr>
<td>–check-bounds={yes/no}</td>
<td>始终或从不发出边界检查（忽略声明）</td>
</tr>
<tr>
<td>–math-mode={ieee,fast}</td>
<td>禁止或启用不安全的浮点优化（覆盖@fastmath声明）</td>
</tr>
<tr>
<td>–code-coverage={none/user/all}</td>
<td>计算源代码行的执行次数</td>
</tr>
<tr>
<td>–code-coverage</td>
<td>相当于 –code-coverage=user</td>
</tr>
<tr>
<td>–track-allocation={none/user/all}</td>
<td>计算每个源行分配的字节数</td>
</tr>
<tr>
<td>–track-allocation</td>
<td>相当于 –track-allocation=user</td>
</tr>
</tbody>
</table>
<p>8 查看版本号</p>
<pre><code>julia&gt; VERSION
v&quot;1.0.0&quot;
</code></pre><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Julia中的变量是与值相关联（或绑定）的名称，不需要事先声明变量的类型，而是根据赋值表达式生成对应类型的数据，用变量进行保存。<br>例如：</p>
<pre><code>julia&gt; x = 10
10
julia&gt; x+1
11
julia&gt; x = 1+2
3

julia&gt; x = &quot;hello julia&quot;
&quot;hello julia&quot;
</code></pre><p>在上面示例中，x是指向存储的常量10</p>
<h2 id="变量命名规则："><a href="#变量命名规则：" class="headerlink" title="变量命名规则："></a>变量命名规则：</h2><p>1 变量区分大小写，a 与 A不是一个对象<br>2 变量采用的utf-8编码<br>3 变量字符集合：数字字母下划线，其他等同于字母的符号，首字母不为数字<br>4 不能和系统关键字同名</p>
<h2 id="文体约定"><a href="#文体约定" class="headerlink" title="文体约定"></a>文体约定</h2><p>虽然Julia对有效名称的限制很少，但采用以下约定变得很有用：</p>
<ul>
<li>变量名称为小写。</li>
<li>可以用下划线（’_’）表示单词分隔，但不鼓励使用下划线，除非该名称很难以其他方式阅读。</li>
<li>Types和Modules的名称以大写字母开头，单词分隔用上面的驼峰表示而不是下划线。</li>
<li>functions和macros的名称是小写的，没有下划线。</li>
<li>写入其参数的函数具有以其结尾的名称!。这些函数有时被称为“变异”或“就地”函数，因为它们旨在在调用函数后生成其参数的更改，而不仅仅是返回值。</li>
</ul>
<h1 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h1><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>以下是Julia的原始数字类型：</p>
<h3 id="整数类型："><a href="#整数类型：" class="headerlink" title="整数类型："></a><strong>整数类型：</strong></h3><table>
<thead>
<tr>
<th>类型</th>
<th>签？</th>
<th>位数</th>
<th>最小的价值</th>
<th>最大的价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int8</td>
<td>✓</td>
<td>8</td>
<td>-2 ^ 7</td>
<td>2 ^ 7 - 1</td>
</tr>
<tr>
<td>UInt8</td>
<td></td>
<td>8</td>
<td>0</td>
<td>2 ^ 8 - 1</td>
</tr>
<tr>
<td>Int16</td>
<td>✓</td>
<td>16</td>
<td>-2 ^ 15</td>
<td>2 ^ 15 - 1</td>
</tr>
<tr>
<td>UInt16</td>
<td></td>
<td>16</td>
<td>0</td>
<td>2 ^ 16 - 1</td>
</tr>
<tr>
<td>Int32</td>
<td>✓</td>
<td>32</td>
<td>-2 ^ 31</td>
<td>2 ^ 31 - 1</td>
</tr>
<tr>
<td>UInt32</td>
<td></td>
<td>32</td>
<td>0</td>
<td>2 ^ 32 - 1</td>
</tr>
<tr>
<td>Int64</td>
<td>✓</td>
<td>64</td>
<td>-2 ^ 63</td>
<td>2 ^ 63 - 1</td>
</tr>
<tr>
<td>UInt64</td>
<td></td>
<td>64</td>
<td>0</td>
<td>2 ^ 64 - 1</td>
</tr>
<tr>
<td>Int128</td>
<td>✓</td>
<td>128</td>
<td>-2 ^ 127</td>
<td>2 ^ 127 - 1</td>
</tr>
<tr>
<td>UInt128</td>
<td></td>
<td>128</td>
<td>0</td>
<td>2 ^ 128 - 1</td>
</tr>
<tr>
<td>Bool</td>
<td>N / A</td>
<td>8</td>
<td>false （0）</td>
<td>true （1）</td>
</tr>
</tbody>
</table>
<h3 id="浮点类型："><a href="#浮点类型：" class="headerlink" title="浮点类型："></a><strong>浮点类型：</strong></h3><table>
<thead>
<tr>
<th>类型</th>
<th>精确</th>
<th>位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float16</td>
<td>半</td>
<td>16</td>
</tr>
<tr>
<td>Float32</td>
<td>单</td>
<td>32</td>
</tr>
<tr>
<td>Float64</td>
<td>双</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>查看本机是32位还是64位</p>
<pre><code>julia&gt; typeof(1) 返回值为Int64则为64位，返回值为Int32 则为32位机
Int64
</code></pre><p>32位机无法表示的数字时会自动转换为Int64类型</p>
<h3 id="无符号整数使用0x前缀和十六进制（基数为16）数字"><a href="#无符号整数使用0x前缀和十六进制（基数为16）数字" class="headerlink" title="无符号整数使用0x前缀和十六进制（基数为16）数字"></a><strong>无符号整数使用0x前缀和十六进制（基数为16）数字</strong></h3><p>进行输入和输出0-9a-f（大写数字A-F也适用于输入）。无符号值的大小由使用的十六进制数字数决定：<br>(ans)是只在交互模式下才能使用的变量，保存的内容是上一个表达式的运算结果</p>
<pre><code>julia&gt; 0x1
0x01

julia&gt; typeof(ans)
UInt8

julia&gt; 0x123
0x0123

julia&gt; typeof(ans)
UInt16

julia&gt; 0x1234567
0x01234567

julia&gt; typeof(ans)
UInt32

julia&gt; 0x123456789abcdef
0x0123456789abcdef

julia&gt; typeof(ans)
UInt64

julia&gt; 0x11112222333344445555666677778888
0x11112222333344445555666677778888

julia&gt; typeof(ans)
UInt128
</code></pre><h3 id="还支持二进制和八进制文字："><a href="#还支持二进制和八进制文字：" class="headerlink" title="还支持二进制和八进制文字："></a><strong>还支持二进制和八进制文字：</strong></h3><pre><code>julia&gt; 0b10
0x02

julia&gt; typeof(ans)
UInt8

julia&gt; 0o010
0x08

julia&gt; typeof(ans)
UInt8

julia&gt; 0x00000000000000001111222233334444
0x00000000000000001111222233334444

julia&gt; typeof(ans)
UInt128
</code></pre><p>在二进制，八进制和十六进制前加-号表示取补码。它们产生一个与无符号文字相同大小的无符号整数</p>
<pre><code>julia&gt; -0x2
0xfe

julia&gt; -0x0002
0xfffe
</code></pre><h3 id="原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出："><a href="#原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出：" class="headerlink" title="原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出："></a>原始数字类型（如整数）的最小和最大可表示值由typemin和typemax函数给出：</h3><pre><code>julia&gt; (typemin(Int32), typemax(Int32))
(-2147483648, 2147483647)

julia&gt; for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]
           println(&quot;$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]&quot;)
       end
   Int8: [-128,127]
  Int16: [-32768,32767]
  Int32: [-2147483648,2147483647]
  Int64: [-9223372036854775808,9223372036854775807]
 Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]
  UInt8: [0,255]
 UInt16: [0,65535]
 UInt32: [0,4294967295]
 UInt64: [0,18446744073709551615]
UInt128: [0,340282366920938463463374607431768211455]
</code></pre><h3 id="溢出行为"><a href="#溢出行为" class="headerlink" title="溢出行为"></a>溢出行为</h3><p>在Julia中，超出给定类型的最大可表示值会导致环绕行为：</p>
<pre><code>julia&gt; x = typemax(Int64)
9223372036854775807

julia&gt; x + 1
-9223372036854775808

julia&gt; x + 1 == typemin(Int64)
true
</code></pre><h3 id="除法错误"><a href="#除法错误" class="headerlink" title="除法错误"></a>除法错误</h3><p>除法需要考虑除数为0的情况<br>1 一个非0数字除以0，得到Inf<br>2 0/0  -&gt; NaN<br>3 任意数对0求余数，报错<br>4 一个常规数字对Inf进行除法，得到的结果为0.0<br>5 一个常规数字对NaN除法，得到的结果还是NaN<br>6 Inf/Inf –&gt; Nan<br>7 0/Inf  –&gt; NaN</p>
<pre><code>julia&gt; 3%0
ERROR: DivideError: integer division error
 in rem at ./int.jl:80

julia&gt; 3/0
Inf

julia&gt; 0/0
NaN

julia&gt; 0%0
ERROR: DivideError: integer division error
 in rem at ./int.jl:80

julia&gt; x = 1/0
Inf

julia&gt; 2/x
0.0

julia&gt; x = 0/0
NaN

julia&gt; 2/x
NaN
</code></pre><h3 id="浮点数字"><a href="#浮点数字" class="headerlink" title="浮点数字"></a>浮点数字</h3><p>可以使用科学计数法 1.3e4 = 13000.0<br><strong>另外可以使用f替代e来实现科学计数法</strong> 0.5f2 = 50.0f0<br>还支持半精度浮点数（Float16），但它们在软件中实现并Float32用于计算。</p>
<pre><code>julia&gt; sizeof(Float16(4.))
2

julia&gt; 2*Float16(4.)
Float16(8.0)
</code></pre><p><strong>下划线_可用作数字分隔符：</strong></p>
<pre><code>julia&gt; 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010
(10000, 5.0e-9, 0xdeadbeef, 0xb2)
</code></pre><p><strong>Machine epsilon</strong> (暂时不知道怎么翻译)<br>大多数实数不能用浮点数精确表示,所以需要一个精度来判断该值与表达式所写值得差值是否满足精度，满足则认为是正确表示的。</p>
<p>Julia提供eps，它给出了1.0到下一个更大的可表示浮点值之间的距离：</p>
<pre><code>julia&gt; eps(Float32)
1.1920929f-7

julia&gt; eps(Float64)
2.220446049250313e-16

julia&gt; eps() # same as eps(Float64)
2.220446049250313e-16
</code></pre><p>这个东西就像我们结帐的时候，都是以最低单位为分的，但是在实际过程中，都是以元为最低单位进行结算，但是分确实就是我国的最低结算单位，在银行等地方还是会用到的。</p>
<p>Julia还提供了<strong>nextfloat与prevfloat</strong>它们分别返回下一个最大或最小的可表示浮点数的参数功能：</p>
<pre><code>julia&gt; x = 1.25f0
1.25f0

julia&gt; nextfloat(x)
1.2500001f0

julia&gt; prevfloat(x)
1.2499999f0

julia&gt; bitstring(prevfloat(x))
&quot;00111111100111111111111111111111&quot;

julia&gt; bitstring(x)
&quot;00111111101000000000000000000000&quot;

julia&gt; bitstring(nextfloat(x))
&quot;00111111101000000000000000000001&quot;
</code></pre><h3 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h3><p>如果数字没有精确的浮点表示，则必须将其四舍五入到适当的可表示值。但是，如果需要，可以根据IEEE 754标准中提出的舍入模式改变完成此舍入的方式。</p>
<p>使用的默认模式始终是RoundNearest，它舍入到最接近的可表示值，并使用最低有效位向最近的值四舍五入。</p>
<h3 id="任意精度算术"><a href="#任意精度算术" class="headerlink" title="任意精度算术"></a>任意精度算术</h3><p>为了允许使用任意精度整数和浮点数进行计算，Julia分别包装了GNU多精度算术库（GMP）和GNU MPFR库。Julia中的BigInt和BigFloat类型分别用于任意精度整数和浮点数。</p>
<p>存在构造函数以从原始数字类型创建这些类型，并且parse可以用于从AbstractStrings 构造它们。一旦创建，由于Julia的类型提升和转换机制，它们与所有其他数字类型一起参与算术运算：</p>
<pre><code>julia&gt; BigInt(typemax(Int64)) + 1
9223372036854775808

julia&gt; parse(BigInt, &quot;123456789012345678901234567890&quot;) + 1
123456789012345678901234567891

julia&gt; parse(BigFloat, &quot;1.23456789012345678901&quot;)
1.234567890123456789010000000000000000000000000000000000000000000000000000000004

julia&gt; BigFloat(2.0^66) / 3
2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19

julia&gt; factorial(BigInt(40))
815915283247897734345611269596115894272000000000
</code></pre><p>但是，上述基本类型之间的类型提升和BigInt/ BigFloat不是自动的，必须明确说明。</p>
<pre><code>julia&gt; x = typemin(Int64)
-9223372036854775808

julia&gt; x = x - 1
9223372036854775807

julia&gt; typeof(x)
Int64

julia&gt; y = BigInt(typemin(Int64))
-9223372036854775808

julia&gt; y = y - 1
-9223372036854775809

julia&gt; typeof(y)
BigInt
</code></pre><p>BigFloat可以通过调用setprecision和全局更改默认精度（有效数的位数）和舍入操作模式setrounding，并且所有进一步的计算将考虑这些更改。或者，通过使用与do块相同的函数，只能在特定代码块的执行中更改精度或舍入：</p>
<pre><code>julia&gt; setrounding(BigFloat, RoundUp) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.100000000000000000000000000000000000000000000000000000000000000000000000000003

julia&gt; setrounding(BigFloat, RoundDown) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.099999999999999999999999999999999999999999999999999999999999999999999999999986

julia&gt; setprecision(40) do
           BigFloat(1) + parse(BigFloat, &quot;0.1&quot;)
       end
1.1000000000004
</code></pre><h3 id="数字文字系数-（此乃神器）"><a href="#数字文字系数-（此乃神器）" class="headerlink" title="数字文字系数 ###（此乃神器）"></a>数字文字系数 ###（此乃神器）</h3><p>为了使常见的数字公式和表达式更清晰，Julia允许变量紧跟数字文字，表示乘法。这使得写多项式表达式更加清晰：</p>
<pre><code>julia&gt; x = 3
3

julia&gt; 2x^2 - 3x + 1
10

julia&gt; 1.5x^2 - .5x + 1
13.0
julia&gt; 4^2x
4096（备注：先计算的是2x后再计算的幂）
</code></pre><p>数字文字也可用作带括号的表达式的系数：</p>
<pre><code>julia&gt; 2(x-1)^2 - 3(x-1) + 1
3
</code></pre><p>另外，带括号的表达式可以用作变量的系数，意味着表达式乘以变量：</p>
<pre><code>julia&gt; (x-1)x
6
</code></pre><p><strong>但是</strong>，两个带括号的表达式的并置，也不能在括号表达式之前放置变量，都可以用来暗示乘法：</p>
<pre><code>julia&gt; (x-1)(x+1)
ERROR: MethodError: objects of type Int64 are not callable

julia&gt; x(x+1)
ERROR: MethodError: objects of type Int64 are not callable
</code></pre><p><strong>后置括号跟函数的参数调用冲突，所以这样的写法会报错</strong></p>
<h3 id="字面零和一"><a href="#字面零和一" class="headerlink" title="字面零和一"></a>字面零和一</h3><p>Julia提供的函数返回对应于指定类型或给定变量类型的文字0和1。</p>
<p>功能    描述<br>zero(x)    x变量类型或类型的字面零x<br>one(x)    文字类型x或类型的变量x<br>这些函数在数值比较中很有用，可以避免不必要的类型转换带来的开销。</p>
<p>例子：</p>
<pre><code>julia&gt; zero(Float32)
0.0f0

julia&gt; zero(1.0)
0.0

julia&gt; one(Int32)
1

julia&gt; one(BigFloat)
1.0
</code></pre><h2 id="数学运算和基本功能"><a href="#数学运算和基本功能" class="headerlink" title="数学运算和基本功能"></a>数学运算和基本功能</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>所有原始数字类型都支持以下算术运算符：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+x</td>
<td>一元加</td>
<td>身份操作</td>
</tr>
<tr>
<td>-x</td>
<td>一元减去</td>
<td>将值映射到它们的加法反转</td>
</tr>
<tr>
<td>x + y</td>
<td>二进制加</td>
<td>执行添加</td>
</tr>
<tr>
<td>x - y</td>
<td>二进制减去</td>
<td>执行减法</td>
</tr>
<tr>
<td>x * y</td>
<td>时</td>
<td>执行乘法运算</td>
</tr>
<tr>
<td>x / y</td>
<td>划分</td>
<td>执行分裂</td>
</tr>
<tr>
<td>x ÷ y</td>
<td>整数除</td>
<td>x / y，截断为整数</td>
</tr>
<tr>
<td>x \ y</td>
<td>逆分</td>
<td>相当于 y / x</td>
</tr>
<tr>
<td>x ^ y</td>
<td>功率</td>
<td>提升x到了y力量</td>
</tr>
<tr>
<td>x % y</td>
<td>余</td>
<td>相当于 rem(x,y)</td>
</tr>
</tbody>
</table>
<p>以及对Bool类型的否定：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>!x</td>
<td>否定</td>
<td>改变true，false反之亦然</td>
</tr>
</tbody>
</table>
<p><strong>julia中/是算术除法，÷是地板除法</strong></p>
<p>按位运算符<br>所有原始整数类型都支持以下按位运算符：</p>
<table>
<thead>
<tr>
<th>表达</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>~x</td>
<td>按位不是</td>
</tr>
<tr>
<td>x &amp; y</td>
<td>按位和</td>
</tr>
<tr>
<td>x</td>
<td>y</td>
<td>按位或</td>
</tr>
<tr>
<td>x ⊻ y</td>
<td>按位xor（独占或）</td>
</tr>
<tr>
<td><strong>x &gt;&gt;&gt; y</strong></td>
<td><strong>逻辑右移</strong></td>
</tr>
<tr>
<td>x &gt;&gt; y</td>
<td>算术右移</td>
</tr>
<tr>
<td>x &lt;&lt; y</td>
<td>逻辑/算术移位左</td>
</tr>
</tbody>
</table>
<p>所有二进制算术和按位赋值运算符如下：<br>+=  -=  *=  /=  \=  ÷=  %=  ^=  &amp;=  |=  ⊻=  &gt;&gt;&gt;=  &gt;&gt;=  &lt;&lt;=</p>
<h3 id="矢量化的“点”运算符-此乃第二大神器）"><a href="#矢量化的“点”运算符-此乃第二大神器）" class="headerlink" title="矢量化的“点”运算符 ###(此乃第二大神器）"></a>矢量化的“点”运算符 ###(此乃第二大神器）</h3><p>对于每个二进制操作^，都有一个相应的“点”操作.^，它被自动定义为^在数组上逐个元素地执行。例如，[1,2,3] ^ 3未定义，因为“立方”（非正方形）数组没有标准数学意义，而是[1,2,3] .^ 3定义为计算元素（或“矢量化”）结果[1^3, 2^3, 3^3]。类似地，对于像!或一样的一元运算符.x，有一个对应.x的元素应用运算符。</p>
<pre><code>julia&gt; [1,2,3] .^ 3
3-element Array{Int64,1}:
  1
  8
 27

julia&gt; [1,2,3] .+4
3-element Array{Int64,1}:
 5
 6
 7

julia&gt; x = 3
3

julia&gt; [1,2,3] .*x
3-element Array{Int64,1}:
 3
 6
 9
</code></pre><h3 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h3><p>为所有原始数字类型定义标准比较操作：</p>
<table>
<thead>
<tr>
<th>操作者</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等</td>
</tr>
<tr>
<td>!=， ≠</td>
<td>不相等</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=， ≤</td>
<td>小于或等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=， ≥</td>
<td>大于或等于</td>
</tr>
</tbody>
</table>
<p>根据IEEE 754标准比较浮点数：</p>
<ul>
<li>有限数字以通常的方式排序。</li>
<li>正零等于但不大于负零。</li>
<li>Inf等于自己，比其他任何值都大。</li>
<li>-Inf等于自己，小于任意值。</li>
<li><p>NaN 不等于，不小于，不大于任何东西，包括它本身。不可做比较运算</p>
<pre><code>julia&gt; NaN == NaN
false

julia&gt; NaN != NaN
true

julia&gt; NaN &lt; NaN
false

julia&gt; NaN &gt; NaN
false
</code></pre></li>
</ul>
<p>Julia提供了额外的函数来测试特殊值的数字，这在哈希键比较的情况下非常有用：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>测试是否</th>
</tr>
</thead>
<tbody>
<tr>
<td>isequal(x, y)</td>
<td>x并且y是相同的</td>
</tr>
<tr>
<td>isfinite(x)</td>
<td>x 是一个有限数，非无穷</td>
</tr>
<tr>
<td>isinf(x)</td>
<td>x 是无穷的</td>
</tr>
<tr>
<td>isnan(x)</td>
<td>x 不是一个数字</td>
</tr>
</tbody>
</table>
<p><strong>isequal认为NaNs彼此相等：</strong></p>
<pre><code>julia&gt; isequal(NaN, NaN)
true

julia&gt; isequal([1 NaN], [1 NaN])
true

julia&gt; isequal(NaN, NaN32)
true
</code></pre><p><strong>isequal 也可用于区分带符号的零：</strong></p>
<pre><code>julia&gt; -0.0 == 0.0
true

julia&gt; isequal(-0.0, 0.0)
false
</code></pre><h3 id="连续比较-（此乃第三大神器）"><a href="#连续比较-（此乃第三大神器）" class="headerlink" title="连续比较 ###（此乃第三大神器）"></a>连续比较 ###（此乃第三大神器）</h3><p>与大多数语言不同，除了Python之外，比较可以任意链接：</p>
<pre><code>julia&gt; 1 &lt; 2 &lt;= 2 &lt; 3 == 3 &gt; 2 &gt;= 1 == 1 &lt; 3 != 5
true

julia&gt; v(x) = (println(x); x)
v (generic function with 1 method)
julia&gt; v(1)&lt;v(2)&lt;v(3)&lt;v(4)&lt;v(5)
2
1
3
4
5
true
</code></pre><p>链式比较中的评估顺序是不确定的。强烈建议不要在链式比较中使用带副作用的表达式（如打印）。如果需要副作用，&amp;&amp;应明确使用短路操作器。</p>
<h3 id="运算符优先级和相关性"><a href="#运算符优先级和相关性" class="headerlink" title="运算符优先级和相关性"></a>运算符优先级和相关性</h3><p>Julia应用以下顺序和操作的关联性，从最高优先级到最低优先级：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>操作符</th>
<th>关联性</th>
</tr>
</thead>
<tbody>
<tr>
<td>句法</td>
<td>.  ::</td>
<td>从左往右</td>
</tr>
<tr>
<td>幂</td>
<td>^</td>
<td>从右往左</td>
</tr>
<tr>
<td>一元</td>
<td>+ - √</td>
<td>从右往左[1]</td>
</tr>
<tr>
<td>移位</td>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左往右</td>
</tr>
<tr>
<td>馏分</td>
<td>//</td>
<td>从左往右</td>
</tr>
<tr>
<td>乘除</td>
<td>* / % &amp; \ ÷</td>
<td>从左往右[2]</td>
</tr>
<tr>
<td>加减</td>
<td>+ - &#124; ⊻</td>
<td>从左往右[2]</td>
</tr>
<tr>
<td>句法</td>
<td>: ..</td>
<td>从左往右</td>
</tr>
<tr>
<td>句法</td>
<td>&gt;    从左往右</td>
</tr>
<tr>
<td>句法</td>
<td>&lt;</td>
<td>从右往左</td>
</tr>
<tr>
<td>比较</td>
<td>&gt; &lt; &gt;= &lt;= == === != !== &lt;:</td>
<td>非关联</td>
</tr>
<tr>
<td>控制流</td>
<td>‘&amp;&amp;’&gt;’&#124;&#124;’&gt;’?’</td>
<td>从右往左</td>
</tr>
<tr>
<td>配对</td>
<td>=&gt;</td>
<td>从右往左</td>
</tr>
<tr>
<td>赋值</td>
<td>= += -= *= /= //= \= ^= ÷= %= &#124;= &amp;= ⊻= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>从右往左</td>
</tr>
</tbody>
</table>
<p>[1]<br>一元运算符+和-需要围绕它们的参数明确括号以使它们与运算符++等消除歧义。一元运算符的其他组合被解析为具有右关联性，例如√√-aas √(√(-a))。</p>
<p>[2]<br>运算符+，++和<em>是非关联的。a + b + c被解析为+(a, b, c)而不是+(+(a, b), c)。但是，后备方法+(a, b, c, d…)和</em>(a, b, c, d…)默认为左关联。</p>
<h3 id="求和-积运算-（此乃第四大神器）"><a href="#求和-积运算-（此乃第四大神器）" class="headerlink" title="求和 积运算 ###（此乃第四大神器）"></a>求和 积运算 ###（此乃第四大神器）</h3><pre><code>julia&gt; +(1,2,3)
6

julia&gt; +(+(1,2,3),4)
10

julia&gt; *(1,2,3,4)
24
</code></pre><p>运输符优先级函数<br>您还可以通过内置函数找到任何给定运算符的数字优先级Base.operator_precedence，其中较高的数字优先：</p>
<pre><code>julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(9,11,15)
</code></pre><p>通过调用内置函数也可以找到表示运算符关联性的符号Base.operator_associativity–此函数在官网上面有，但是我的版本里面是没有的定义。<br>官网上面写的运行结果为（看个人电脑情况吧，没有搞清楚怎么回事）</p>
<pre><code>julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)
</code></pre><h3 id="数字转换"><a href="#数字转换" class="headerlink" title="数字转换"></a>数字转换</h3><p>Julia支持三种形式的数值转换，它们在处理不精确转换时有所不同。</p>
<ul>
<li>T(x)或convert(T,x)转换x为T类型的值。 T取值可以是Int8 Int16 Float16等</li>
</ul>
<p>如果T是浮点类型，则结果是最接近的可表示值，可以是正无穷大或负无穷大。<br>如果T是整数类型，InexactError则如果x不能表示，则引发a T。</p>
<ul>
<li><p>x % T将整数转换x为整数类型的值全T等到x模数2^n，其中n是位数T。换句话说，二进制表示被截断以适合。</p>
</li>
<li><p>round函数采取类型T作为可选参数。例如，round(Int,x)是一个简写Int(round(x))。</p>
</li>
</ul>
<h3 id="舍-amp-入函数使用说明"><a href="#舍-amp-入函数使用说明" class="headerlink" title="舍&amp;入函数使用说明"></a>舍&amp;入函数使用说明</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>返回值类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>round(x)</td>
<td>就近取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>round(T, x)</td>
<td>就近取整</td>
<td>T</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>floor(T, x)</td>
<td>向下取整</td>
<td>T</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>向上取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>ceil(T, x)</td>
<td>向上取整</td>
<td>T</td>
</tr>
<tr>
<td>trunc(x)</td>
<td>向0取整</td>
<td>typeof(x)</td>
</tr>
<tr>
<td>trunc(T, x)</td>
<td>向0取整</td>
<td>T</td>
</tr>
</tbody>
</table>
<h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a>除法函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>div(x,y), x÷y</td>
<td>取整整除</td>
</tr>
<tr>
<td>fld(x,y)</td>
<td>向下取整整除</td>
</tr>
<tr>
<td>cld(x,y)</td>
<td>向上取整整除</td>
</tr>
<tr>
<td>rem(x,y)</td>
<td>取模</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>取模</td>
</tr>
<tr>
<td>mod1(x,y)</td>
<td>取模，但是在整除时返回值为y</td>
</tr>
<tr>
<td>divrem(x,y)</td>
<td>返回商和余数的元组（a,b）</td>
</tr>
<tr>
<td>fldmod(x,y)</td>
<td>返回商和余数的元组（a,b）</td>
</tr>
<tr>
<td>gcd(x,y…)</td>
<td>最大公约数</td>
</tr>
<tr>
<td>lcm(x,y…)</td>
<td>最小公倍数</td>
</tr>
</tbody>
</table>
<h3 id="符号和绝对值函数"><a href="#符号和绝对值函数" class="headerlink" title="符号和绝对值函数"></a>符号和绝对值函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td>x的绝对值</td>
</tr>
<tr>
<td>abs2(x)</td>
<td>x^2</td>
</tr>
<tr>
<td>sign(x)</td>
<td>正数返回1，负数返回-1 ，0返回0</td>
</tr>
<tr>
<td>signbit(x)</td>
<td>负数返回true,其他都返回false</td>
</tr>
<tr>
<td>copysign(x,y)</td>
<td>将y的符号给到x，返回之后的x</td>
</tr>
<tr>
<td>flipsign(x,y)</td>
<td>x的符号取决于x*y的符号，返回之后的x</td>
</tr>
</tbody>
</table>
<h3 id="指数-对数-平方根函数"><a href="#指数-对数-平方根函数" class="headerlink" title="指数 对数 平方根函数"></a>指数 对数 平方根函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sqrt(x), √x</td>
<td>对x进行开方</td>
</tr>
<tr>
<td>cbrt(x), ∛x</td>
<td>对x进行开3次方</td>
</tr>
<tr>
<td>hypot(x,y)</td>
<td>返回x y的平方和之后的根，也就是向量(x,y)的长度</td>
</tr>
<tr>
<td>exp(x)</td>
<td>底数为e，返回e^x的结果</td>
</tr>
<tr>
<td>expm1(x)</td>
<td>返回exp(x)-1</td>
</tr>
<tr>
<td>ldexp(x,n)</td>
<td>返回2^n * x的结果，<strong>这里x必须为Float类型</strong></td>
</tr>
<tr>
<td>log(x)</td>
<td>自然数对数</td>
</tr>
<tr>
<td>log(b,x)</td>
<td>返回以b为底，x为基数的对数</td>
</tr>
<tr>
<td>log2(x)</td>
<td>返回以2为底，x为基数的对数</td>
</tr>
<tr>
<td>log10(x)</td>
<td>返回以10为底，x为基数的对数</td>
</tr>
<tr>
<td>log1p(x)</td>
<td>返回log(x+1)的结果</td>
</tr>
<tr>
<td>exponent(x)</td>
<td>返回整数部分2进制的位数，exponent(127.0)=6 exponent(128.0)=7 </td>
</tr>
<tr>
<td>significand(x)</td>
<td>返回值为1.a，a的算法为x%8/8</td>
</tr>
</tbody>
</table>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>sin 正弦   sinA = a/c a为A的对角的边长，c为斜边<br>cos余弦    cosA = b/c b为另外的一条直角边<br>tan  正切  tanA = a/b<br>cot  余切  cotA = b/a<br>sec  正割  secA = c/b<br>csc余割    cscA = c/a<br>sinh   cosh   tanh   coth   sech   csch 双曲xx<br>asin   acos   atan   acot   asec   acsc  反xx  x=sin(y) -&gt; y = asin(x) + pi/2*N<br>asinh  acosh  atanh  acoth  asech  acsch 反双曲xx<br>sinc   cosc 周期为2的正余弦函数</p>
<p>以d结束的三角函数都是以度数作为单位进行运算的，前面和之前的一样<br>sind   cosd   tand   cotd   secd   cscd<br>asind  acosd  atand  acotd  asecd  acscd</p>
<p>举例：</p>
<pre><code>julia&gt; sind(90)
1.0

julia&gt; sind(45)
0.7071067811865476
</code></pre><p>更多特殊函数请移步 <a href="https://github.com/JuliaMath/SpecialFunctions.jl" target="_blank" rel="noopener">SpecialFunctions.jl</a></p>
<h2 id="复数和有理数"><a href="#复数和有理数" class="headerlink" title="复数和有理数"></a>复数和有理数</h2><p>复数表示方式示例 2+3im,其中2为实部，3为虚部，im是虚部的标志，将3im写前面语法上是对的，但是输出的时候会显示为2+3im<br>使用复数执行所有标准算术运算：</p>
<pre><code>julia&gt; (1 + 2im)*(2 - 3im)
8 + 1im

julia&gt; (1 + 2im)/(1 - 2im)
-0.6 + 0.8im

julia&gt; (1 + 2im) + (1 - 2im)
2 + 0im

julia&gt; (-3 + 2im) - (5 - 1im)
-8 + 3im

julia&gt; (-1 + 2im)^2
-3 - 4im

julia&gt; (-1 + 2im)^2.5
2.729624464784009 - 6.9606644595719im

julia&gt; (-1 + 2im)^(1 + 1im)
-0.27910381075826657 + 0.08708053414102428im

julia&gt; 3(2 - 5im)
6 - 15im

julia&gt; 3(2 - 5im)^2
-63 - 60im

julia&gt; 3(2 - 5im)^-1.0
0.20689655172413796 + 0.5172413793103449im
</code></pre><p>注意 3/4im == 3/(4<em>im) == -(3/4</em>im)</p>
<h3 id="复数函数"><a href="#复数函数" class="headerlink" title="复数函数"></a>复数函数</h3><pre><code>julia&gt; z = 1 + 2im
1 + 2im

julia&gt; real(1 + 2im) # real part of z
1

julia&gt; imag(1 + 2im) # imaginary part of z
2

julia&gt; conj(1 + 2im) # complex conjugate of z
1 - 2im

julia&gt; abs(1 + 2im) # absolute value of z
2.23606797749979  #sqrt(a^2+b^2)

julia&gt; abs2(1 + 2im) # squared absolute value
5  #a^2+b^2

julia&gt; angle(1 + 2im) # phase angle in radians
1.1071487177940904
</code></pre><p>conj(x)    返回的是复数x的共轭复数，实部一样，虚部取-运算</p>
<p>有如下公式成立：<br><strong>x = conj(X)/abs2(x)</strong></p>
<p>angle(x)函数是求复数相角，是在matlab中的一种方法，计算复数x向量的相角，返回值为为-pi~pi之间，结果准确表达的含义是向量与x轴正向的夹角的弧度，当向量无限趋近于-x轴方向时越接近最值pi或者-pi</p>
<pre><code>julia&gt; sqrt(1im)
0.7071067811865476 + 0.7071067811865475im


julia&gt; sqrt(1 + 2im)
1.272019649514069 + 0.7861513777574233im

julia&gt; cos(1 + 2im)
2.0327230070196656 - 3.0518977991518im

julia&gt; exp(1 + 2im)
-1.1312043837568135 + 2.4717266720048188im

julia&gt; sinh(1 + 2im)
-0.4890562590412937 + 1.4031192506220405im
</code></pre><p>说明一下，有如下公式成立</p>
<p><strong>angle(x)/2 = angle(sqrt(x))</strong></p>
<p>复数的开发实际是将相位/2，求新得到的相位上的长度的对应表示方法<br>复数的构造函数complex(a,b) -&gt; (a+bim)</p>
<p>注意一下INF Nan在复数上的表示</p>
<pre><code>julia&gt; 1 + Inf*im
1.0 + Inf*im

julia&gt; 1 + NaN*im
1.0 + NaN*im
</code></pre><h2 id="有理数"><a href="#有理数" class="headerlink" title="有理数"></a>有理数</h2><p>分数表示方式 2//3表示的是三分之二</p>
<pre><code>julia&gt; 2//3 == 6//9
true

julia&gt; 2//3 == 9//27
false

julia&gt; 3//7 &lt; 1//2
true

julia&gt; 3//4 &gt; 2//3
true

julia&gt; 2//4 + 1//6
2//3

julia&gt; 5//12 - 1//4
1//6

julia&gt; 5//8 * 3//12
5//32

julia&gt; 6//5 / 10//7
21//25
</code></pre><p>特殊注意的是分母为0时的情况</p>
<pre><code>julia&gt; 5//0
1//0

julia&gt; -3//0
-1//0

julia&gt; 0//0
ERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)
 in call at ./rational.jl:8
</code></pre><p>5//0显示为1//0，然后与分数运算，结果为1//0</p>
<pre><code>julia&gt; 5//0 + 1//2
1//0

julia&gt; 5//0 *1//2
1//0

julia&gt; 5//0 *10
1//0

julia&gt; 5//0 +1
1//0

julia&gt; 5//0 *100
1//0
</code></pre><p>分数表示的运算和浮点数运算规则一样，只是表示的方法一直都是分数</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>Julia的字符串支持的编码是UTF-8的，支持中文以及大众语言，当然,ascii的字符处理起来更快一点。</p>
<h3 id="字符串高级功能"><a href="#字符串高级功能" class="headerlink" title="字符串高级功能"></a>字符串高级功能</h3><p>关于Julia的字符串有一些值得注意的高级功能：</p>
<ul>
<li>Julia中用于字符串（和字符串文字）的内置具体类型是String。它通过UTF-8编码支持所有Unicode字符。（提供了一个函数来转换为/从其他Unicode编码转换。）</li>
<li>所有字符串类都是抽象类AbstractString的子类，外部包定义了其他AbstractString子类型（例如，用于其他编码-gbk）。如果定义了一个函数需要一个字符串参数，则应该将类型声明为AbstractString，这样可以接受任何类型字符串。</li>
<li>像C和Java一样，但与大多数动态语言不同，Julia有一个用于表示单个字符的第一类类型，称为AbstractChar。内置Char子类型AbstractChar是32位基本类型，可以表示任何Unicode字符（并且基于UTF-8编码）。</li>
<li>与在Java中一样，字符串是不可变的：AbstractString不能更改对象的值。要构造不同的字符串值，可以从其他字符串的来构造新字符串。</li>
<li>从概念上讲，字符串是从索引到字符的部分函数：对于某些索引值，不返回任何字符值，而是抛出异常。这允许通过编码表示的字节索引而不是字符索引有效地索引到字符串，这对于Unicode字符串的可变宽度编码不能有效且简单地实现。</li>
<li><strong>字符串的索引值下标从1开始的，a[0]会报错julia&gt; ab[0]</strong><br>ERROR: BoundsError: attempt to access 16-element Array{UInt8,1}:</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>字符是用单引号表示的，里面只能包含表示一个字符的表达式或者字母，如果不止一个字符则会报错</p>
<pre><code>julia&gt; &apos;x&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char

julia&gt; Int(&apos;x&apos;)
120

julia&gt; typeof(ans)
Int64

julia&gt; &apos;\u0&apos;
&apos;\0&apos;: ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; &apos;\u78&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &apos;\u2200&apos;
&apos;∀&apos;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; &apos;\U10ffff&apos;
&apos;\U10ffff&apos;: Unicode U+10ffff (category Cn: Other, not assigned)
更多ASCII字符表示可以百度一下
</code></pre><p>字符是可以比较和做加减法运算的，但是不能2个字符进行加法</p>
<pre><code>julia&gt; a = &apos;a&apos;
&apos;a&apos;

julia&gt; b = &apos;b&apos;
&apos;b&apos;

julia&gt; a+b
ERROR: MethodError: `+` has no method matching +(::Char, ::Char)
Closest candidates are:
  +(::Any, ::Any, ::Any, ::Any...)
  +(::Integer, ::Char)
  +(::Char, ::Integer)

julia&gt; a+1
&apos;b&apos;

julia&gt; a+2
&apos;c&apos;

julia&gt; b -a
1

julia&gt; b-1
&apos;a&apos;
</code></pre><h2 id="字符串基础"><a href="#字符串基础" class="headerlink" title="字符串基础"></a>字符串基础</h2><h3 id="字符串表示方式"><a href="#字符串表示方式" class="headerlink" title="字符串表示方式"></a>字符串表示方式</h3><p>字符串可以用双引号 三引号进行表示，当字符串内容里面需要有双引号的时候，可以使用三引号，也可以选择转义</p>
<pre><code>julia&gt; str = &quot;Hello, world.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;&quot;&quot;Contains &quot;quote&quot; characters&quot;&quot;&quot;
&quot;Contains \&quot;quote\&quot; characters&quot;
</code></pre><h3 id="字符串的访问"><a href="#字符串的访问" class="headerlink" title="字符串的访问"></a>字符串的访问</h3><p><strong>字符串的默认最后一个字符的下标为end</strong>，str[end]就是取最后一个元素，但是<strong>没有start，起始值就是1，也不是0</strong>，不能想当然。<br><strong>独此一份，Julia的下标是从1开始的，与其他计算机编程语言都不同</strong></p>
<pre><code>julia&gt; str[1]
&apos;H&apos;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
&apos;,&apos;: ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[end]
&apos;\n&apos;: ASCII/Unicode U+000a (category Cc: Other, control)
</code></pre><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>返回字符串str的第四位到第九位，包含9</p>
<pre><code>julia&gt; str[4:9]
&quot;lo, wo&quot;  
</code></pre><p>返回的是<strong>字符类型</strong></p>
<pre><code>julia&gt; str[6] 
&apos;,&apos;: ASCII/Unicode U+002c (category Po: Punctuation, other)
</code></pre><p>返回的是<strong>字符串类型</strong></p>
<pre><code>julia&gt; str[6:6]
&quot;,&quot; 
</code></pre><p>切片函数SubString(str,start,stop) #避免end歧义所以用的stop</p>
<pre><code>julia&gt; str = &quot;long string&quot;
&quot;long string&quot;

julia&gt; substr = SubString(str, 1, 4)
&quot;long&quot;

julia&gt; typeof(substr)
SubString{String}
</code></pre><p>unicode &amp; utf-8<br>这个知识点是计算机都有的，自行百度，其中一个：<br><a href="https://blog.csdn.net/humadivinity/article/details/79403625" target="_blank" rel="noopener">https://blog.csdn.net/humadivinity/article/details/79403625</a></p>
<h3 id="字符串的遍历"><a href="#字符串的遍历" class="headerlink" title="字符串的遍历"></a>字符串的遍历</h3><ul>
<li>for x in str的方式遍历<br>s = “a b c d”<br>julia&gt; for c in s<pre><code>    println(c)
end
</code></pre>a</li>
</ul>
<p>b</p>
<p>c</p>
<p>d</p>
<ul>
<li>foreach函数（我的版本中无效，官网是有写的）<br>foreach(display,s)</li>
</ul>
<h3 id="字符串构造函数"><a href="#字符串构造函数" class="headerlink" title="字符串构造函数"></a>字符串构造函数</h3><p>string(s1,s2,s3,s4)  -&gt;返回值为s1s2s3s4的拼接结果</p>
<pre><code>julia&gt; greet = &quot;Hello&quot;
&quot;Hello&quot;

julia&gt; whom = &quot;world&quot;
&quot;world&quot;

julia&gt; string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)
&quot;Hello, world.\n&quot;
</code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串不支持 s<em>number的格式来复制字符串，但是支持 s1 </em> s2 * s3来对s1 s2 s3进行拼接</p>
<h3 id="字符串引用"><a href="#字符串引用" class="headerlink" title="字符串引用"></a>字符串引用</h3><p>使用$符号后面接变量名称来引用变量存放的内容</p>
<pre><code>julia&gt; &quot;$greet, $whom.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;1 + 2 = $(1 + 2)&quot;
&quot;1 + 2 = 3&quot;

julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; &quot;v: $v&quot;
&quot;v: [1, 2, 3]&quot;

julia&gt; name = &apos;Bob&apos;
&apos;x&apos;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &quot;hi, $name&quot;
&quot;hi, Bob&quot;
</code></pre><h3 id="三引号字符串"><a href="#三引号字符串" class="headerlink" title="三引号字符串"></a>三引号字符串</h3><p>三引号字符串可以隐式换行，想在字符串中保持原文内容不变，可以采用三引号来表示。<br>显示的时候换行是用的 \n 来显示的</p>
<h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><p>字符串可以进行：<br>1 大小比较运算​<br>2 相等判断<br>3 查找是否包含<br>4 重复复制字符串 repeat(s,10) s复制10次<br>5 将列表转换为字符串，有2个参数，第二个可选，第一个参数含义是列表中的元素用参数1进行拼接，如果第二个参数有，则表示在最后一个元素前添加该参数，示例如下</p>
<pre><code>julia&gt; join([&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;,&quot;ddd&quot;],&quot;,&quot;,&quot; and &quot;)
&quot;aaa,bbb,ccc and ddd&quot;
</code></pre><p>6 其他一些有用的函数有包括：</p>
<p>firstindex(str)给出了可用于索引的最小（字节）索引str（对于字符串总是1，对于其他容器不一定是真的）。<br>lastindex(str)给出了可用于索引的最大（字节）索引str。<br>length(str)中的字符数str。<br>length(str, i, j)有效字符的数量指标的str，从i到j。<br>ncodeunits(str)字符串中的代码单元数。<br>codeunit(str, i)给出str索引处字符串中的代码单元值i。<br>thisind(str, i) 给一个字符串中的任意索引找到索引指向的字符的第一个索引。<br>nextind(str, i, n=1)找到n索引后开始的第th个字符的开头i。<br>prevind(str, i, n=1)找到n索引前的第th个字符的开头i。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式的表示方式<br>r”xxxxx”</p>
<p>你可以从RegexMatch对象中提取以下信息：</p>
<p>整个子串匹配： m.match<br>捕获的子串作为字符串数组： m.captures<br>整个匹配开始的偏差： m.offset<br>捕获的子串的偏移量作为向量： m.offsets</p>
<pre><code>julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2
</code></pre><p>子组的访问方式</p>
<pre><code>julia&gt; m=match(r&quot;(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)&quot;,&quot;12:45&quot;)
RegexMatch(&quot;12:45&quot;, hour=&quot;12&quot;, minute=&quot;45&quot;)

julia&gt; m[:minute]
&quot;45&quot;

julia&gt; m[2]
&quot;45&quot;
</code></pre><p><strong>将2个单词交换位置：</strong></p>
<pre><code>julia&gt; replace(&quot;first second&quot;, r&quot;(\w+) (?&lt;agroup&gt;\w+)&quot; =&gt; s&quot;\g&lt;agroup&gt; \1&quot;)
&quot;second first&quot;
</code></pre><p>正则函数</p>
<pre><code>julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{Nothing, SubString{String}},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/web前端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/web前端/" itemprop="url">web前端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T11:11:31+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,356 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="前端学习体系"><a href="#前端学习体系" class="headerlink" title="前端学习体系"></a>前端学习体系</h2><pre><code>1.HTML-用来勾勒出网页的结构和内容-骨架
2.CSS-用来美化网页-皮肤-化妆
3.JavaScript-让网页呈现出动态的数据和效果
4.jQuery-js框架，提高JavaScript开发效率
</code></pre><h2 id="浏览器介绍"><a href="#浏览器介绍" class="headerlink" title="浏览器介绍"></a>浏览器介绍</h2><pre><code>chrome safari  ---&gt; webkit
firefox ---&gt; mozilla
</code></pre><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><pre><code>html保存在服务器，html运行在浏览器
html--超文本标记语言
</code></pre><h2 id="HTMl-语法"><a href="#HTMl-语法" class="headerlink" title="HTMl 语法"></a>HTMl 语法</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code>&lt;标签&gt;&lt;/标签&gt;
ex:&lt;div&gt;&lt;/div&gt;
</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>&lt;标签 属性1=&quot;值1&quot; 属性2=&quot;值2&quot; ..&gt;&lt;/标签&gt;
ex:&lt;span id=&quot;s1&quot; style=&quot;..&quot;&gt;&lt;/span&gt;
</code></pre><h3 id="标签与标签之间的嵌套关系"><a href="#标签与标签之间的嵌套关系" class="headerlink" title="标签与标签之间的嵌套关系"></a>标签与标签之间的嵌套关系</h3><pre><code>&lt;div&gt;
    &lt;span id=&quot;s1&quot;&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><h3 id="标签的分类"><a href="#标签的分类" class="headerlink" title="标签的分类"></a>标签的分类</h3><pre><code>    1.闭合标签/双标签
        &lt;body&gt;内容&lt;/body&gt;
    2.非闭合标签/单标签
        &lt;标签&gt;
        &lt;标签/&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        单标签没有内容这个概念

总结：学习html，就是学习固定标签，固定属性
            以及标签间的嵌套关系
</code></pre><h2 id="HTML用法"><a href="#HTML用法" class="headerlink" title="HTML用法"></a>HTML用法</h2><pre><code>HTML  经历了5个版本
HTML4 之前版本很宽泛，宽松
HTML4 非常严谨
HTML5 是最新也是最流行的版本。比HTML4宽泛

&lt;!doctype html&gt;&lt;!--文档定义标签--&gt;
&lt;html&gt;&lt;!--根元素--&gt;
    &lt;head&gt;
        &lt;!--本网页相关信息--&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!--网页的主体，
        在页面中显示的所有内容
        都写在body里面--&gt;
        hello world!My first page!!
    &lt;/body&gt;
&lt;/html&gt;

总结：doctype用于约束HTML文档内部的
      标签，属性和嵌套关系
            不写doctype,同一篇代码，会在不同浏览器
            中，有巨大显示差异。
</code></pre><h2 id="HTML常见标签"><a href="#HTML常见标签" class="headerlink" title="HTML常见标签"></a>HTML常见标签</h2><h3 id="文本标签–跟论文格式非常相似"><a href="#文本标签–跟论文格式非常相似" class="headerlink" title="文本标签–跟论文格式非常相似"></a>文本标签–跟论文格式非常相似</h3><pre><code>标题  &lt;hn&gt;&lt;/hn&gt;  n=1~6
ex:   &lt;h1&gt;&lt;/h1&gt;
            ...
            &lt;h6&gt;&lt;/h6&gt;
总结：h1最大，h6最小
            字体加粗
            垂直方向，上下都有空间

段落 paragraph
    &lt;p&gt;&lt;/p&gt;
            垂直方向，上下都有空间
</code></pre><h3 id="课堂案例："><a href="#课堂案例：" class="headerlink" title="课堂案例："></a>课堂案例：</h3><pre><code>使用hn标签和p标签，写自己的简易的简历
属性 align=&quot;center&quot; 可以使用在标题标签中
</code></pre><h3 id="列表标签-显得有条理"><a href="#列表标签-显得有条理" class="headerlink" title="列表标签 显得有条理"></a>列表标签 显得有条理</h3><pre><code>3.1无序列表    
    u--unordered
    l--list
    i--item
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    ...
&lt;/ul&gt;
3.2有序列表
&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    ...
&lt;/ol&gt;
</code></pre><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><pre><code>&lt;div&gt;&lt;/div&gt;
div看不见，功能是为了逻辑分区
&lt;div id=&quot;header&quot;&gt;&lt;/div&gt; 头
&lt;div id=&quot;nav&quot;&gt;&lt;/div&gt; 导航栏
&lt;div id=&quot;contents&quot;&gt;&lt;/div&gt; 内容
&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt; 脚

H5添加了很多和div一样，
但是更容易读容易理解的标签
&lt;header&gt;&lt;/header&gt;
&lt;nav&gt;&lt;/nav&gt;
&lt;footer&gt;&lt;/footer&gt;

块级分区    div在这个区域独占一行

行级(行内)分区
    &lt;span&gt;&lt;/span&gt;
    如果只是一行文字内部的区域
    进行分区设置属性、修改样式
    这种时候使用行内分区

    行内分区不会换行，会和其他文字混合
    在同一行上span
</code></pre><h3 id="元素-标签-的显示方式"><a href="#元素-标签-的显示方式" class="headerlink" title="元素(标签)的显示方式"></a>元素(标签)的显示方式</h3><pre><code>1.行级元素(行内)
    可以和其他行级元素位于同一行显示
    span
2.块级元素
    自己独占一行
    hn p div ul li ol
</code></pre><h3 id="其他的行内元素"><a href="#其他的行内元素" class="headerlink" title="其他的行内元素"></a>其他的行内元素</h3><pre><code>i/em      斜体
b/strong  粗体
u         下划线
del/s            删除线
</code></pre><h3 id="实体引用，实体替换符号"><a href="#实体引用，实体替换符号" class="headerlink" title="实体引用，实体替换符号"></a>实体引用，实体替换符号</h3><pre><code>行内元素的空格折叠现象
写代码的时候，不管连写多少个空格和
回车，显示成一个空格

&lt;br&gt;
&lt;br/&gt;回车

&amp;nbsp; 空格
&amp;lt;  &lt;  
&amp;gt;  &gt;
</code></pre><p>复习：</p>
<p>1.网站运行的流程<br>    .html存储在服务器，运行在浏览器<br>2.h5 html的标准框架</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>3.文本标签<br>    hn p ul li ol<br>4.分区标签<br>    块级分区 div  header footer nav<br>    行级分区 span i em s del u strong b<br>5.块级元素与行级元素的区别<br>    块级元素，自己独占一行<br>    行级元素，可以与其他行级元素位于同一行<br>6.实体替代符号<br>    &nbsp;&lt;&gt;</p>
<p>作业：<br>1.网站的运行流程<br>2.行级元素与块级元素的区别<br>3.今天所有的demo重新敲一遍<br>4.详细的完善个人简历要使用div分区<br>    建议使用i b u等标签给关键内容修改样式</p>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><p>是一个单标签，最重要的属性src<br><img src="/2018/08/11/web前端/图片路径"></p>
<p>图片路径的写法<br>主机、路径、文件名都写清晰了<br>绝对路径<br>在一个显示其他网站中的图片，<br>这种行为图片盗链<br>通常使用绝对路径，称提供网页图片的网站为图床</p>
<p>好处就是，节省了自己服务器的存储空间<br>坏处，图床网站把图片路径改变，<br>            自己的网站就显示不出来了</p>
<p>相对路径–参照物–&gt;当前.html文件</p>
<pre><code>&lt;img src=&quot;08.png&quot;&gt;
&lt;img src=&quot;img/07.png&quot;&gt;
&lt;img src=&quot;../img/06.png&quot;&gt;
</code></pre><p>img的其他属性<br>img行级元素，自带了width和height<br>图片的失真<br>为了解决图片失真的问题<br>通常width和height只写一个<br>让另外一个去自适应</p>
<p>alt：找不到图片时，显示的文本<br>title：鼠标悬停在元素上，弹出的文本</p>
<p>img标签支持下面几种图片格式<br>png 支持透明色<br>jpg 不支持透明色<br>gif 支持动态图   256色</p>
<h2 id="超链接-用于跳转页面"><a href="#超链接-用于跳转页面" class="headerlink" title="超链接 用于跳转页面"></a>超链接 用于跳转页面</h2><p>作用：链接到网页，图片，下载<br>    <a href="http://www.baidu.cn/" target="_blank" rel="noopener">文本链接</a><br>    <a href="img/08.png">点我出图片</a><br>    <a href="01_img.html">跳转到01_img.html</a></p>
<p>a标签的属性<br>target    _self 链接页面在当前选项卡打开 默认值<br>                    _blank 链接页面在新的选项卡打开</p>
<p>两个页面之间的跳转，是超链接<br>一个页面内部的位置跳转，是锚点</p>
<p>H5锚点的用法:<br>在需要跳转的位置<br>标签内添加id属性<br>比如id=”abc”<br>在a标签中的href属性中<br>添加值 href=”#abc”<br>这样点击a标签，页面就会跳转到锚点的位置<br>另：href=”#”会让页面直接跳转到顶部</p>
<pre><code>&lt;h3 id=&quot;a&quot;&gt;charAt&lt;/h3&gt;
&lt;a href=&quot;#a&quot;&gt;charAt()方法&lt;/a&gt;
</code></pre><h2 id="网页中表格标签"><a href="#网页中表格标签" class="headerlink" title="网页中表格标签"></a>网页中表格标签</h2><pre><code>&lt;table border=&quot;2px&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;aaaa&lt;/td&gt;
        &lt;td&gt;bbbb&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;cccc&lt;/td&gt;
        &lt;td&gt;dddd&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>table是表格<br>tr  table row 行<br>td  table data 列</p>
<p>table的常用属性<br>width     宽<br>height    高<br>border    边框宽度<br>align     表格对其<br>cellpadding  边框与内容的距离<br>cellspacing  边框之间的距离</p>
<p>跨列，一个单元格占据多列</p>
<td colspan="n"></td><br>从左向右跨n列<br><br>跨行，一个单元格占据多行<br><br>    <td rowspan="n"></td>

<p>从上到下占n行<br>由于占据了下面几个单元格的位置<br>下面n-1行，都减少一个td</p>
<p>表分组<br>    <thead></thead><br>    <tbody></tbody><br>    <tfoot></tfoot></p>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>用于在页面中显示一个可以收集用户<br>填写的数据的控件</p>
<p>总结：<br>想通过网页把用户填入的信息发送给服务器处理<br>1.所有的标签必须在form表单中<br>2.form表单中的标签，必须有name属性<br>3.使用submit把数据提交给服务器</p>
<p>form表单的主要属性，以下了解即可<br>action:表单提交的url<br>method:表单提交数据的方法<br>enctype:表单数据的编码格式</p>
<p><strong>input 9种类型</strong></p>
<h3 id="文本框和密码框"><a href="#文本框和密码框" class="headerlink" title="文本框和密码框"></a>文本框和密码框</h3><pre><code>&lt;input type=&quot;text&quot; name=&quot;...&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;...&quot;&gt;
</code></pre><p>value属性 值<br>placeholder 文本提示<br>maxlength:限制输入的字符数<br>readonly:只读。自能看，不能改</p>
<h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><p>我们学习过span，span可用在任何地方<br>lable的作用跟span类似，但是只用在表单中</p>
<h3 id="radio-单选框"><a href="#radio-单选框" class="headerlink" title="radio 单选框"></a>radio 单选框</h3><pre><code>&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;
&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;
</code></pre><p>name属性，决定了一组单选<br>value属性，才能提交值！<br>checked=”checked” 默认选中</p>
<h3 id="checkbox-多选框"><a href="#checkbox-多选框" class="headerlink" title="checkbox 多选框"></a>checkbox 多选框</h3><p>name属性，决定了一组多选<br>value属性，才能提交值！<br>checked=”checked” 默认选中</p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>submit 提交</p>
<pre><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
</code></pre><h3 id="button-按钮"><a href="#button-按钮" class="headerlink" title="button 按钮"></a>button 按钮</h3><pre><code>&lt;input type=&quot;button&quot; value=&quot;点点我&quot;
onclick=&quot;alert(&apos;111111111111&apos;)&quot;&gt;
</code></pre><h3 id="reset-重置-基本不用"><a href="#reset-重置-基本不用" class="headerlink" title="reset 重置 基本不用"></a>reset 重置 基本不用</h3><h3 id="隐藏域-hidden"><a href="#隐藏域-hidden" class="headerlink" title="隐藏域 hidden"></a>隐藏域 hidden</h3><p>在form中存在，但是用户看不到<br>隐藏域包含着不给用户看的信息<br>隐藏域的信息，可以提交给服务器</p>
<p><strong>其他类型</strong><br>文件选择器-上传文件用的</p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>有name属性才能提交</p>
<h3 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h3><p>多重的，可以选择多个文件</p>
<h3 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h3><pre><code>&lt;textarea&gt;大量的文本&lt;/textarea&gt;    
</code></pre><p>rows cols描述的是文本区域内<br>可见的宽度和高度<br>原本的意思，每一行显示多少个字符，<br>显示多少行字符。<br>但是由于系统编码不同，浏览器解析不同<br>导致显示字符数差异很大。</p>
<h3 id="下拉列表-下拉选"><a href="#下拉列表-下拉选" class="headerlink" title="下拉列表(下拉选)"></a>下拉列表(下拉选)</h3><pre><code>&lt;select&gt;
    &lt;option&gt;&lt;/option&gt;
    ...
    &lt;option&gt;&lt;/option&gt;
&lt;/select&gt;
</code></pre><p>总结：<br>1.当option没有value属性<br>    select标签的value值是<br>    选中的那个option标签的内容<br>2.当option有value属性<br>    select标签的value值是<br>    选中的那个option标签的value值</p>
<p>表单标签总结:</p>
<ul>
<li>1.只有含有name属性的表单标签才可以提交数据</li>
<li>2.radio和checkbox必须<br>设置value属性才可以提交数据</li>
<li>3.text的value是直接设置值<br>placeholder是设置提示</li>
<li>4.radio和checkbox默认选中checked</li>
<li>5.select默认选中是selected</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><pre><code>&lt;span style=&quot;color:#f00;font-size:30px&quot;&gt;内联样式的使用&lt;/span&gt;
在标签的style属性中写样式
特点
内联样式使用不多
1.不能重用
2.内联样式优先级最高
项目代码完全不使用内联
只有在学习和调试过程中
</code></pre><h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><pre><code>在head标签中，写style标签
在style标签内部写样式
选择器{
    属性：值;
}
样式代码可以重用,但只能在本html中重用
在项目使用不多
</code></pre><h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><pre><code>创建一个.css文件
在html文件中，head标签中引用这个css文件
&lt;link href=&quot;03.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre><h2 id="层叠样式表的规则特性"><a href="#层叠样式表的规则特性" class="headerlink" title="层叠样式表的规则特性"></a>层叠样式表的规则特性</h2><pre><code>1.层叠效果
    多个样式作用在同一个标签上
    如果样式属性不重复
    那么这些样式都会产生效果
2.继承
    父级元素的样式会继承给子元素
    子元素可以重新写样式，
    不使用父级元素的样式
3.优先级
    优先级最低的 浏览器默认样式
    优先级最高的 内联样式

    内部样式和外部样式--就近优先
    以被影响标签为基准，哪个样式离这个标签近
    就使用哪个样式的效果
</code></pre><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code>选择器的作用，为了选出当前页面中
符合要求的一个或者多个标签

样式属性的作用，给选出来的标签设置样式

选择器{样式属性:值;}
</code></pre><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><pre><code>*{color:#f00;}
少用，写通用样式的时候使用
</code></pre><h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><pre><code>选出当前页面中，标签名称符合要求的标签
ex:div{} span{} p{} body{}
使用范围：设置某个标签的通用样式

body{
    maring:0px;
    padding:0px;
}
</code></pre><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><pre><code>唯一不重复
&lt;p id=&quot;p1&quot;&gt;id选择器1&lt;/p&gt;
#p1{
    color:#f00;
    font-size:25px;
    width:150px;        
}

id选择器 #id值
注意，同一个html中，ID值是唯一不可重复
在同一个html，使用id选择器，
只能找到一个标签
</code></pre><h3 id="类选择器-class选择器"><a href="#类选择器-class选择器" class="headerlink" title="类选择器 class选择器"></a>类选择器 class选择器</h3><pre><code>如果编写html标签时，需要让某些标签应用一类样式，就使用类选择器标签的属性,class为类名

&lt;div class=&quot;d1&quot;&gt;&lt;/div&gt;
.d1{
        width:200px;
        height:100px;
        background-color:#006699;
        border:1px solid #f00;
}

多类选择器

    .w200{
        width:200px;
    }
    .h50{
        height:50px;
    }
    .bgc_red{
        background-color:#f00;
    }        
    &lt;div class=&quot;w200 h50 bgc_red&quot;&gt;&lt;/div&gt;

    当一个标签，想匹配多个样式的时候，使用多类选择器
</code></pre><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><pre><code>把一系列选择器当成一组，设置共有样式。
#p1,.d1,h1,ul,li{
        border:2px solid #000;
}
逗号分隔，可以使用标签选择器，
id选择器，class选择器，混合编写
一般用于设置公共样式
一般项目中分组选择器，写在最开始的部分
</code></pre><h3 id="后代选择器-派生"><a href="#后代选择器-派生" class="headerlink" title="后代选择器(派生)"></a>后代选择器(派生)</h3><pre><code>div h1{
        color:#f00;
}

div内部只要存在h1，就可以定位h1
</code></pre><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><pre><code>div&gt;h1{
    background-color:pink;
}
h1必须是div的儿子才可以被匹配
</code></pre><h2 id="css常用样式属性"><a href="#css常用样式属性" class="headerlink" title="css常用样式属性"></a>css常用样式属性</h2><h3 id="布局-相关属性"><a href="#布局-相关属性" class="headerlink" title="布局 相关属性"></a>布局 相关属性</h3><pre><code>width: 宽
height:高
单位：px cm 100%
</code></pre><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><pre><code>margin:设置外边距
margin:10px;   同时设置4个方向的外边距
margin:10px 20px; 上下为10 左右为20
margin:0px auto;  块级元素水平居中
margin:10px 20px 30px 40px;
                上   右   下   左
margin-top:10px;  上边距
margin-right:
margin-bottom:
margin-left:

设置外边距，视觉效果，块级元素在位移
</code></pre><h4 id="内边距padding"><a href="#内边距padding" class="headerlink" title="内边距padding"></a>内边距padding</h4><pre><code>padding:10px;    设置4个方向的内边距
padding:10px 20px; 上下10px  左右20px
padding:10px 20px 30px 40px
                上    右   下   左
padding-top
padding-right
padding-bottom
padding-left

改变内边距，视觉效果，元素大小改变
</code></pre><h4 id="盒子模型-框结构"><a href="#盒子模型-框结构" class="headerlink" title="盒子模型(框结构)"></a><strong>盒子模型(框结构)</strong></h4><pre><code>css渲染页面时，使用盒子模型
元素之间的留白，元素背景填充范围，
元素大小。对这些属性的控制规则，
就是盒子模型

我们写的元素，
在浏览器中占据的空间是多少(宽度)

左外边距+左边框+左内边距
+内容区域(我们设置的宽高)
+右内边距+右边框+右外边距

总结：
div默认占据宽度，
是父容器的内容区域宽度的100%
div默认的高，是内部内容的高
如果内部没有内容或者没有高
高度为0
</code></pre><h3 id="背景属性background"><a href="#背景属性background" class="headerlink" title="背景属性background"></a>背景属性background</h3><pre><code>1.背景颜色
    background-color:合法的颜色值
    background:合法的颜色值

    合法的颜色值：
    1.颜色的单词 red pink
    2.#ffffff 6位16进制字符串
    3.#aabbcc ---&gt; #abc  #f00 #ff0000
    4.rgb(255,255,255);
    5.rgba(255,255,255,0~1)

2.背景图片 
    background-image:url(&quot;图片路径&quot;)
    background-repeat:no-repeat;平铺方式        
                    repeat
                    repeat-x;
                    repeat-y;
    background-position:center center;背景图片定位
                        center top bottom left right
                        可以直接写数值100px 200px
    background-size:500px 500px;设置背景图片的大小
</code></pre><p><strong>注意点：</strong></p>
<pre><code>块级元素和行级元素区别
块级元素可以设置宽高
行级元素，除了自代宽高属性的标签，
其他行级元素，设置宽高无效
margin-top,margin-bottom对行级元素无效
</code></pre><p><strong><br>选择器补充</strong></p>
<pre><code>伪类选择器
:hover
当鼠标悬浮在标签上，使用此样式
</code></pre><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript?"></a>什么是JavaScript?</h2><p>JavaScript是运行的客户端的解释性脚本语言。</p>
<p>客户端是浏览器(包括:IE、Firefox、Chrome、Safari、Opera)</p>
<p>解释性脚本是指程序语言的一种执行方式;</p>
<p>JavaScript与Java之间不存在任何关系;</p>
<p>JavaScript最早由网景公司在 1995 年发行的 Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript.</p>
<p>Microsoft在其IE浏览器推出JScript与其抗衡.</p>
<p>欧洲计算机制造商协会(ECMA)在借鉴JavaScript1.5的基础上推出</p>
<p>ECMAScript,从而成为所有脚本语言的标准.</p>
<p>ECMAScript(ES)最新的版本为ECMAScript-6(简称ES6)</p>
<h2 id="JavaScript的语法结构"><a href="#JavaScript的语法结构" class="headerlink" title="JavaScript的语法结构"></a>JavaScript的语法结构</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   ...
   ...
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;JS文件路径及名称&quot;&gt;&lt;/script&gt;
</code></pre><p>第一步:创建JS文件并且写入相关的代码;</p>
<p>第二步:在网页文件内调用相关的JS文件;</p>
<p>说明:</p>
<pre><code>A.JS严格区分大小写;

B.每行JS代码必须以分号结尾;

C.JavaScript文件的扩展名为.js
</code></pre><h2 id="变量-Varaible"><a href="#变量-Varaible" class="headerlink" title="变量(Varaible)"></a>变量(Varaible)</h2><p>变量是指存储在计算机内存中有名称的信息,其值在程序运行期间可以发生变化;</p>
<p>声明变量</p>
<p>var 变量名称;</p>
<p>var 变量名称 = 值;</p>
<h3 id="变量名称的命名规范"><a href="#变量名称的命名规范" class="headerlink" title="变量名称的命名规范"></a>变量名称的命名规范</h3><pre><code>A.变量名称必须以字母或下划线开头,包含字母、数字及下划线;

B.变量名称禁止与系统关键字相同;

C.变量名称必须遵守&quot;驼峰标记法&quot;;

D.变量名称必须含义明确;
</code></pre><h3 id="JavaScript关键字"><a href="#JavaScript关键字" class="headerlink" title="JavaScript关键字:"></a>JavaScript关键字:</h3><p>var、if、else、switch、case、break、default、for、while、function</p>
<p>ECMAScript关键字:</p>
<p>class、float、boolean、object、extends、public、protected、private、interface、abstract、implements</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符型-string"><a href="#字符型-string" class="headerlink" title="字符型(string):"></a>字符型(string):</h3><p>必须括在双引号或单引号之间;</p>
<pre><code>转义符:
\n,换行
\r,回车
\t,水平制表符
\v,垂直制表符
\f,换页(走纸)
\\,反斜线
\&apos;,单引号
\&quot;,双引号
</code></pre><h3 id="数值型-number"><a href="#数值型-number" class="headerlink" title="数值型(number)"></a>数值型(number)</h3><p>包括整型和浮点型,可以带有符号位,可存储八进制、十进制、十六进制的数字;</p>
<p>八进制的表示方法为0[0-7]+</p>
<p>十六进制的表示方法0[x|X][0-9a-fA-F]+</p>
<h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型(boolean)"></a>布尔型(boolean)</h3><p>只能存储true或false</p>
<h3 id="未定义-undefined"><a href="#未定义-undefined" class="headerlink" title="未定义(undefined)"></a>未定义(undefined)</h3><p>值只能为undefined</p>
<pre><code>以下变量的值为undefined

A.声明但没有赋值的变量;

B.声明但赋值为undefined的变量;

C.引用对象不存在的属性;
</code></pre><h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象(object)"></a>对象(object)</h3><p>属性与方法的集合体;</p>
<pre><code>{
    propert:value,
    ....,
    method:function([parameter,...]){
        ...
        ...
    }
}
</code></pre><h3 id="null-空对象"><a href="#null-空对象" class="headerlink" title="null(空对象)"></a>null(空对象)</h3><p>其作用是为断开继承链(原型链);</p>
<h3 id="function-自定义函数"><a href="#function-自定义函数" class="headerlink" title="function(自定义函数)"></a>function(自定义函数)</h3><p>可以重复执行的代码段;</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="按作用划分"><a href="#按作用划分" class="headerlink" title="按作用划分"></a>按作用划分</h3><p>1 字符运算符: + </p>
<p>2 数学运算符:+(正号)、-(负号)、*、/、%、+、-</p>
<p>3 比较运算符:&gt;、&gt;=、==(等于)、!=(不等于)、===、!==(不全等)、&lt;=、&lt;</p>
<p>  全等:(1)值相同(2)数据类型相同</p>
<p>4 逻辑运算符:!、&amp;&amp;、||  </p>
<p>  短路现象:在进行&amp;&amp;或||运算时,只有第一个表达式的值可以</p>
<p>  确定整个表达式结果时,后续表达式将忽略执行;</p>
<p>5 自增/自减运算符</p>
<p>  i++、i–,后缀形式:先使用,后加减</p>
<p>  ++i、–i,前缀形式:先加减,后使用</p>
<p>6 赋值运算符:=、+=、-=、*=、/=、%=</p>
<h3 id="按参加运算的操作数的数量"><a href="#按参加运算的操作数的数量" class="headerlink" title="按参加运算的操作数的数量"></a>按参加运算的操作数的数量</h3><ul>
<li><p>单目运算符:只有一个操作数,如负数(-)、逻辑非(!)</p>
</li>
<li><p>双目运算符:有两个操作数,如加号(+)、大于(&gt;)等</p>
</li>
<li><p>三目运算符:expression ? value1 : value2</p>
</li>
</ul>
<p><strong>运算符优先级</strong></p>
<p>一、二、三、赋值</p>
<p>算术、比较、逻辑</p>
<p>案例:</p>
<pre><code>var p = !true || 3 + 2 - 5 &lt;= 7
        false || 3 + 2 - 5 &lt;= 7
        false || 0 &lt;= 7
        false || true
        true
</code></pre><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre><code>if(condition){
   ...
   ...
}

if(condition){
    ...
    ...
} else {
    ...
    ...
}

if(condition){
    ...
} else if(condition){
    ... 
} else if(condition){
    ...
} ... else{
    ...
}
</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><pre><code>switch(expression){
    case 值1:
       ...
       break;
    case 值2:
       ...
       break;
    case N
       break;
    default:
       ...
       break;
}
</code></pre><p>说明:</p>
<p>A. if语句的条件表达式只能为布尔型(可能存在数据类型的自动转换)</p>
<p>   switch语句的表达式可以为任意数据类型(布尔除外)</p>
<p>B. if语句每次执行时都将对变量进行取值操作;而switch只进行一次取值操作;</p>
<p>C. switch语句进行全等运算;</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>1 for语句</p>
<pre><code>for(expr1;expr2;expr3){
    ...
}
</code></pre><p>  说明:</p>
<p>  expr1,在循环之前无条件执行一次,一般于变量初始化;</p>
<p>  expr2,在循环前执行一次,以判断能否进入循环体;</p>
<p>  expr3,在循环后执行一次,一般用于步长的计算;</p>
<p>  for语句的表达式可以省略其中任何一个或全部;</p>
<p>2 while语句</p>
<pre><code>while(条件表达式){
   ...
   ...
}
</code></pre><p>  说明:</p>
<p>  A.死循环:指条件永远为真的循环语句.</p>
<p>  B.for语句和while语句同属”当型循环(先判断,后执行)”,所以可以互换;</p>
<p>3 do…while循环</p>
<pre><code>do{
  ...
  ...
} while(条件表达式);
</code></pre><p>  说明:</p>
<p>  A.do…while是先执行,后判断;</p>
<p>  B.do…while语句至少执行一次;而当型循环(for、while)至少执行零次;</p>
<p>4 for…in语句</p>
<pre><code>for(key in array){
    ...
    ...
}
</code></pre><p>5 break语句:结束switch及循环语句 </p>
<p>6 continue语句:跳过当前的循环而进行下一次的循环</p>
<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h3><h4 id="构建String对象"><a href="#构建String对象" class="headerlink" title="构建String对象"></a>构建String对象</h4><p>   直接量方式 </p>
<p>   ‘string’或”string”</p>
<p>   构造函数方式</p>
<pre><code>new String(&apos;string&apos;)
</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>   length</p>
<p>   描述:返回字符串的长度</p>
<p>   语法:int object.length</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>   toLowerCase()</p>
<p>   描述:将字符转换小写字母</p>
<p>   语法:</p>
<pre><code>string object.toLowerCase(void)
</code></pre><hr>
<p>   toUpperCase()</p>
<p>   描述:将字符转换大写字母</p>
<p>   语法：</p>
<pre><code>string object.toUpperCase(void)
</code></pre><hr>
<p>   substr()</p>
<p>   描述:截取字符串</p>
<p>   语法:</p>
<pre><code>string object.substr(int start[,int length])
</code></pre><p>   说明:</p>
<p>   A.字符串从0开始编号;</p>
<p>   B.如果省略length参数,则返回到字符串结尾之间的字符</p>
<p>   C.如果start参数为负数,则倒数;</p>
<hr>
<p>   substring</p>
<p>   描述:截取字符串</p>
<p>   语法:string object.substring(int start[,int end])</p>
<p>   说明:</p>
<p>   A.返回的字符串包含起始位,不包含结束位;</p>
<p>   B.如果省略end参数,则返回到字符串结尾之间的字符;</p>
<hr>
<p>   indexOf()</p>
<p>   描述:返回字符串第一次出现的位置,如果没有出现,则返回-1</p>
<p>   语法:int object.indexOf(string)</p>
<hr>
<p>   lastIndexOf()</p>
<p>   描述:返回字符串最后一次出现的位置,如果没有出现,则返回-1</p>
<p>   语法:int object.lastIndexOf(string)</p>
<hr>
<p>   replace()方法</p>
<p>   描述:字符串替换</p>
<p>   语法:</p>
<p>   string object.replace(string search,string replacement)</p>
<p>   string object.replace(object RegExp,string replacement)</p>
<hr>
<p>   split()</p>
<p>   描述:使用分隔符拆分字符串</p>
<p>   语法:</p>
<p>   array object.split(delimiter)</p>
<p>   array object.split(RegExp)   </p>
<h4 id="ES6新增方法"><a href="#ES6新增方法" class="headerlink" title="ES6新增方法"></a>ES6新增方法</h4><p>   trim()</p>
<p>   描述:删除第一个之前及最后一个字符之后的空白</p>
<p>   语法:string object.trim(void)</p>
<hr>
<p>   startsWith()</p>
<p>   描述:检测字符是否以指字符开头</p>
<p>   语法:bool object.startsWith(string)</p>
<hr>
<p>   endsWith()</p>
<p>   描述:检测字符是否以指字符结尾</p>
<p>   语法:bool object.endsWith(string)</p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p>  Math对象是一个静态对象.</p>
<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>  Math.PI,圆周率</p>
<p>  Math.SQRT2,2的平方根</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>  Math.ceil()</p>
<p>  描述:进一取整</p>
<p>  语法:number Math.ceil(number)</p>
<hr>
<p>  Math.floor()</p>
<p>  描述:舍一取整</p>
<p>  语法:number Math.floor(number)</p>
<hr>
<p>  Math.pow()</p>
<p>  描述:幂运算</p>
<p>  语法:number Math.pow(base,exp)</p>
<hr>
<p>  Math.sqrt()</p>
<p>  描述:平方根</p>
<p>  语法:number Math.sqrt(number)</p>
<hr>
<p>  Math.min()</p>
<p>  描述:最小值</p>
<p>  语法:number Math.min(num1,num2,…)</p>
<hr>
<p>  Math.max()</p>
<p>  描述:最大值</p>
<p>  语法:number Math.max(num1,num2,…)</p>
<hr>
<p>  Math.random()</p>
<p>  描述:产生介于0~1之间的随机数(0&lt;=X&lt;1)</p>
<p>  语法:number Math.random(void)</p>
<hr>
<p>  Math.round()</p>
<p>  描述:四舍五入(仅保留到整数位置)</p>
<p>  语法:number Math.round(number)</p>
<h3 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h3><h4 id="构建Date对象"><a href="#构建Date对象" class="headerlink" title="构建Date对象"></a>构建Date对象</h4><p>   new Date()</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>   getYear()</p>
<p>   描述:获取年份(从公元1900到现在经历的年份)</p>
<p>   语法:int object.getYear(void)</p>
<hr>
<p>   getFullYear()</p>
<p>   描述:获取年份</p>
<p>   语法:int object.getFullYear(void)</p>
<hr>
<p>   getMonth()</p>
<p>   描述:获取月份(取值范围为0~11)</p>
<p>   语法:int object.getMonth(void)</p>
<hr>
<p>   getDate()</p>
<p>   描述:获取日期(xx号)</p>
<p>   语法:int object.getDate(void)</p>
<hr>
<p>   getDay()</p>
<p>   描述:获取星期的第几天(0为星期日,依次类推)</p>
<p>   语法:int object.getDay(void)</p>
<hr>
<p>   getHours()</p>
<p>   描述:获取小数</p>
<p>   语法:int object.getHours(void)</p>
<hr>
<p>   getMinutes()</p>
<p>   描述:获取分钟数</p>
<p>   语法:int object.getMinutes(void)</p>
<hr>
<p>   getSeconds()</p>
<p>   描述:获取秒数</p>
<p>   语法:int object.getSeconds(void)</p>
<hr>
<p>   getMilliseconds()</p>
<p>   描述:获取毫秒</p>
<p>   语法:int object.getMilliseconds(void)</p>
<hr>
<p>   getTime()</p>
<p>   描述:返回从公元1970年到现在的毫秒数</p>
<p>   语法:int object.getTime(void)</p>
<hr>
<p>   toUTCString()/toGMTString()</p>
<p>   描述:将日期转换成UTC/GMT格式</p>
<p>   语法:string object.toUTCString(void)</p>
<pre><code>string object.toGMTString(void)
</code></pre><h4 id="ES6新增的方法"><a href="#ES6新增的方法" class="headerlink" title="ES6新增的方法"></a>ES6新增的方法</h4><pre><code>Date.now() 静态方法

描述:返回从公元1970年到现在的毫秒数

语法:int Date.now(void)

说明:该方法为静态方法
</code></pre><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><h4 id="构建Array对象"><a href="#构建Array对象" class="headerlink" title="构建Array对象"></a>构建Array对象</h4><p>   直接量方式</p>
<p>   [value,…]</p>
<p>   构造函数方式</p>
<p>   new Array(length)</p>
<p>   new Array(value,…)</p>
<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>   length</p>
<p>   描述:获取数组成员的数量</p>
<p>   语法:int object.length</p>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><p>   unshift()</p>
<p>   描述:在数组的开头添加一个或多个成员,并返回数组的新长度</p>
<p>   语法:int object.unshift(value,…)</p>
<hr>
<p>   push()</p>
<p>   描述:在数组的未尾添加一个或多个成员,并返回数组的新长度</p>
<p>   语法:int object.push(value,…)</p>
<hr>
<p>   shift() </p>
<p>   描述:删除数组的第一个成员,并且返回该成员</p>
<p>   语法:mixed object.shift(void)  </p>
<hr>
<p>   pop()</p>
<p>   描述:删除数组的最后一个成员,并且返回该成员</p>
<p>   语法:mixed object.pop(void)     </p>
<hr>
<p>   join()</p>
<p>   描述:    将数组成员使用指定分隔符连接成字符串</p>
<p>   语法:string object.join(delimiter)</p>
<hr>
<p>   isArray()</p>
<p>   描述:判断是否为数组(静态方法) </p>
<p>   语法:bool Array.isArray(obj)</p>
<h4 id="数组遍历-–-forEach-语句"><a href="#数组遍历-–-forEach-语句" class="headerlink" title="数组遍历 – forEach()语句"></a>数组遍历 – forEach()语句</h4><pre><code>object.forEach(function(value[,index]){
        ...
        ...
});
</code></pre><h3 id="Regular-Expression对象-正则表达式对象"><a href="#Regular-Expression对象-正则表达式对象" class="headerlink" title="Regular Expression对象(正则表达式对象)"></a>Regular Expression对象(正则表达式对象)</h3><p>构建正则表达式对象</p>
<p>  直接量方式</p>
<p>  /正则表达式/修正符</p>
<p>  构造函数方式</p>
<p>  new RegExp(‘正则表达式’,’修正符’)</p>
<p>正则表达式</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>   \d,匹配数字,等价于[0-9]</p>
<p>   \D,匹配非数字,等价于[^0-9]</p>
<p>   \s,匹配任意的空白字符,等价于[\n\r\t\v\f]</p>
<p>   \S,匹配任意的非空白字符,等价于[^\n\r\t\v\f]</p>
<p>   \w,匹配任意的字母、数字及下划线,等价于[0-9a-zA-Z_]</p>
<p>   \W,匹配任意的非字母、数字及下划线,等价于[^0-9a-zA-Z_]</p>
<p>   ., 匹配除换行外的任意字符</p>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>   ?,出现零次或一次,等价于{0,1}</p>
<p>   *,至少出现零次,等价于{0,}</p>
<p>   +,至少出现一次,等价于{1,}</p>
<p>   {m},出现m次</p>
<p>   {m,},至少出现m次</p>
<p>   {m,n},至少出现m次,至多n次(m&lt;=x&lt;=n)</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>   |,或者</p>
<p>   ^,以指定字符开头</p>
<p>   $,以指定字符结尾</p>
<p>   […],表示在范围之内,如[0-9]</p>
<p>   [^…],表示不在范围之内,如[^3-5]</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>   \n,换行</p>
<p>   \r,回车</p>
<p>   \t,水平制表符</p>
<p>   \v,垂直制表符</p>
<p>   \f,换页(走纸)</p>
<p>   \,反斜线</p>
<p>   .,点</p>
<p>   |,竖线</p>
<p>   *,星号</p>
<p>   \?,问号</p>
<h4 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h4><p>   (…)</p>
<p>   (?:…)</p>
<h4 id="修正符"><a href="#修正符" class="headerlink" title="修正符"></a>修正符</h4><p>   g(global),全局</p>
<p>   i(ignore),忽略大小写</p>
<p><strong>方法</strong></p>
<p>  test()</p>
<p>  描述:检测字符串是否符合正则表达式规范</p>
<p>  语法:bool object.test(string)</p>
<h1 id="前端编程"><a href="#前端编程" class="headerlink" title="前端编程"></a>前端编程</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><pre><code>DOM(Document Object Model),文档对象模型

JavaScript由ECMAScript(简称ES)、DOM和BOM组成;

ECMAScript:关键字、保留关键字、流程语句、数据类型、内置对象;

DOM:提供操作HTML/XML文档相关的API;

DOM由DOM Core、HTML DOM和XML DOM组成;

DOM Core:提供处理HTML和XML文档的API;

HTML DOM:提供处理HTML文档的API;

XML DOM:提供处理XML文档的API;
</code></pre><p><strong>在DOM树中一切皆节点;</strong></p>
<h2 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><pre><code>1,代表元素节点(指HTML标记)

2,代表属性节点(指HTML标记的属性)

3,代表文本节点(指纯文本)

8,代表注释节点(指HTML注释)

9,代表文档节点(指整个HTML文档)
</code></pre><h3 id="节点的关系"><a href="#节点的关系" class="headerlink" title="节点的关系"></a>节点的关系</h3><p>子节点:一个节点是另一个节点的直接下一级节点;</p>
<p>如</p>
<pre><code>&lt;i&gt;&lt;b&gt;...&lt;/b&gt;&lt;/i&gt;
</code></pre><p>父节点:一个节点是另一个节点的直接上一级节点;</p>
<p>兄弟节点:同一个父节点的所有子节点</p>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><p>  <strong>nodeName</strong></p>
<p>  描述:获取节点的名称</p>
<p>  语法:string node.nodeName<br><strong><br>  nodeValue</strong></p>
<p>  描述:获取节点值</p>
<p>  语法:string node.nodeValue</p>
<p>  <strong>nodeType</strong></p>
<p>  描述:获取节点的类型</p>
<p>  语法:int node.nodeType</p>
<p>  <strong>childNodes</strong></p>
<p>  描述:返回节点内所有的子节点形成的集合(数组)</p>
<p>  语法:NodeList node.childNodes</p>
<h3 id="方法-4"><a href="#方法-4" class="headerlink" title="方法"></a>方法</h3><p>  appendChild()</p>
<p>  描述:追加子节点</p>
<p>  语法:Node node.appendChild(node)                </p>
<p>  说明:返回的是新插入的子节点</p>
<hr>
<p>  removeChild()</p>
<p>  描述:删除子节点</p>
<p>  语法:Node node.removeChild(node)</p>
<h2 id="document对象-继承自Node"><a href="#document对象-继承自Node" class="headerlink" title="document对象(继承自Node)"></a>document对象(继承自Node)</h2><h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><p>  documentElement</p>
<p>  描述:返回文档的根元素</p>
<p>  语法:Element document.documentElement</p>
<h3 id="方法-5"><a href="#方法-5" class="headerlink" title="方法"></a>方法</h3><p>  getElementById()</p>
<p>  描述:根据对象ID来获取元素</p>
<p>  语法:Element document.getElementById(string id)</p>
<hr>
<p>  createElement()</p>
<p>  描述:创建元素节点</p>
<p>  语法:Element document.createElement(string tagName)</p>
<h2 id="Element对象-继承自Node"><a href="#Element对象-继承自Node" class="headerlink" title="Element对象(继承自Node)"></a>Element对象(继承自Node)</h2><h3 id="方法-6"><a href="#方法-6" class="headerlink" title="方法"></a>方法</h3><p>  getAttribute()</p>
<p>  描述:获取属性值</p>
<p>  语法:string Element.getAttribute(string name)</p>
<hr>
<p>  setAttribute()</p>
<p>  描述:设置属性</p>
<p>  语法:void Element.setAttribute(string name,string value)</p>
<hr>
<p>  removeAttribute()</p>
<p>  描述:删除属性</p>
<p>  语法:void Element.removeAttribute(string name)</p>
<hr>
<p>  hasAttribute()</p>
<p>  描述:返回是否存在指定属性</p>
<p>  语法:bool Element.hasAttribute(string name)</p>
<h2 id="HTML-与-DOM"><a href="#HTML-与-DOM" class="headerlink" title="HTML 与 DOM"></a>HTML 与 DOM</h2><p> HTML DOM提供针对处理HTML文档的API.</p>
<p><strong>1 选取对象</strong></p>
<pre><code>Element document.getElementById(string id)

NodeList document.getElementsByTagName(string tagName)

NodeList Element.getElementsByTagName(string tagName)
</code></pre><p><strong>2 属性控制</strong></p>
<pre><code>A.对于单个单词的HTML标记属性即HTML DOM对象属性;

B.对于合成词的HTML标记属性(如table标记的cellpading、cellspacing属性)在HTML DOM编程时,采用&quot;驼峰标记法&quot;命名(如cellPadding、cellSpacing)

C.对于HTML标记的class属性,在HTML DOM编程时使用className取代;
  (因为class是ECMAScript中的关键字)

D.对于HTML标记的布尔属性(如单/复选框的checked、列表项的selected属性)在HTML DOM编程时采用boolean类型表示;

E.在HTML DOM编程时,某些HTMLDOM对象有自己特有的属性/方法;

F.HTML标记的style属性在HTML DOM编程时形成CSSStyleDeclaration/CSS2Properties对象;
</code></pre><p><strong>3 HTMLDocument对象</strong></p>
<p>  getElementsByName()方法</p>
<p>  描述:获取文档中name属性相同的对象的组成的集合(数组)</p>
<p>  语法:NodeList document.getElementsByName(string name)</p>
<h3 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h3><h4 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h4><p><strong>title</strong></p>
<p>描述:获取/设置标题栏信息</p>
<p>语法: document.title = value 或 var 变量名称 = document.title</p>
<p><strong>head</strong></p>
<p>描述:获取文档的head对象</p>
<p>语法:Element document.head</p>
<p><strong>body</strong></p>
<p>描述:获取文档的body对象</p>
<p>语法:Element document.body</p>
<p><strong>images</strong></p>
<p>描述:返回文档中所有的图像组成的集合(数组)</p>
<p>语法:NodeList document.images</p>
<p><strong>forms</strong></p>
<p>描述:返回文档中所有的表单组成的集合(数组)</p>
<p>语法:NodeList document.forms</p>
<p><strong>links</strong></p>
<p>描述:返回文档中所有的<link>标记组成的集合(数组)</p>
<p>语法:NodeList document.links</p>
<p><strong>anchors</strong></p>
<pre><code>描述:返回文档中所有的&lt;a&gt;标记组成的集合(数组)

语法:NodeList document.anchors
</code></pre><hr>
<h4 id="方法-7"><a href="#方法-7" class="headerlink" title="方法"></a>方法</h4><p><strong>querySelectorAll()</strong></p>
<p>描述:返回由使用指定的CSS选择器的对象组成的集合(数组)</p>
<p>语法:NodeList document.querySelectorAll(selector)</p>
<p>说明:该方法支持所有CSS3选择器</p>
<p><strong>querySelector()</strong></p>
<p>描述:返回由使用指定的CSS选择器的对象的第一个元素</p>
<p>语法:Element document.querySelector(selector)</p>
<h3 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h3><p><strong>属性</strong></p>
<p>tagName</p>
<p>描述:获取元素的标记名称</p>
<p>语法:string Element.tagName</p>
<p><strong>方法</strong></p>
<p>querySelector()</p>
<p>描述:返回由使用指定的CSS选择器的对象的第一个元素</p>
<p>语法:Element  Element.querySelector(selector)</p>
<p>querySelectorAll()</p>
<p>描述:返回由使用指定的CSS选择器的对象组成的集合(数组)</p>
<p>语法:NodeList Element.querySelectorAll(selector)</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="BOM定义"><a href="#BOM定义" class="headerlink" title="BOM定义"></a>BOM定义</h3><p>BOM(Browser Object Model),浏览器对象模型,提供与浏览器相关的API.</p>
<p>  window对象是BOM的顶级对象,代表浏览器窗口或iframe或frame.</p>
<h3 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h3><p>  document 描述:返回HTMLDocument对象</p>
<p>  history  描述:返回History对象</p>
<p>  screen 描述:返回Screen对象</p>
<p>  navigator 描述:返回Navigator对象</p>
<p>  location 描述:返回Location对象</p>
<p>  Math 描述:返回Math对象</p>
<h3 id="方法-8"><a href="#方法-8" class="headerlink" title="方法"></a>方法</h3><p>  alert()方法</p>
<p>  描述:弹出警示对话框(只有一个确定按钮)</p>
<p>  语法:window.alert(string)</p>
<hr>
<p>  confirm()方法</p>
<p>  描述:弹出询问对话框(有确定和取消两个按钮)</p>
<p>  语法:bool window.confirm(string)</p>
<hr>
<p>  setInterval()</p>
<p>  描述:每间隔指定的时间执行相关的代码(重复执行)</p>
<p>  语法:int window.setInterval(function,milliseconds)</p>
<hr>
<p>  clearInterval()</p>
<p>  描述:清除由setInterval()设置的timeId</p>
<p>  语法:window.clearInterval(int timeId)</p>
<hr>
<p>  setTimeout()  </p>
<p>  描述:间隔指定的时间后执行相关的代码(执行一次)</p>
<p>  语法:int window.setTimeout(function,milliseconds)</p>
<hr>
<p>  clearTimeout()</p>
<p>  描述:清除由setTimeout()设置的timeId</p>
<p>  语法:window.clearTimeout(int timeId)</p>
<hr>
<p>  parseInt()</p>
<p>  描述:转换成整数</p>
<p>  语法:int parseInt(value)</p>
<hr>
<p>  parseFloat()</p>
<p>  描述:转换成浮点数</p>
<p>  语法:int parseFloat(value)</p>
<hr>
<p>  isNaN()</p>
<p>  描述:检测值是否为NaN(Not a Number)</p>
<p>  语法:bool isNaN(value)</p>
<h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><p>  href属性</p>
<p>  描述:获取/设置地址栏中的地址信息</p>
<p>  语法:</p>
<p>  location.href = string</p>
<p>  var 变量名称 = location.href</p>
<p>  search属性</p>
<p>  描述:获取地址栏”?”以后所有的参数</p>
<p>  语法:string location.search</p>
<p>  reload()</p>
<p>  描述:重新加载文档</p>
<p>  语法:location.reload(void)</p>
<h3 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h3><p>  width属性</p>
<p>  描述:获取显示分辨率宽度</p>
<p>  语法:number screen.width</p>
<p>  height</p>
<p>  描述:获取显示分辨率高度</p>
<p>  语法:number screen.height</p>
<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><p>  back()</p>
<p>  描述:后退一步</p>
<p>  语法:history.back(void)</p>
<p>  forward()</p>
<p>  描述:前进一步</p>
<p>  语法:history.forward(void)</p>
<p>  go()</p>
<p>  描述:前进/后退</p>
<p>  语法:history.go(number)</p>
<p>  说明:如果为负数,则后退;否则前进;</p>
<p>  history.back() 等价于 history.go(-1)</p>
<p>  history.forward() 等价于 history.go(1)  </p>
<h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><p>  userAgent属性(简称UA)</p>
<p>  描述:返回代理器信息</p>
<p>  语法:string navigator.userAgent</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON基础</p>
<p>  JSON(JavaScript Object Notation),是一种轻量级的数据交换格式;</p>
<p>  JSON的官网  <a href="http://www.json.org" target="_blank" rel="noopener">http://www.json.org</a></p>
<p>JSON支持的数据格式</p>
<p>  数组:[value,….]</p>
<p>  对象:{property:value,….}</p>
<h2 id="jQuery操作DOM"><a href="#jQuery操作DOM" class="headerlink" title="jQuery操作DOM"></a>jQuery操作DOM</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><pre><code>语法：$(&quot;创建的完整标记&quot;);
ex:
    1、创建一对div元素
        var $div = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;);
        $div.html(&quot;&lt;h1&gt;...&lt;/h1&gt;&quot;);
        $div.attr(&quot;id&quot;,&quot;container&quot;);
    2、创建一个图像标记
        var $img = $(&quot;&lt;img&gt;&quot;);
        $img.attr(&quot;src&quot;,&quot;img/a.jpg&quot;);
</code></pre><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><pre><code>1、内部插入
    作为子元素插入到网页中
    1、$obj.append($new);
        将$new元素追加到$obj元素的尾部(最后一个子元素)
    2、$obj.prepend($new);
        将$new元素添加到$obj元素的头部(第一个子元素)
2、外部插入
    作为兄弟元素插入到网页中
    1、$obj.before($new)
        将$new作为$obj的上一个兄弟元素插入进来
    2、$obj.after($new)
        将$new作为$obj的下一个兄弟元素插入进来
</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code>1、remove()
    语法：$obj.remove();
    作用：删除 $obj 元素
2、remove(&quot;selector&quot;)
    语法：$obj.remove(&quot;selector&quot;);
    作用：将满足 selector 选择器的元素删除出去
3、empty()
    语法：$obj.empty()
    作用：清空$obj内的内容
</code></pre><h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><pre><code>1、children() / children(selector)
    作用：获取某对象中的子元素(只考虑元素节点)或满足selector选择器的子元素(只考虑元素节点)。
    注意：只能获取子元素，不能获取后代元素
2、next() / next(selector)
    作用：获取某对象的下一个兄弟元素 / 满足selector的下一个兄弟元素
3、prev() / prev(selector)
    作用：获取某对象的上一个兄弟元素 / 满足selector的上一个兄弟元素
4、siblings() / siblings(selector)
    作用：获取某对象的所有兄弟元素 / 满足selector的兄弟元素
5、find(selector)
    查找满足selector选择器的所有后代元素
6、parent()
    作用：获取某对象的父元素
</code></pre><h3 id="jQuery事件处理"><a href="#jQuery事件处理" class="headerlink" title="jQuery事件处理"></a>jQuery事件处理</h3><h4 id="页面加载后的执行"><a href="#页面加载后的执行" class="headerlink" title="页面加载后的执行"></a>页面加载后的执行</h4><pre><code>在DOM树加载完成后就要执行的操作
1、
    $(document).ready( function(){
        //页面的初始化操作
        //DOM树加载完毕后就开始运行
    } );

2、
    $().ready( function(){

    } );
3、
    $( function(){

    });
</code></pre><h4 id="jQuery的事件绑定"><a href="#jQuery的事件绑定" class="headerlink" title="jQuery的事件绑定"></a>jQuery的事件绑定</h4><pre><code>1、方式1
    $obj.bind(&quot;事件名称&quot;,事件处理函数);

    ex:
        $obj.bind(&quot;click&quot;,function(){
            alert(&quot;单击事件&quot;);
        });

2、方式2
    $obj.事件名称(事件处理函数);

    ex:
        $obj.click(function(){

        });

注意：
    在事件处理函数中，允许使用 this 来表示触发当前事件的DOM对象
</code></pre><h4 id="事件参数对象-事件对象"><a href="#事件参数对象-事件对象" class="headerlink" title="事件参数对象(事件对象):"></a>事件参数对象(事件对象):</h4><pre><code>1、获取事件对象
    1、
        &lt;button onclick=&quot;btnClick(event)&quot;&gt;&lt;/button&gt;

        function btnClick(event){

        }
    2、
        &lt;button id=&quot;btnTest&quot;&gt;&lt;/button&gt;

        var btn = document.getElementById(&quot;btnTest&quot;);
        btn.onclick = function(event){
            event : 表示当前事件的事件对象
        }


2、事件对象的属性
    1、offsetX
        获取鼠标所操作的点的 横坐标值
    2、offsetY
        获取鼠标所操作的点的 纵坐标值
    3、target
        获取事件源(事件所在的元素)
</code></pre><p><strong>this:</strong><br>1、this 在全局函数中，永远都表示的是 window 对象<br>2、this 在局部函数中，表示都是函数的所有者<br>    btn.onclick = function(){<br>        this:表示的就是函数的所有者 -&gt; btn </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/网络通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/网络通信/" itemprop="url">网络通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T18:53:02+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  17,530 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  71 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>网络起源 （了解）</p>
<p>网络目的 ： 数据的传输</p>
<p>ISO ： 国际标准化组织</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>—-》 网络通信的标准化流程</p>
<p><strong>应用层 ： 提供用户服务，具体的内容由特定程序规定<br>表示层 ： 数据的压缩优化加密<br>会话层 ： 建立应用连接，选择传输层服务<br>传输层 ： 提供数据传输服务，流量控制<br>网络层 ： 路由选择，网络互连<br>链路层 ： 提供链路交换，具体的消息的发送<br>物理层 ： 物理硬件，接口 网卡的规定 </strong></p>
<p><strong>osi模型优点</strong> ：<br> 将功能分开，降低网络传输中的耦合度每一部分完成自己的功能，开发更加清晰专一</p>
<p><strong>四层模型</strong></p>
<ul>
<li>应用层 ：  应用层 表示层  会话层</li>
<li>传输层 ：  传输层</li>
<li>网络层 ：  网络层</li>
<li>物理链路层：   链路层  物理层</li>
</ul>
<p><strong>五层模型（tcp/ip模型）</strong></p>
<ul>
<li>应用层 ：  应用层 表示层  会话层</li>
<li>传输层 ：  传输层</li>
<li>网络层 ：  网络层</li>
<li>链路层 ：  链路层  </li>
<li>物理层 ：  物理层</li>
</ul>
<p><strong>要求 ： </strong></p>
<p>能够按顺序说出七层模型 五层和四层模型<br>知道每一层是什么作用<br>对网络消息传输流程有基本了解</p>
<p><strong>协议 ：</strong><br>网络通信中，各方必须遵守的规定。包括建立什么样的连接，消息结构等。</p>
<ul>
<li>应用层 ： TFTP  HTTP  DNS  SMTP</li>
<li>传输层 ： TCP  UDP</li>
<li>网络层 ： IP</li>
<li>物理层 ： IEEE</li>
</ul>
<p>网络相关概念</p>
<p><strong>主机 ：</strong> host  表示一台计算机</p>
<p>本地使用 ：  ‘localhost’<br> ‘’<br> ‘127.0.0.1’<br>网络使用 ： ‘0.0.0.0’<br> ‘172.60.50.60’  本机ip地址，自己的电脑可以ipconfig或者ifconfig查看</p>
<p><strong>获取计算机名：</strong><br>In [2]: socket.gethostname()<br>Out[2]: ‘godshion’</p>
<p>通过计算机名获取地址：<br>In [3]: socket.gethostbyname(‘godshion’)<br>Out[3]: ‘127.0.1.1’</p>
<p><strong>IP地址</strong></p>
<p>在网络上确定一台主机的地址<br>IPv4 ：点分十进制 比如 192.168.1.72  0–255<br>   32位二级制表示</p>
<p>IPv6 ： 128位二进制</p>
<p>查看本机Ip方法<br>windows    cmd.exe 窗口 –&gt; ipconfig<br>linux      查看本机地址 ifconfig</p>
<p><strong>网络连接测试</strong><br>ping  172.60.50.60</p>
<p>特殊IP<br>127.0.0.1   本地测试IP<br>0.0.0.0    使用局域网内可用的IP<br>192.168.1.0  表示当前网段<br>192.168.1.1  通常是网络节点设备的IP （网关）<br>192.168.1.255  广播地址</p>
<p>通过域名获取服务器信息<br> socket.gethostbyaddr(‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>)<br>(‘127.0.0.1’, [],    [‘119.75.213.61’])<br>   主机     主机别名   主机IP</p>
<p>将点分十进制IP转换为二进制<br>In [11]: socket.inet_aton(‘192.168.1.2’)<br>Out[11]: b’\xc0\xa8\x01\x02’<br>将二进制转换为点分十进制IP<br>In [12]: socket.inet_ntoa(b’\xc0\xa8\x01\x02’)<br>Out[12]: ‘192.168.1.2’</p>
<p>功能 ： 同上面两个完全相同。只是可以选择地址类型<br>inet_pton（socket.AF_INET,’192.168.1.2’）<br>inet_ntop（）</p>
<p>域名： 网络服务器地址的网络名称</p>
<p>端口号 ： 端口号是网络地址的一部分，在一个系统中 每个网络应用都会有一个端口号相对应。用来在接收消息时确定由谁来接收</p>
<p>范围 ： 1–65535<br>1–255 一些通用的众所周知程序占用<br>256-1023  系统应用端口<br>1024 — 65535   自用   &gt;10000 </p>
<p><strong>获取应用端口：</strong><br>In [16]: socket.getservbyname(‘mysql’)<br>Out[16]: 3306</p>
<p>字节序<br>数据在内存中的存储解析方式，不同操作系统可能不同</p>
<p>网络字节序 ： 不同的操作系统在消息收发时均按照该标准操作。</p>
<p>传输层服务</p>
<p>面向连接的传输服务  —-&gt; </p>
<h2 id="tcp协议-面向连接的传输服务"><a href="#tcp协议-面向连接的传输服务" class="headerlink" title="tcp协议   面向连接的传输服务"></a>tcp协议   面向连接的传输服务</h2><p><strong>传输特征：</strong></p>
<ul>
<li>可靠的数据传输</li>
<li>可靠性指数据传输中 无失序 无差错 无丢失  无重复</li>
<li>所有消息传输前一定会建立连接，传输后一定会断开连接</li>
</ul>
<p><strong>三次握手：</strong><br>在进行面向连接的数据传输前进行传输连接的过程</p>
<ol>
<li>客户端向服务器发送连接请求（问是否可以连接）</li>
<li>服务器接收到连接请求进行确认，返回报文</li>
<li>客户端收到回复，进行连接建立</li>
</ol>
<p><strong>四次挥手：</strong><br>在进行面向连接的数据传输时，断开连接的过程</p>
<ol>
<li>主动方发送报文 告知被动方要断开连接</li>
<li>被动方返回报文，告知收到请求，准备断开</li>
<li>被动方再次发送报文给主动方，告知准备完毕可以断开</li>
<li>主动方发送报文进行断开</li>
</ol>
<p>应用情况 ：适用于传输较大的内容或文件，网络情况良好，需要保证传输可靠性的情况<br>比如 ： 聊天信息，文件的上传下载，邮件传输 网页获取</p>
<h2 id="udp协议-面向无连接的传输服务"><a href="#udp协议-面向无连接的传输服务" class="headerlink" title="udp协议  面向无连接的传输服务"></a>udp协议  面向无连接的传输服务</h2><p><strong>传输特点：</strong></p>
<ul>
<li>不保证可靠的数据传输</li>
<li>没有连接过程</li>
<li>数据的收发都比较自由，不会受另一端制约</li>
</ul>
<p>适用情况： 网络情况较差，对传输可靠情形要求不高。需要提升传输效率的情况<br>比如 ： 网络视频，群聊，发送广播</p>
<p><strong>问题总结：</strong></p>
<ol>
<li>osi模型问题</li>
<li>三次握手四次挥手问题</li>
<li>tcp和udp的区别</li>
</ol>
<h2 id="socket套接字编程"><a href="#socket套接字编程" class="headerlink" title="socket套接字编程"></a>socket套接字编程</h2><p>目的 : 通过编程语言提供的函数接口进行组合，更简单的完成基于 tcp 或者udp通信的网路编程</p>
<p>套接字 ： 完成上述目标的一种编程方法</p>
<p>套接字分类</p>
<p>流式套接字（SOCK_STREAM）: 传输层基于tcp的协议进行通信</p>
<p>数据报套接字 （SOCK_DGRAM）：传输层基于udp协议进行通信</p>
<p>底层套接字 （SOCK_RAM）:访问底层协议的套接字</p>
<h2 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h2><h3 id="1-创建套接字"><a href="#1-创建套接字" class="headerlink" title="1. 创建套接字"></a>1. 创建套接字</h3><pre><code>import  socket
socket.socket(socket_family = AF_INET，
              socket_type = SOCK_STREAM,
                            proto = 0)
</code></pre><p>功能 ： 创建一个套接字<br>参数 ： socket_family  : 选择地址族类型 AF_INET<br>socket_type ：套接字类型 SOCK_STREAM 流式 SOCK_DGRAM 数据报<br>proto ：子协议类型，没有子协议选择 0<br>返回值 ： 套接字对象</p>
<h3 id="2-绑定地址（IP-端口号）"><a href="#2-绑定地址（IP-端口号）" class="headerlink" title="2. 绑定地址（IP 端口号）"></a>2. 绑定地址（IP 端口号）</h3><pre><code>sockfd.bind()
</code></pre><p>功能 ： 绑定地址<br>参数 ：<br>一个元组包含两项<br>第一项为IP<br>第二项为端口号（’172.60.50.50’,8888）</p>
<h3 id="3-将套接字设置可监听"><a href="#3-将套接字设置可监听" class="headerlink" title="3. 将套接字设置可监听"></a>3. 将套接字设置可监听</h3><pre><code>sockfd.listen(n)
</code></pre><p>功能 ： 将套接字设置为监听套接字<br>参数 ： n是一个正整数 表示监听等待队列的大小</p>
<h3 id="4-等待接收连接请求"><a href="#4-等待接收连接请求" class="headerlink" title="4. 等待接收连接请求"></a>4. 等待接收连接请求</h3><pre><code>connfd,addr = sockfd.accept()
</code></pre><p>功能： 阻塞等待处理客户端连接<br>返回值 ：<br>第一个 ： 一个新的套接字用来和客户端通信<br>第二个 ： 连接的客户端的地址</p>
<p><strong>阻塞函数：</strong>程序运行到阻塞函数的位置，如果某种期待条件没有达成则暂停继续运行。当条件达成后会结束阻塞继续运行。</p>
<h3 id="5-收发消息"><a href="#5-收发消息" class="headerlink" title="5. 收发消息"></a>5. 收发消息</h3><pre><code>data = connfd.recv(buffersize)
</code></pre><p>功能 ： 流式套接字接收消息<br>参数 ： 一次最多接收多大的消息  字节<br>返回值 ： 返回接收到的内容</p>
<pre><code>n = connfd.send(data)
</code></pre><p>功能 ： 流式套接字发送消息<br>参数 ： 要发送的内容  要求bytes格式<br>返回值 ： 返回实际发送的字节数</p>
<h3 id="6-关闭套接字"><a href="#6-关闭套接字" class="headerlink" title="6. 关闭套接字"></a>6. 关闭套接字</h3><pre><code>close（）
</code></pre><p>功能：关闭套接字 tcp套接字连接断开</p>
<h2 id="tcp-客户端"><a href="#tcp-客户端" class="headerlink" title="tcp 客户端"></a>tcp 客户端</h2><h3 id="1-创建套接字-1"><a href="#1-创建套接字-1" class="headerlink" title="1. 创建套接字"></a>1. 创建套接字</h3><pre><code>socket()
</code></pre><h3 id="2-请求连接"><a href="#2-请求连接" class="headerlink" title="2. 请求连接"></a>2. 请求连接</h3><pre><code>connect()
</code></pre><p>功能： 发起连接请求<br>参数： 是一个元组，表示服务器的地址</p>
<h3 id="3-消息收发"><a href="#3-消息收发" class="headerlink" title="3. 消息收发"></a>3. 消息收发</h3><pre><code>recv()  send()
</code></pre><h3 id="4-关闭套接字"><a href="#4-关闭套接字" class="headerlink" title="4. 关闭套接字"></a>4. 关闭套接字</h3><pre><code>close()
</code></pre><p>服务器端示例代码<br>        import socket</p>
<pre><code># from select_word import *

HOST  = &apos;127.0.0.1&apos;
PORT = 10889

# 创建套接字
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#param3: proto = 0
#这里设置端口重用，不然每次按ctrl+c取消程序的时候会出现端口被占用的错误
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
# socket_family = socket.AF_INET 选择地址族类型，AF_INET 是选择的ipv4
# socket_type = socket.SOCK_STREAM　套接字类型　　SOCK_STREAM是tcp协议
# proto 通常为０　子协议类型
# 返回一个套接字对象

# 绑定地址
s.bind((HOST,PORT))
# 参数只有一个，是二个元素的元组，分别为ip port

# 将套接字设置可监听
s.listen(1)
# 参数ｎ表示将听扽该队列的大小

# 等待接收请求
conn,addr = s.accept()
# 阻塞等待处理客户端连接，如果某种期待条件没有达成则暂停运行，条件达成继续运行
# 返回一个新的套接字用来和客户端通讯
# 连接的客户端的地址
print(&quot;client&apos;s Address:&quot;,addr)
# 收发消息
# while True:
    # 流式套接字接收消息，依次最多接收多大字节的消息，返回接收到的内容
while True:
    data = conn.recv(1024).decode(&quot;utf-8&quot;) 
    #recv函数在一方断开连接的情况下，会立即结束阻塞状态，并返回一个空字符串
    if not data :
        break
    print(&quot;Receive data: &quot;,data)
    # 流式套接字发送消息，参数是发送的内容，要求是bytes格式，返回发送的字节数量

    # result = searchword(data)
    # print(result)
    # conn.send(str(result).encode(&quot;utf-8&quot;)) 
    conn.send(data.encode(&quot;utf-8&quot;)) 
    #broken pipe　管道破裂．　
    #1,如果一端不存在，另一方还在企图发送消息时产生brokenpipeerrot
# 关闭套接字，连接断开
conn.close()
</code></pre><p>客户端代码：<br>        import socket<br>        HOST = “127.0.0.1”<br>        PORT = 10889</p>
<pre><code># 创建套接字
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#这里设置端口重用，不然每次按ctrl+c取消程序的时候会出现端口被占用的错误
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

# 创建连接
s.connect((HOST,PORT))
# 发起连接请求，参数是一个元组，表示服务器的地址　

data = &quot;hello&quot;
# s.send(&apos;aaa&apos;.encode(&quot;utf-8&quot;))
while data:
    # 消息收发
    s.send(data.encode(&quot;utf-8&quot;))
    data = s.recv(512)
    print(&apos;recv data is: &apos;,data)
    data = input(&apos;please input:  &apos;)


# 关闭套接字
s.close()
</code></pre><p>运行结果<br>        ~/桌面/web/tcp$ python3 server.py<br>        client’s Address: (‘127.0.0.1’, 52826)<br>        Receive data:  hello<br>        Receive data:  aaa<br>        Receive data:  bbb<br>        Receive data:  ccc<br>        Receive data:  ddd</p>
<pre><code>~/桌面/web/tcp$ python3 client.py 
recv data is:  b&apos;hello&apos;
please input:  aaa
recv data is:  b&apos;aaa&apos;
please input:  bbb
recv data is:  b&apos;bbb&apos;
please input:  ccc
recv data is:  b&apos;ccc&apos;
please input:  ddd
recv data is:  b&apos;ddd&apos;
please input:
</code></pre><p>作业 ： </p>
<ol>
<li>口述 什么是七层模型，tcp/ip模型<br>三次握手和四次挥手的过程<br>tcp协议的传输和udp协议的传输有何区别</li>
<li>将tcp程序改写为一个通过循环可连续收发消息的程序</li>
</ol>
<h3 id="recv-特性"><a href="#recv-特性" class="headerlink" title="recv() 特性"></a>recv() 特性</h3><ol>
<li>如果连接双方断开连接，则recv会立即结束阻塞返回空字符串</li>
<li>当接收缓冲区为空的时候会阻塞</li>
<li>如果recv一次接收不完缓存去内容，下一次会继续接收</li>
</ol>
<h3 id="send（）特性"><a href="#send（）特性" class="headerlink" title="send（）特性"></a>send（）特性</h3><ol>
<li>如果一段不存在，另一端还在试图send操作时会产生BrokenPipeError异常</li>
<li>当发送缓冲区慢的时候会阻塞</li>
</ol>
<h3 id="网络收发缓冲区"><a href="#网络收发缓冲区" class="headerlink" title="网络收发缓冲区"></a>网络收发缓冲区</h3><p>发送和接收消息均先放到缓冲区中，在进行处理<br>即 recv和send实际是从缓冲区接收内容，向缓冲区发送消息</p>
<h3 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h3><p><strong>产生原因：</strong><br>tcp传输中以字节流的方式发送内容，发送的消息之间没有明显的边界，此时如果发送和接收速度不匹配就会产生粘包</p>
<p>影响 ： 如果每次发送的内容表示一个独立的意思此时可能需要处理粘包。如果发送的内容本身就是连续的整体，此时不需要处理粘包</p>
<p><strong>如何处理：</strong></p>
<ol>
<li>每次发送后加一个结尾标志</li>
<li>发送一个数据结构</li>
<li>每次发送中间有一个短暂的延迟</li>
</ol>
<h2 id="基于udp的服务端"><a href="#基于udp的服务端" class="headerlink" title="基于udp的服务端"></a>基于udp的服务端</h2><ol>
<li>创建套接字 —》 数据报套接字<br> sockfd = socket(AF_INET,SOCK_DGRAM)</li>
<li>绑定服务端地址<br> sockfd.bind()</li>
<li><p>消息的收发<br> data，addr = recvfrom(buffersize)<br> 功能 ： 接收UDP消息<br> 参数 ： 每次最多接收消息的大小<br> 返回值 ： 接收到的内容 </p>
<pre><code>接收到的消息的发送者
</code></pre><p> recvfrom 一次接收一个数据包，如果数据包超出了一次能够接收的大小则会丢失没有收到的内容</p>
<p> sendto(data，addr)<br> 功能 ： udp发送消息<br> 参数 ： data  要发送的内容  bytes</p>
<pre><code>addr  消息要发送给谁
</code></pre><p> 返回值 ： 发送的字节</p>
</li>
<li><p>关闭套接字<br> sockfd.close()</p>
</li>
</ol>
<p><em>小贴士： </em><br><em>sys.argv<br>功能 ： 获取来自命令行的参数，形成一个列表<br>argv[0]是命令本身 其他内容默认以空格分割放到列表中</em></p>
<h3 id="tcp流式套接字和udp数据报套接字使用区别"><a href="#tcp流式套接字和udp数据报套接字使用区别" class="headerlink" title="tcp流式套接字和udp数据报套接字使用区别"></a>tcp流式套接字和udp数据报套接字使用区别</h3><ol>
<li>流式套接字采用字节流的方式传输，而数据报套接字以数据包形式传输</li>
<li>tcp会产生粘包现象，udp不会</li>
<li>tcp编程保证传输的可靠性，udp则不保证</li>
<li>tcp需要listren accept ，udp不需要</li>
<li>tcp使用recv  send进行消息收发，udp使用recvfrom和sendto</li>
</ol>
<p>补充：<br><strong>sendall（）</strong><br>功能参数： 同send<br>返回值 ： 发送成功返回None  发送失败返回异常</p>
<h2 id="套接字对象"><a href="#套接字对象" class="headerlink" title="套接字对象"></a>套接字对象</h2><p>(s表示一个套接字对象)</p>
<ul>
<li><p>s.fileno()<br>功能 ： 获取套接字的文件描述符<br>文件描述符 ：每一个IO 事件操作系统都会分配一个不同的正数与之匹配，该正数即为此IO操作的文件描述符<br>sys.stdin    0<br>sys.stdout   1<br>sys.stderr   2</p>
</li>
<li><p>s.type : 获取套接字类型</p>
</li>
<li><p>s.family: 地址类型</p>
</li>
<li><p>s.getsockname()<br>功能 ： 获取套接字绑定的地址</p>
</li>
<li><p>s.getpeername()<br>功能 ： 用户连接套接字，获取连接端的地址</p>
</li>
<li><p>s.setsockopt(level,optname,value)<br>功能 ： 设置套接字选项 丰富修改原有套接字功能<br>参数：<br>level ： 设置选项的类型 IPPROTP_TCP  IPPROTO_IP  SOL_SOCKET<br>optname： 选项类型中的子选项<br>value ： 为选定的选项设置值</p>
</li>
<li><p>s.getsockopt(level,optname)<br>功能 ： 获取套接字选项值<br>参数：  level ： 获取选项的类型 IPPROTP_TCP  IPPROTO_IP SOL_SOCKET<br>optname： 选项类型中的子选项<br>返回值 ： 获取到的值</p>
</li>
</ul>
<h2 id="udp套接字应用之广播"><a href="#udp套接字应用之广播" class="headerlink" title="udp套接字应用之广播"></a>udp套接字应用之广播</h2><p>特点：一点发送多点接收<br>目标地址 ：广播地址 一个网段内最大的地址<br>172.60.50.<strong>255</strong></p>
<p><em>小贴士：<br>format()<br>功能 ： 字符串属性函数 用来组合字符串</em></p>
<p><strong>广播风暴</strong>：占用大量的带宽造成网络拥塞</p>
<h2 id="tcp应用之-http传输"><a href="#tcp应用之-http传输" class="headerlink" title="tcp应用之 http传输"></a>tcp应用之 http传输</h2><p>HTTP协议 —&gt; 超文本传输协议</p>
<p>用途 ： 编写基于http协议的数据传输程序，网站中浏览器端获取网页的过程<br>将想要获取的内容，以http协议的格式发送给服务端，服务端根据格式进行解析获取到真实需求，将结果以http协议的格式回复给客户端</p>
<p><strong>特点 ：</strong> </p>
<ol>
<li>应用层协议 ，传输层使用tcp服务</li>
<li>简单，灵活，和多中语言对接方便</li>
<li>无状态的协议 即不记录用户使用过程中传递的内容</li>
<li>http1.1 支持持久连接</li>
</ol>
<h3 id="http请求-（Request）"><a href="#http请求-（Request）" class="headerlink" title="http请求 （Request）"></a>http请求 （Request）</h3><p>请求格式：</p>
<p>1 请求行    具体的请求类别<br>   GET           /         HTTP/1.1<br>   请求种类   请求内容    协议版本</p>
<p>   请求头    对请求新的的具体描述<br>   Accept: text/html<br>   以键值对的格式对信息进行具体描述</p>
<p>2 空行</p>
<p>3 请求体    具体的请求参数或者提交内容</p>
<p><strong>请求类型：</strong><br>GET        获取网络资源<br>POST       提交一定的附加数据，得到返回结果<br>HEAD       获取响应头<br>PUT        更新服务器资源<br>DELETE     删除服务器次元<br>CONNECT<br>TRACE      用于测试<br>OPTIONS    获取服务器性能</p>
<h3 id="HTTP响应-（Response）"><a href="#HTTP响应-（Response）" class="headerlink" title="HTTP响应 （Response）"></a>HTTP响应 （Response）</h3><p>响应格式：</p>
<p>1 响应行   反馈具体的响应情况<br> HTTP/1.1    200      OK<br> 版本       响应码   附加信息 </p>
<p>2 响应头   对响应的具体描述<br> Accept-Ranges: bytes<br> 以键值对方式给出响应信息的具体描述</p>
<p>3 空行<br> 响应体   将客户想要的内容进行返回</p>
<p><strong>响应码种类</strong><br>1xx    提示信息，表示请求已经接受<br>2xx    响应成功<br>3xx    响应需要重定向<br>4xx    客户端错误<br>5xx    服务端错误</p>
<p>200  成功<br>404  请求内容不存在<br>401  没有访问权限<br>500  服务器发生未知错误<br>503  服务器暂时不能执行</p>
<p>思考 ：<br>什么是http协议<br>请求格式和每部分的功能<br>响应格式和每部分功能<br>http请求和响应的流程</p>
<p>作业 ：<br>通过流式套接字完成一个文件的发送<br>将一个文件从客户端发送给服务端或者从服务端发送给客户端均可</p>
<h2 id="基础的http服务器"><a href="#基础的http服务器" class="headerlink" title="基础的http服务器"></a>基础的http服务器</h2><p>1.接收HTTP请求<br>2.给出一定的响应</p>
<p>IO  input   output</p>
<p>在内存中存在数据交换的操作都可以认为是输入输出<br>比如：<br>内存和磁盘交互  读写操作<br>内存和网络交互  recv  send</p>
<h3 id="IO密集型程序"><a href="#IO密集型程序" class="headerlink" title="IO密集型程序"></a>IO密集型程序</h3><p>程序执行中大量的IO操作，而较少的cpu运算。消耗cpu较少，运行时间长</p>
<p><strong>CPU密集型程序（计算密集型）</strong>：程序中大量的操作都需要cpu运算，IO操作较少。消耗cpu大，运行速度快</p>
<h4 id="IO-分类"><a href="#IO-分类" class="headerlink" title="IO 分类"></a>IO 分类</h4><p>阻塞IO  非阻塞IO  IO多路复用  事件IO   异步IO。。</p>
<p>1 阻塞IO ： 默认形态 效率很低的一种IO情形</p>
<p>阻塞情况 ：因为某种条件没有达成造成的阻塞<br>e.g.   accept   recv   input</p>
<p>处理IO事件的时候耗时比较长形成阻塞<br>e.g.  文件的读写过程，网络数据发送过程</p>
<p>2 非阻塞IO ： 通过修改IO事件的属性，使其变为非阻塞的状态。（改变了第一种阻塞的状况）</p>
<p>通常和循环搭配使用，不断检测阻塞条件是否已经满足。</p>
<p>s.setblocking()<br>功能： 将套接字设置为非阻塞状态<br>参数： bool   设置为False则表示设置为非阻塞</p>
<h3 id="超时检测"><a href="#超时检测" class="headerlink" title="超时检测"></a>超时检测</h3><p>将原本阻塞的函数，设置一个阻塞的最长时间，在规定时间内如果条件达到则正常执行，如果仍然阻塞则抛出异常</p>
<p>s.settimeout(sec)<br>功能 ： 设置套接字超时时间<br>参数 ： 设置的时间</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>定义 ： 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。以此形成，多个IO事件都可以操作，不必诸个等待执行的效果。</p>
<p>准备就绪：IO事件即将发生的临界状态</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>import select</p>
<p>select —-&gt; windows  linux  unix<br>poll —&gt; linux unix<br>epoll –&gt; linux  unix</p>
<p> r, w, x = select(rlist, wlist, xlist[, timeout])<br> 功能：监控IO事件，阻塞等待IO事件的发生<br> 参数：<br>   rlist  列表  存放我们监控等待处理的IO事件<br>   wlist  列表  存放我们要主动处理的IO事件<br>   xlist  列表  存放如果发生异常需要我们处理的<br>   timeout 数字  超时时间<br>   返回值：r  列表   rlist当中准备就绪的IO<br>   w  列表   wlist当中准备就绪的IO<br>   x  列表   xlist当中准备就绪的IO</p>
<p><em>注意事项 ： </em><br>1.在处理IO过程中不应该发生死循环（某个IO单独占有服务器）<br>2.IO多路复用行了一种并发的效果，效率较高</p>
<p>练习 ： 写一个select服务端  同时关注客户端端的连接，客户端的发送和终端的输入。将客户端发送的内容和终端输入的内容均写入到一个文件中</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>按照二进制位进行操作运算</p>
<p>&amp;(按位与)    |（按位或）    ^（按位异或）<br>&lt;&lt;（左移）    &gt;&gt;（右移） </p>
<p>11  1011<br>14  1110</p>
<p>&amp;   1010  一0则0<br>|   1111  一1则1<br>^   0101  相同为0不同为1<br>11 &lt;&lt; 2  ==&gt; 44   右侧补0<br>14 &gt;&gt; 2  ==&gt; 3    挤掉低位的数字</p>
<p>使用 ： </p>
<ol>
<li>在做底层硬件的寄存器操作</li>
<li>在做标志位过滤时</li>
</ol>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><ul>
<li><p>创建poll对象<br>p = select.poll()</p>
</li>
<li><p>添加关注对象<br>p.register(s，POLLIN | POLLERR)<br>p.unregister(s)<br>poll IO事件类型分类<br>POLLIN POLLOUT  POLLERR POLLHUP  POLLPRI  POLLVAL<br>rlist   wlist   xlist    断开   紧急处理  无效数据</p>
</li>
<li><p>进行监控<br>events = p.poll()<br>功能： 阻塞等待register的事件发生<br>返回值 ： events 是一个列表，列表中每个元素表示准备就绪需要处理的IO<br>[(fileno,event),          (),()]<br>  描述符 具体什么就绪了<br>描述符地图｛s.fileno(): s｝</p>
</li>
<li><p>处理IO事件</p>
</li>
</ul>
<p>作业 ： </p>
<ol>
<li>熟练 写出 select server代码</li>
<li>能够描述IO多路复用的执行原理和内部机制</li>
<li>巩固HTTPserver的代码—》理解HTTP服务器执行流程</li>
</ol>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>使用方法 ： 代码基本与poll相同</p>
<ul>
<li>将生成对象的 poll() 函数 变为 epoll()</li>
<li>将register注册IO事件时 关注的事件类别改为epoll类别</li>
</ul>
<p>区别：<br>epoll 效率要高于 poll和select<br>epoll 的关注触发方式多一些</p>
<h2 id="本地套接字"><a href="#本地套接字" class="headerlink" title="本地套接字"></a>本地套接字</h2><p>linux下文件类型：<br>b（块设备文件） c（字符设备文件）   d（目录）<br>-（普通文件） l（链接文件） s（套接字文件） p（管道文件）</p>
<p>作用 ： 用于本地不同的程序间进行通信</p>
<p>本地套接字创建流程：</p>
<ul>
<li>创建套接字对象<br>sockfd = socket（AF_UNIX,SOCK_STREAM）</li>
<li>建立套接字文件<br>sockfd.bind(path) 绑定一个文件</li>
<li>监听</li>
<li>接收发送消息</li>
</ul>
<p>*小贴士<br>os.path.exists(path)<br>功能： 判断一个文件是否存在<br>参数： 文件位置<br>返回值： 存在返回True  否则返回False</p>
<p>os.unlink()   os.remove()<br>功能：删除一个文件<br>参数：要删除的文件</p>
<p>In [2]: os.path.exists(“./re”)<br>Out[2]: True</p>
<p>In [3]: os.unlink(“./re”)*</p>
<h1 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h1><p>意义 ： 充分的利用计算机资源提高程序的运行效率</p>
<p>定义 ： 通过应用程序利用计算机的多个核心达到同时执行多个任务的目的，以此来提升程序的执行效率</p>
<p>实施方案 ： 多进程    多线程</p>
<p>并行： 多个计算机核心在同时处理多个任务，这多个任务间是并行关系</p>
<p>并发：同时处理多个任务，内核在任务间不断的切换，达到好像都在处理运行的效果</p>
<p>进程：程序在计算机中的一次执行过程 </p>
<p>程序 ： 是一个可执行文件，是静态的，占有磁盘，不占计算机的运行资源<br>进程 ： 进程是一个动态的过程描述，占有计算机的资源，有一定的生命周期</p>
<ul>
<li>同一个程序的不同运行过程是不同的进程。因为分配的计算机资源不同，生命周期也不同</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的创建流程"><a href="#进程的创建流程" class="headerlink" title="进程的创建流程"></a>进程的创建流程</h3><ul>
<li>1.用户空间运行一个程序，发起进程的创建</li>
<li>2.操作系统接受用户申请开启进行创建</li>
<li>3.操作系统分配计算机资源，确定进程状态</li>
<li>4.将新创建的进程交给用户使用</li>
</ul>
<p><strong>cpu时间片</strong><br>如果一个进程占有计算机核心，我们称为该进程占有cpu时间片。多个任务实际会对cpu内核进行争夺，由操作系统分配cpu资源</p>
<p>进程信息<br><strong>PCB（进程控制块）</strong>：在*nix操作系统中，进程创建后会自动在内存中产生一个空间存放进程信息，称为PCB</p>
<p>进程信息：进程的ID 进程占有内存位置 创建时间  创建用户..</p>
<p><strong>查看命令：ps  -aux</strong></p>
<p><strong>PID</strong>(process ID) : 在操作系统中进程的唯一标志，大于0的整数，由系统自动分配</p>
<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3><ul>
<li>进程是操作系统分配计算机资源的最小单位</li>
<li>每个进程有自己单独的虚拟内存空间</li>
<li>进程之间的执行上相互独立，互不影响</li>
</ul>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>  <strong>三态</strong></p>
<pre><code>* 就绪态：进程具备执行条件，等待系统分配处理器资源
* 运行态：进程占有cpu处于运行的状态
* 等待态：进程暂时不具备运行条件，需要阻塞等待
</code></pre><p>  <strong>五态</strong> （在三态基础上增加新建态和终止态）</p>
<pre><code>* 新建态 ：创建一个新的进程，获取资源的过程
* 终止态 ：进程执行结束，资源释放回收的过程
</code></pre><p>ps -aux  —-&gt; STAT 表示进程状态</p>
<pre><code>D  等待态  （不可终端等待）
S  等待态   （可终端等待）
T  等待态   （暂停状态）
R  运行态   （包含就绪态）
Z  僵尸态  

\+  前台进程 在终端运行
&lt;  高优先级
N  低优先级
l  有进程链接
s  会话组
</code></pre><h3 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h3><p>优先级决定了一个进程的执行权限和占有资源的优先程度</p>
<p><strong>查看优先级</strong> ：<br>    top ： 动态查看进程优先级    摁 &lt;  &gt; 翻页</p>
<p><strong>优先级取值范围</strong>  -20 — 19   -20最高</p>
<pre><code>nice ： 以指定的优先级运行一个程序
    e.g.  nice  -9   ./while.py
          nice  --9  ./while.py   -9的优先级运行
</code></pre><h3 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h3><p>在系统中除了初始化进程每个进程都有一个父进程，可能有0个或者多个子进程。由此形成进程的父子关系。我们认为每个进程都是父进程创造的。</p>
<p>查看进程树 : pstree<br>查看父进程PID ： ps  -ajx</p>
<p>思考 ：<br>什么是进程，进程和程序的区别<br>了解进程的特征<br>清楚进程每种状态，及状态转换</p>
<p>需求 ： 编写一个程序能够同时做多件任务</p>
<p>方案 ： 写一个程序，根据需要在程序内不可以创建多个进程完成任务</p>
<p><strong>使用os.fork()方法实现</strong></p>
<p>import os </p>
<p>pid = os.fork()<br>功能 ： 创建一个新的进程<br>参数 ： 无<br>返回值 ：<br>失败返回一个负数   -1<br>成功 ： 在原有进程中返回新进程的PID号，在新进程中返回0</p>
<ul>
<li>子进程会复制父进程全部代码段，包括fork之前产生的内存空间</li>
<li>子进程从fork的下一句开始执行</li>
<li>父子进程通常会根据fork返回值的差异选择执行不同的代码</li>
<li>子进程虽然复制父进程的代码空间，但是有自己的特有属性 比如 PID号 PCB等</li>
<li>父子进程在执行上互补干扰，执行顺序不确定</li>
<li>父子进程空间独立，在本进程中对空间的操作不会影响到其他进程</li>
<li><strong>os.fork函数不能在Windows操作系统上面运行</strong></li>
</ul>
<p>进程相关函数使用</p>
<p>获取进程号<br>os.getpid()<br>功能 ：获取当前进程的进程号<br>返回值 ： 返回进程号</p>
<p>os.getppid()<br>功能：获取父进程的进程号<br>返回值 ： 返回进程号</p>
<p>进程的退出<br>os._exit(status)<br>功能 ： 退出进程<br>参数 ： 进程的退出状态 整数</p>
<p>sys.exit([status])<br>功能： 退出进程<br>参数： 不写默认为0<br>       传入一个整数表示退出状态<br>             传入一个字符串，则在进程退出时会打印该字符串</p>
<ul>
<li>sys.exit 可以通过捕获 SystemExit 异常阻止其退出</li>
</ul>
<p>代码示例：<br>    “””１，创建套接字<br>            ２，绑定<br>            ３，监听<br>            ４，接收客户端请求accept<br>            ５，创建子进程处理客户端请求，父进程继续接收其他客户端连接<br>            ６，客户端退出则子进程结束”””</p>
<pre><code>import socket
import os
import sys
import signal

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
s.bind((&quot;127.0.0.1&quot;,9527))
s.listen(100)

def client_handler(c):
    print(&quot;asfagg&quot;)
    print(&quot;cpid deal with client&quot;,c.getpeername())
    while True:
        data = c.recv(1024).decode()
        if not data:
            break
        print(data)
        c.send(b&quot;receive your msg&quot;)


signal.signal(signal.SIGCHLD,signal.SIG_IGN)
while True:
    try:
        conn,addr = s.accept()
    except KeyboardInterrupt:
        s.close()
        sys.exit(&quot;exit&quot;)
    except Exception as e:
        print(e)
        continue
    pid = os.fork()
    if pid &lt; 0:
        print(&quot;create failed&quot;)
    elif pid == 0:     
        s.close()#子进程不需要监听套接字
        print(os.getpid(),&quot;hello&quot;)
        client_handler(conn)
        # data = conn.recv(1024)
        # print(data.decode())
        #子进程处理完客户端请求一定要退出
        conn.close()
        sys.exit(0)
    else:
        conn.close() #关闭冗余的套接字
</code></pre><p>作业 ： </p>
<p>写一个聊天室</p>
<p>功能 ： 类似QQ群聊</p>
<ol>
<li>进入聊天室前需要输入用户名</li>
<li>有人进入聊天室会向其他用户发起通知<br>xxx  进入了聊天室</li>
<li>一个人发消息，其他人都能收到<br>xxx 说：xxxxxxxx</li>
<li>某个人退出聊天室 其他人也会收到通知<br>xxx 退出了聊天室</li>
</ol>
<p>思考 服务端    客户端</p>
<ul>
<li>使用什么技术</li>
<li>每个功能的实现方案</li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程先于子进程退出，此时子进程就会成为孤儿进程。</p>
<ul>
<li>孤儿进程会被系统指定的进程收养，即系统进程会成为孤儿进程新的父进程。当孤儿进程退出时“继父”，会处理孤儿进程退出状态，使其不会成为僵尸。</li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>子进程先于父进程退出，父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程 </p>
<ul>
<li>僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统资源，应该尽量避免僵尸进程的产生</li>
</ul>
<p><strong>如何避免僵尸进程</strong></p>
<ul>
<li>父进程先退出（不佳，因为不好控制）</li>
<li>父进程处理子进程的退出状态</li>
</ul>
<p>pid,status = <strong>os.wait()</strong><br>功能： 在父进程中阻塞等待子进程的退出<br>返回值 ：<br>一个两个元素的元组<br>pid : 退出的子进程的PID号<br>status ： 退出的子进程的退出状态</p>
<p>pid,status = <strong>os.waitpid(pid，option) </strong><br>功能 ： 处理子进程的退出状态<br>参数 ：<br>pid  -1 表示等待任意子进程退出</p>
<blockquote>
<p>0 整数 表示等待对应PID号的子进程退出<br>option ：  0 表示阻塞等待  WNOHONG  表示非阻塞<br>返回值  ： 同wait()</p>
</blockquote>
<p>waitpid（-1,0） ====  wait()</p>
<p><strong>创建二级子进程</strong></p>
<ul>
<li>父进程创建子进程等待子进程的退出</li>
<li>子进程创建二级子进程后马上退出</li>
<li>二级子进程成为孤儿，处理具体事件</li>
</ul>
<h3 id="聊天室项目"><a href="#聊天室项目" class="headerlink" title="聊天室项目"></a>聊天室项目</h3><p>功能 ： 类似QQ群聊</p>
<ol>
<li>进入聊天室前需要输入用户名</li>
<li>有人进入聊天室会向其他用户发起通知<br>xxx  进入了聊天室</li>
<li>一个人发消息，其他人都能收到<br>xxx 说：xxxxxxxx</li>
<li>某个人退出聊天室 其他人也会收到通知<br>xxx 退出了聊天室</li>
<li>管理员喊话功能 ：管理员发言所有客户端都能收到<br>管理员 说：xxxxxxx </li>
</ol>
<p>需要什么技术：</p>
<p>socket 通信</p>
<p>存储用户 ： 字典或列表 姓名 和 地址</p>
<p>用什么类型套接字 ： udp套接字</p>
<p>怎么发消息：</p>
<ul>
<li>转发  即客户端发给服务器然后服务器在发送给其他人</li>
<li>在客户端让发送和接收需要相互独立，各使用一个进程</li>
<li>服务端，管理员喊话和请求的接收需要独立，各使用一个进程</li>
</ul>
<p>注意点</p>
<ol>
<li>功能封装  将每个功能模块化</li>
<li>测试，每个功能进行测试</li>
</ol>
<p>代码编写流程</p>
<p>搭建网络连接—-&gt;多进程的创建—&gt;每个进程功能的编写—&gt;项目功能的诸个编写</p>
<p>客户端可能发送的请求</p>
<p>进入聊天室：  “L name”<br>服务端 ： 识别请求  判定是否可以进入<br>  回复客户端  保留用户<br>  告知其他人谁进入</p>
<p>聊天请求 ： “C name message”<br>服务端 ： 识别请求  转发给其他人</p>
<p>退出聊天室： “Q name”<br>服务端 ： 识别请求  告知其他人谁退出<br>   将其从用户中删除</p>
<p><strong> 这里只是写的一种最容易理解的编码方式，在udp协议中是需要在应用层进行加密处理，这里的加密处理明显不够，而且空格并不是很好的分割符，比如人名为Jason smith，发送了一条消息’hello’，在服务器会转发为’jason’说’smith hello’，而本身应该表示’jason smith’说’hello’，但是这里暂且先不处理，简化一下发送格式 </strong></p>
<h2 id="multiprocessing-模块创建进程"><a href="#multiprocessing-模块创建进程" class="headerlink" title="multiprocessing 模块创建进程"></a>multiprocessing 模块创建进程</h2><ul>
<li>1.需要将要做的事件进行封装成函数</li>
<li>2.使用multiprocessing提供的类Process创建进程对象</li>
<li>3.通过对象和Process的初始化函数对进程进行设置以    及绑定要执行的事件</li>
<li>4.启动进程，会自动的执行函数代表的事件</li>
<li>5.完成进程的回收</li>
</ul>
<h3 id="创建进程对象"><a href="#创建进程对象" class="headerlink" title="创建进程对象"></a>创建进程对象</h3><p>Process()<br>功能：创建进程对象<br>参数：name ： 给创建的进程对象起一个名字<br>              默认为Process-1<br>            target :  绑定的函数<br>            args ：元组 用来给 target函数传参按位置传参<br>      kwargs ： 字典  按照键值传参</p>
<p>p.start()<br>功能：启动进程 进程被创建，自动运行对应函数</p>
<p>p.join([timeout])<br>功能 ： 阻塞等待对应子进程的退出，回收子进程<br>参数 ： 超时时间</p>
<ul>
<li>如果不使用join 则子进程会成为僵尸进程</li>
<li>在使用multiprocessing创建进程中，一般父进程功能   就是创建子进程等待回收，不做过多其他事情</li>
<li>使用multiprocessing创建子进程，同样子进程复制父   进程空间，之后有自己独立的执行空间，互不干扰</li>
</ul>
<p>作业： 1. 将聊天室代码进行梳理</p>
<pre><code>  2.  复习fork创建进程的内容进行整理
3. multiprocessing 函数巩固
</code></pre><h3 id="进程对象属性"><a href="#进程对象属性" class="headerlink" title="进程对象属性"></a>进程对象属性</h3><p>p.join()  回收进程<br>p.start() 启动进程<br>p.is_alive()  判断进程是否在生命周期状态，在生命周期中返回True 否则返回False</p>
<p>p.name  进程名称 默认为Process-1 如果起名字则为自己取的名称</p>
<p>p.pid   进程的PID号</p>
<p>代码示例</p>
<pre><code>import multiprocessing as mp
import time

def worker(a,b,c,name):
    for i in range(3):
        # time.sleep(sec)
        print(a,b,c)
        print(&quot;I&apos;m &quot;,name)
        print(&quot;I&apos;m working ...&quot;)

p = mp.Process(&apos;k&apos;,worker,(2,3,4),{&quot;name&quot;:&quot;Jason&quot;})
p.start()
p.join(4)
print(&quot;after join&quot;)
</code></pre><p><strong>p.daemon</strong><br>默认为False  主进程退出不会影响子进程<br><strong>如果设置为 True 则主进程退出时会让所有子进程都退出</strong></p>
<p><strong> * 该属性的设置必须在start() 前</strong><br><strong> * 该属性一般不用和join同时出现</strong></p>
<h3 id="创建自定义进程类"><a href="#创建自定义进程类" class="headerlink" title="创建自定义进程类"></a>创建自定义进程类</h3><ul>
<li>1.继承Process类</li>
<li>2.运行Process类的<strong>init</strong> 以获取父类属性</li>
<li>3.<strong>重写run方法</strong>，在通过自定类生成对象后，调用start()会自动执行这个方法</li>
</ul>
<p>代码示例：</p>
<pre><code>import multiprocessing as mp
import time

class myProcess(mp.Process):
    def __init__(self,value):
        super().__init__()
        self.value = value

    #重写父类的run方法
    def run(self):
        print(time.ctime())
        time.sleep(self.value)
        print(time.ctime())

    def start(self):
        pass


myP = myProcess(2)
print(&quot;========&quot;)
#在启动的时候才会启动run方法，本质是在Process的start中调用的run 方法
myP.start()
time.sleep(1)
print(&quot;-------------&quot;)
&quot;&quot;&quot;
Tue Jun 12 10:15:55 2018
Tue Jun 12 10:15:57 2018
&quot;&quot;&quot;
</code></pre><h3 id="多进程优缺点"><a href="#多进程优缺点" class="headerlink" title="多进程优缺点"></a>多进程优缺点</h3><p><strong>优点 ： </strong><br>并行执行多个任务，提高效率<br>创建方便<br>运行独立，不受其他进程影响<br>数据安全<br><strong>缺点 ：</strong>在进程的创建和删除过程中消耗计算机资源较多</p>
<h3 id="进程池技术"><a href="#进程池技术" class="headerlink" title="进程池技术"></a>进程池技术</h3><p>产生原因 ：如果有大量的任务需要多进程完成，则可能需要频繁的创建和删除进程，给计算机带来较多的消耗。</p>
<p><strong>使用 ：大量可以短时间完成的任务需要多进程操作的时候比较适用于进程池</strong></p>
<p>使用方法：</p>
<ul>
<li><ol>
<li>创建进程池，在池内放入适当的进程</li>
</ol>
</li>
<li><ol start="2">
<li>将事件加入进程池队列</li>
</ol>
</li>
<li><ol start="3">
<li>事件不断运行，所有事件运行完成</li>
</ol>
</li>
<li><ol start="4">
<li>关闭进程池，回收进程</li>
</ol>
</li>
</ul>
<p>from multiprocessing import Pool </p>
<p>Pool(processes)<br>功能 ： 创建进程池对象<br>参数 ： processes  表示进程池中有多少进程<br>对象 ： 进程池对象</p>
<p>pool.apply_async(func,args,kwds)<br>功能 ： 将事件放入进程池等待执行<br>参数 ：<br>func   要放入进程池的事件函数<br>args   给func函数以元组传参<br>kwds   给func函数以字典传参<br>返回值 ：<br>返回一个事件对象<br>通过get()方法可以获取事件函数的返回值</p>
<p>pool.apply(func,args,kwds)<br>功能 ： 将事件放入进程池等待执行<br>参数 ：<br>func   要放入进程池的事件函数<br>args   给func函数以元组传参<br>kwds   给func函数以字典传参</p>
<p>pool.close()<br>功能 ： 关闭进程池 不能再添加新的事件</p>
<p>pool.join()<br>功能 ： 回收进程池</p>
<p>代码示例：</p>
<pre><code>from multiprocessing import Pool
import time

def fun(msg):
    time.sleep(2)
    print(&quot;msg is &quot;,msg)
    return time.ctime()

pool = Pool(processes = 5)
result = []
for i in range(5):
    msg = i
    # r = pool.apply_async(fun,args = (msg,))
    pool.apply(fun,args = (msg,))
    # result.append(r)

pool.close()

pool.join()
# for i in result:
#     print(i.get())
</code></pre><p><strong>这里的apply_async 和 apply的区别在于apply是阻塞的，所以进入子进程执行后，等待当前子进程执行完毕，在继续执行下一个进程。<br>apply_async 是异步非阻塞的，不用等待当前进程执行完毕，随时根据系统调度来进行进程切换</strong></p>
<p>pool.map(func,iter)<br>功能 ： 将要完成的事件放入到进程池<br>参数 ： func 要完成的事件函数，iter 要给func传递的参数的迭代器<br>返回值 ： 返回事件函数的返回值列表</p>
<p>练习 ： 使用multiprocessing 创建两个进程，分别复制一个文件的上半部分和下半部分到另外一个新的文件中<br><em>小贴士 :  os.path.getsize(path) 获取文件大小</em></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程间由于空间独立，资源互相无法直接获取，此时在不同的进程间传递数据就需要专门的进程间通信方法。</p>
<p>和磁盘交互 ： 使用中间文件 但是不安全，速度慢</p>
<p><strong>进程间通信方法 （IPC）</strong><br>管道   消息队列  共享内存   信号  信号量  套接字</p>
<h3 id="管道通信-Pipe"><a href="#管道通信-Pipe" class="headerlink" title="管道通信 Pipe"></a>管道通信 Pipe</h3><p>在内存中开辟一块空间，形成管道结构，管道对多个进程可见，进程可以通过对管道的读写操作进行通信</p>
<p>multiprocessing —》 Pipe </p>
<p>fd1,fd2 = Pipe(duplex = True)<br>功能 ： 创建一个管道<br>参数 ： 默认表示管道为双向管道<br>        如果设置为False 则表示单向管道<br>返回值 : 返回两个管道流对象，表示管道两端<br>         如果是双向管道，则都可以读写<br>                 如果是单向管道，则fd1只读  fd2只写</p>
<p>fd1.recv()<br>功能 ： 从管道内读信息<br>返回值：读到的内容</p>
<ul>
<li>当管道内无内容时会阻塞</li>
</ul>
<p>fd2.send(data)<br>功能 ： 向管道写入内容<br>参数 ： 要写的内容</p>
<ul>
<li>可以发送几乎Python的任意数据类型</li>
</ul>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Pipe
import os,time

fd1,fd2 = Pipe(duplex=False)
ps = [] 

def fun(msg):
    time.sleep(2)
    print(&quot;msg is&quot;,msg)
    fd2.send(str(msg))

# ps = []
for i in range(5):
    p = Process(target=fun,args=(i,))
    p.start()
    ps.append(p)

for i in range(5):
    data = fd1.recv()
    print(&quot;data is &quot;,data)

for p in ps:
    p.join()
</code></pre><p>运行结果：</p>
<pre><code>msg is 0
data is  0
msg is 1
data is  1
msg is 2
data is  2
msg is 3
data is  3
msg is 4
data is  4
</code></pre><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>队列 ： 先进先出<br>在内存中开辟队列结构空间，对多个进程可见。多个进程向队列中存入消息，取出消息，完成进程间通信。</p>
<p>创建队列<br>q = Queue(maxsize = 0)<br>功能 ： 创建队列<br>参数 ： maxsize 默认表示根据系统分配空间存储消息<br>        如果传入一个正整数则表示最多存入消息数量<br>返回值 ： 队列对象</p>
<p>q.put(data,[block,timeout])<br>功能 ： 向队列中存入消息<br>参数 ： data  存入的数据 （支持Python数据类型）<br>        block  默认为True表示 当队列满时阻塞<br>                       设置为False 表示非阻塞<br>                timeout  当block为Ture时表示超时时间</p>
<p>data = q.get([block,timeout])<br>功能 ： 从队列获取消息<br>参数 ： block  默认为True表示 当队列空时阻塞<br>                       设置为False 表示非阻塞<br>                timeout  当block为Ture时表示超时时间<br>返回值：返回获取到的消息</p>
<p>q.full()  判断队列是否为满<br>q.empty() 判断队列是否为空<br>q.qsize() 获取队列中消息数量<br>q.close() 关闭队列</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Queue
q = Queue()

def fun1():
    for x in range(10):
        q.put(x)
    q.put(&quot;fasfgsd&quot;)
    pass

def fun2():
    data = q.get()
    while True:
        if data is not None:
            print(data)
            data = q.get()
        else:
            break
        pass

def fun3():
    while q.qsize():
        try:
            data = q.get()
            print(&apos;queue data: &apos;,data)
        except Queue.Empty:
            pass
        except :
            pass
p1 = Process(target=fun1)
p2 = Process(target=fun3)
p1.start()
p2.start()
p1.join()
p2.join()
</code></pre><p>运行结果：<br>        queue data:  0<br>        queue data:  1<br>        queue data:  2<br>        queue data:  3<br>        queue data:  4<br>        queue data:  5<br>        queue data:  6<br>        queue data:  7<br>        queue data:  8<br>        queue data:  9<br>        queue data:  fasfgsd</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>在内存中开辟一段空间，存储数据，对多个进程可见。每次写入共享内存的数据会覆盖之前的内容</p>
<p>from multiprocessing import  Value，Array</p>
<p>obj = Value(ctype,obj)<br>功能 ： 开辟共享内存空间<br>参数 ： ctype  字符串 要转变的c的类型code（对照ctype表）<br>        obj  共享内存初始值<br>返回共享内存对象</p>
<p>obj.value  表示共享内存中的值。对其修改或者使用即为使用共享内存中的值</p>
<p>obj = Array(ctype,obj)<br>功能 ： 开辟共享内存空间<br>参数 ：<br>ctype  要转换的类型<br>obj 要存入共享内存的数据<br>列表  将列表存入共享内存 要求类型一致<br>整数  在共享内存中开辟几个单元的空间<br>返回值：共享内存对象</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Array
import time

# shm = Array(&apos;i&apos;,[1,2,3,4,5,6])
#这里的i 指的是整型数据，C语言中整型数据默认值为0
shm = Array(&apos;i&apos;,6)

def fun1():
    for i in shm:
        print(i)
    shm[3] = 1000

def fun2():
    for i in shm:
        print(i)

p = Process(target= fun1)
p2 = Process(target= fun2)
p.start()

p.join()
p2.start()
p2.join()
</code></pre><p>运行结果：在fun1中修改的内容，func取出来是修改过的，通信成功<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        0<br>        1000<br>        0<br>        0</p>
<table>
<thead>
<tr>
<th></th>
<th>管道</th>
<th>消息队列</th>
<th>共享内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>开辟空间</td>
<td>内存</td>
<td>内存</td>
<td>内存</td>
</tr>
<tr>
<td>读写方式</td>
<td>两端读写（双向/单向）</td>
<td>先进先出</td>
<td>操作覆盖内存            </td>
</tr>
<tr>
<td>效率</td>
<td>一般</td>
<td>一般</td>
<td>较快</td>
</tr>
<tr>
<td>应用</td>
<td>多用于父子进程</td>
<td>广泛灵活</td>
<td>复杂<br>需要互斥机制</td>
</tr>
</tbody>
</table>
<p>作业 ：<br>熟练掌握进程间通信方法<br>自己实现进程池的使用，知道进程池特性</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>一个进程向另一个进程通过信号传递某种讯息。接收方在接受到信号时进行相应的处理</p>
<p>kill  -l   查看信号<br>kill  -signame  PID   给PID的进程发送一个信号 </p>
<p>关于信号 </p>
<p>信号名称 ： 系统定义，  名字或者数字<br>信号含义 ： 系统定义，  信号的作用<br>默认处理方法：当一个进程接收到信号时默认产生的效果<br>               终止进程   暂停进程   忽略<br>e.g.<br>SIGHUP   连接断开<br>SIGINT   CTRL + C<br>SIGQUIT  CTRL + \<br>SIGTSTP  CTRL + Z<br>SIGKILL  终止进程且不能被处理<br>SIGSTOP  暂停进程且不能被处理<br>SIGALRM  时钟信号<br>SIGCHLD  子进程状态改变给父进程发送</p>
<p>Python进行信号处理</p>
<p>os.kill(pid,sig)<br>功能 ： 发送信号给某个进程<br>参数 ： pid   给哪个进程发送信号<br>        sig   要发送什么信号</p>
<p>signal.alarm(sec)<br>功能 ： 一定时间后向自身发送 一个SIGALRM信号<br>参数 ： 定时时间</p>
<ul>
<li>在一个进程中只允许有一个时钟，设置第二个的时候时   间就会重置</li>
</ul>
<p>程序执行的异步和同步</p>
<p>同步：按照步骤一步一步往下顺序执行<br>异步：在程序执行中利用内核，不想应用层的持续执行</p>
<ul>
<li>信号是唯一的异步通信方式</li>
</ul>
<p>signal.pause()<br>功能 ： 阻塞等待进程收到一个信号</p>
<p>signal.signal(signum，handler)<br>功能 ： 处理信号<br>参数 ： signum  ： 要处理的信号<br>handler ： 信号的处理方法<br><strong>可选值 ：<br>SIG_DFL  表示使用默认方法处理<br>SIG_IGN  表示忽略这个信号<br>func     自定义函数</strong></p>
<p>自定义函数格式：<br>def func(sig,frame)<br>sig：接收到的信号<br>frame：信号结构对象</p>
<ul>
<li>signal函数是一个异步处理函数</li>
<li>signal函数不能处理SIGKILL，SIGSTOP信号</li>
<li>在父进程中加上signal(SIGCHLD,SIG_IGN)，当子进程退   出时会自动交由系统处理</li>
</ul>
<p>示例代码：<br>        from signal import *<br>        import time<br>        import os</p>
<pre><code>#信号处理函数
def handler(sig,frame):
    if sig == SIGALRM:
        print(&quot;接收到时钟信号&quot;)
        exit()
    elif sig == SIGINT:
        print(&quot;就不结束&quot;)

alarm(5)

#当接收到SIGALRM信号 用handler函数处理
signal(SIGALRM,handler)
signal(SIGINT,handler)

while True:
    print(&quot;Waiting for a signal&quot;)
    time.sleep(2)
</code></pre><p>运行结果：<br>        Waiting for a signal<br>        ^C就不结束<br>        Waiting for a signal<br>        ^C就不结束<br>        ^C就不结束<br>        Waiting for a signal<br>        接收到时钟信号</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>给定一定的数量，对多个进程可见，并且多个进程根据信号的数量多少确定不同的行为</p>
<p>multiprocessing —》 Semaphore() </p>
<p>sem = Semaphore(num)<br>功能 ： 生成信号量对象<br>参数 ： 信号量的初始值<br>返回值 ： 信号量对象</p>
<p>sem.acquire()  将信号量数量减一  信号量为0会阻塞<br>sem.release()  将信号量数量加一<br>sem.get_value() 获取当前信号量的值</p>
<p>示例代码：</p>
<pre><code>import multiprocessing as mp
import time
import os
sem = mp.Semaphore(3)

def fun():
    print(&quot;process %d wait semaphore&quot;%os.getpid())
    sem.acquire()
    print(&quot;process %d use semaphore&quot;%os.getpid())
    time.sleep(1)
    sem.release()
    print(&quot;process %d add semaphore&quot;%os.getpid())

jobs = []
for i in range(4):
    p = mp.Process(target=fun)
    jobs.append(p)
    p.start()
for i in jobs:
    i.join()
</code></pre><p>运行结果：</p>
<pre><code>process 8441 wait semaphore
process 8441 use semaphore
process 8442 wait semaphore
process 8442 use semaphore
process 8443 wait semaphore
process 8443 use semaphore
process 8444 wait semaphore
process 8441 add semaphore
process 8444 use semaphore
process 8442 add semaphore
process 8443 add semaphore
process 8444 add semaphore
</code></pre><h2 id="同步互斥机制"><a href="#同步互斥机制" class="headerlink" title="同步互斥机制"></a>同步互斥机制</h2><p>目的 ： 解决对共有资源操作产生的争夺</p>
<p>临界资源 ： 多个进程或者线程都能够操作的资源<br>临界区   ： 操作临界资源的代码段</p>
<p>同步 ： 同步是一种合作关系，为完成某个任务多进程或者多线程之间形成一种协调，按照约定或条件一次执行操作临界资源，相互告知资源使用         情况。</p>
<p>互斥 ： 互斥是一种制约关系，当一个进程或者线程进入临界区会进行加锁的操作。此时其他进程（线程）再企图使用临界资源时就会阻塞，直到         资源被释放才能使用</p>
<h3 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event  事件"></a>Event  事件</h3><p>multiprocessing Event<br>创建事件对象<br>e = Event()</p>
<p>事件阻塞<br>e.wait([timeout])</p>
<p>事件设置  e处于设置状态，e.wait()不再阻塞<br>e.set()</p>
<p>事件清除  e处于未设置状态，e.wait()阻塞<br>e.clear() </p>
<p>事件判断  判断e的当前状态<br>e.is_set()</p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Event
import time

e = Event()
def wait_event():
    print(&quot;waiting for event set&quot;)
    e.wait()
    print(&quot;it&apos;s my turn&quot;,e.is_set())

def wait_event_timeout():
    print(&quot;I just wait for 2s &quot;)
    e.wait(2)
    print(&quot;after 2s,it&apos;s my turn&quot;)

p1 = Process(target = wait_event)
p2 = Process(target = wait_event_timeout)

p1.start()
p2.start()

print(&quot;main process is operating resource&quot;)
time.sleep(3)
e.set()
print(&quot;open resoure&quot;)

p1.join()
p2.join()
</code></pre><p>运行结果：</p>
<pre><code>main process is operating resource
waiting for event set
I just wait for 2s 
after 2s,it&apos;s my turn
open resoure
it&apos;s my turn True
</code></pre><h3 id="锁-Lock"><a href="#锁-Lock" class="headerlink" title="锁  Lock"></a>锁  Lock</h3><p>multiprocessing —&gt; Lock</p>
<p>创建对象<br>lock = Lock()</p>
<p>lock.acquire()  上锁<br>lock.release()  解锁</p>
<p>上锁状态 ： 此时执行acquire（）操作会阻塞<br>解锁状态 ： 执行acquire（）操作为非阻塞</p>
<p>with  lock：  —-》 上锁<br>….<br>….<br>—-&gt; with代码段结束后自动解锁 </p>
<p>示例代码：</p>
<pre><code>from multiprocessing import Process,Lock 
import sys 
from time import sleep 

#sys.stdout标准输出流作为所有进程的临界资源

def writer1():
    lock.acquire()  #上锁
    for i in range(5):
        sleep(1)
        sys.stdout.write(&quot;writer1输出\n&quot;)
    lock.release()  #解锁

def writer2():
    #with方式上锁
    with lock:
        for i in range(5):
            sleep(1)
            sys.stdout.write(&quot;writer2输出\n&quot;)

#创建锁
lock = Lock()

w1 = Process(target = writer1)
w2 = Process(target = writer2)

w1.start()
w2.start()

w1.join()
w2.join()
</code></pre><p>运行结果：</p>
<pre><code>writer1输出
writer1输出
writer1输出
writer1输出
writer1输出
writer2输出
writer2输出
writer2输出
writer2输出
writer2输出
</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>这里不得不说死锁的概念<br>出自： <a href="https://www.cnblogs.com/Simon-xm/p/4072986.html" target="_blank" rel="noopener">https://www.cnblogs.com/Simon-xm/p/4072986.html</a><br>Python——网络编程，如何避免死锁？<br>问题描述：什么是死锁？</p>
<p>死锁发生在当一个服务器和客户端同时试图往一个连接上写东西或同时从一个连接上读的时候。在这种情况下，没有进程可以得到任何数据（如果它们都正在读），因此，如果它们正在写，向外的buffer会被充满，结果他们就好象被骗了，什么都做不了。</p>
<p>示例服务器代码：</p>
<pre><code>import socket,traceback

host=&quot;&quot;
port=51423

sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
sock.bind((host,port))
sock.listen(1)

while True:
    try:
        clientsock,clientaddr= sock.accept()
    except KeyboardInterrupt:
        raise
    except:
        traceback.print_exc()
        continue

    try:
        print(&quot;Got connection from &quot;,clientsock.getpeername)
        while True:
            data = clientsock.recv(4096)
            if not len(data):
                break
            clientsock.sendall(data)
    except (KeyboardInterrupt,SystemExit):
            raise
    except:
            traceback.print_exc()

    try:
        clientsock.close()
    except KeyboardInterrupt:
        raise
    except:
        traceback.print_exc()
</code></pre><p>示例客户端代码：</p>
<pre><code>import socket
import sys

port=51423
host=&quot;localhost&quot;

data=b&quot;x&quot;*10485760
sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
sock.connect((host,port))

byteswritten=0
while byteswritten&lt;len(data):
    startpos = byteswritten
    endpos = min(byteswritten+1024,len(data))
    byteswritten+=sock.send(data[startpos:endpos])
    sys.stdout.write(&quot;wrote %d bytes\r&quot;% byteswritten)
    sys.stdout.flush()

sock.shutdown(1)

print(&quot;All data sent.&quot;)
while True:
    buf = sock.recv(1024).decode()
    if not len(buf):
        break
    sys.stdout.write(buf)
</code></pre><p>在运行上述服务器代码的情况下运行客户端代码，得到如下结果：</p>
<p>服务器：<br>(ev1)[root@Simonxu bin]# python testserver.py<br>Got connection from  <built-in method="" getpeername="" of="" socket="" object="" at="" 0x7f5e18d2b460=""><br>客户端：<br>(ev1)[root@Simonxu bin]# python test.py<br>wrote 164864 bytes<br>可以看出，上述服务器和客户端卡在的wrote 164864 bytes。</built-in></p>
<p><strong>分析：</strong></p>
<p>已知客户端程序试图发送一个10MB的数据，每次传输1KB，同时显示发送数据动态，并在所有数据发送完成后，从服务器每次1KB读取并写数据。</p>
<p>而服务器在建立套接口连接后，从客户端每次读取4KB数据，在接收到数据后，直接把数据发回客户端。</p>
<p>而矛盾的是，由于客户端在发送一个10MB大小的数据，这要发送较长时间，在发送的过程中没有办法读取数据，因此服务器返回的数据就堆积在客户端的接收缓冲区。</p>
<p>当接收缓冲区满了之后，服务器的sendall（）函数发生错误，循环死锁，服务器不再接收客户端发来的数据。客户端也无法继续发送数据。就形成了上面的情况。</p>
<p><strong>如何避免死锁？</strong></p>
<ul>
<li><p>1、可以在客户端每次执行完send（）后，进行一次recv（）以接收服务器发来的数据，避免buffer充满。</p>
</li>
<li><p>2、可以让客户端发送的数据较少，这样在buffer充满之前就可以从缓冲区读取服务器发回的数据。</p>
</li>
<li><p>3、采用多线程或其他一些方法，使客户端可以同时发送和接收。</p>
</li>
</ul>
<p><strong>知识补充</strong></p>
<p>缓冲区：</p>
<ol>
<li><p>tcp 收发缓冲区默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/ipv4/tcp_rmem<br>　　4096    87380   4161536<br>　　87380  ：tcp接收缓冲区的默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/ipv4/tcp_wmem<br>　　4096    16384   4161536<br>　　16384  ： tcp 发送缓冲区的默认值</p>
</li>
<li><p>tcp 或udp收发缓冲区最大值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/rmem_max<br>　　131071<br>　　131071：tcp 或 udp 接收缓冲区最大可设置值的一半。<br>　　也就是说调用 setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;rcv_size, &amp;optlen);  时rcv_size 如果超过 131071，那么<br>　　getsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;rcv_size, &amp;optlen); 去到的值就等于 131071 * 2 = 262142<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/wmem_max<br>　　131071<br>　　131071：tcp 或 udp 发送缓冲区最大可设置值得一半。<br>　　跟上面同一个道理</p>
</li>
<li><p>udp收发缓冲区默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/rmem_default<br>　　111616：udp接收缓冲区的默认值<br>　　[root@ <a href="http://www.linuxidc.com]#" target="_blank" rel="noopener">www.linuxidc.com]#</a> cat /proc/sys/net/core/wmem_default<br>　　111616<br>　　111616：udp发送缓冲区的默认值</p>
</li>
<li><p>tcp 或udp收发缓冲区最小值<br>　　tcp 或udp接收缓冲区的最小值为 256 bytes，由内核的宏决定；<br>　　tcp 或udp发送缓冲区的最小值为 2048 bytes，由内核的宏决定</p>
</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>什么是线程 </p>
<p>线程也是一种多任务编程方式，可以使用计算机的多核资源。线程被称为轻量级的进程。</p>
<h3 id="线程的特征"><a href="#线程的特征" class="headerlink" title="线程的特征"></a>线程的特征</h3><ul>
<li>线程是计算机多核分配的最小单位</li>
<li>一个进程可以包含多个线程</li>
<li>线程也是一个运行过程，也要消耗计算机资源。多个   线程共享进程的资源和空间</li>
<li>线程也拥有自己特有的资源属性，比如指令集，TID等</li>
<li>线程无论是创建删除还是运行消耗的资源都小于进程</li>
<li>多个线程之间并行执行，执行上互不干扰</li>
</ul>
<h3 id="threading-模块创建线程"><a href="#threading-模块创建线程" class="headerlink" title="threading 模块创建线程"></a>threading 模块创建线程</h3><p>threading.Thread()<br>功能 : 创建线程对象<br>参数 ：name  线程名称  默认为Thread-1<br>       target  线程函数<br>             args   元组  给线程函数位置传参<br>             kwargs 字典  给线程函数键值传参<br>返回 ： 线程对象</p>
<p>t.start()   启动线程<br>t.join([timeout])   回收线程</p>
<p>线程对象的属性<br>t.is_alive() 查看线程的状态<br>t.name  线程名称<br>t.setName()  设置线程名称<br>threading.currentThread()  获取当前线程对象</p>
<p><strong>t.daemon 属性<br>默认情况下主线的结束不会影响到分支线程的执行<br>如果设置为True 则主线程退出分支线程也会退出</strong></p>
<p>设置方法：<br>t.daemon = True<br>t.setDaemon(True)</p>
<p>判断daemon属性:<br>t.isDaemon()</p>
<ul>
<li>线程daemon属性的设置在start前</li>
<li>一般设置daemon后不会再使用join</li>
</ul>
<p>示例代码：</p>
<pre><code>import threading
import time
import os

a = 1
def music():
    # while True:
    global a
    a = 100
    for i in range(3):
        time.sleep(2)
        print(&quot;play music&quot;,os.getpid())

# for i in range(3):
#     time.sleep(2)
#     print(&quot;play game&quot;) 

t = threading.Thread(target = music)
t.start()
for i in range(5):
    time.sleep(2)
    print(&quot;play game&quot;,os.getpid()) 
t.join()

print(a)
</code></pre><p>运行结果:</p>
<pre><code>play game 8687
play music 8687
play game 8687
play music 8687
play game 8687
play music 8687
play game 8687
play game 8687
100
</code></pre><h3 id="创建自己的线程类"><a href="#创建自己的线程类" class="headerlink" title="创建自己的线程类"></a>创建自己的线程类</h3><p>步骤：<br>1.继承 Thread类<br>2.运行Thread类中的<strong>init</strong>方法以获取父类原有属性<br>3.重写run方法</p>
<p>示例代码：</p>
<pre><code>from threading import Thread
from time import ctime,sleep

class Mythread(Thread):
    def __init__(self,name=&quot;HMoon&quot;,target=None,args=(),kwargs={}):
        super().__init__()
        self.name = name
        self.target = target
        self.args = args
        self.kwargs = kwargs

    def fun(self):
        print(&quot;fdsggsdggh&quot;)
        self.target(*self.args)

def aaa(msg):
    print(&quot;aaaaa&quot;)
    print(msg)

t = Mythread(name= &quot;aaa&quot;,target=aaa,args=(&quot;fsaff&quot;,))
t.start()
t.join()
</code></pre><p>运行结果：</p>
<pre><code>fdsggsdggh
aaaaa
fsaff
</code></pre><p>作业 ： </p>
<ol>
<li>复习网络编程</li>
<li>司机和售票员<ul>
<li>创建父子进程 分别表示司机和售票员</li>
<li>当售票员捕捉到SIGINT信号，给司机发送SIGUSER1信   号，此时司机打印“老司机开车了”<br>当售票员捕捉到SIGQUIT信号，给司机发送SIGUSER2信号，此时司机打印：”车速有点快，系好安全带”<br>当司机捕捉到SIGTSTP信号，给售票员发送SIGUSER1,此时售票员打印“到站了请下车”</li>
</ul>
</li>
</ol>
<ul>
<li>到站后，售票员先下车（子进程先退出），然后司机   下车</li>
</ul>
<p>作业代码：<br>        import multiprocessing as mp<br>        from signal import *<br>        import sys,os<br>        import time</p>
<pre><code>def driver_handle(sig,frame):
    if sig == SIGUSR1:
        print(&quot;老司机开车了&quot;)
    elif sig  == SIGUSR2:
        print(&quot;车速有点快，系好安全带&quot;)
    elif sig == SIGTSTP:
        os.kill(p.pid,SIGUSR1)

def saler_handle(sig,frame):
    if sig == SIGINT:
        os.kill(os.getppid(),SIGUSR1)
    elif sig == SIGQUIT:
        os.kill(os.getppid(),SIGUSR2)
    elif sig == SIGUSR1:
        print(&quot;到站了,请下车&quot;)
        sys.exit(&quot;售票员下车&quot;)

def saler():
    signal(SIGINT,saler_handle)
    signal(SIGQUIT,saler_handle)
    signal(SIGUSR1,saler_handle)
    signal(SIGTSTP,SIG_IGN)
    while True:
        time.sleep(3)
        print(&quot;Python带你去远方&quot;)

p = mp.Process(target = saler)
p.start()

signal(SIGUSR1,driver_handle)
signal(SIGUSR2,driver_handle)
signal(SIGTSTP,driver_handle)
signal(SIGINT,SIG_IGN)
signal(SIGQUIT,SIG_IGN)

p.join()
</code></pre><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>  通信方法 : 多个线程共用进程空间，所以进程的全局量对进程内的线程均可见。因此线程间没有特有的通信方式往往使用全局变量通信</p>
<p>  注意事项 ：线程间使用全局变量通信往往需要同步互斥机制做为通信的安全保证</p>
<p>线程的同步互斥</p>
<h3 id="线程event对象"><a href="#线程event对象" class="headerlink" title="线程event对象"></a>线程event对象</h3><p>创建对象 ：<br>  e = threading.Event()<br>  e.wait([timeout])  如果e为设置状态则不会阻塞，未设置则阻塞<br>  e.set()   将e变为设置状态<br>  e.clear() 将e的设置去除</p>
<p>示例代码：</p>
<pre><code>import threading 
from time import sleep 

msg = None 

#创建事件对象
e = threading.Event()

def bar():
    print(&quot;呼叫foo&quot;)
    global msg 
    msg = &quot;天王盖地虎&quot;

def foo():
    print(&quot;等待口令&quot;)
    sleep(2)
    if msg == &quot;天王盖地虎&quot;:
        print(&quot;宝塔镇河妖,自己人,哈哈哈&quot;)
    else:
        print(&quot;口令错误,打死他&quot;)
    e.set()

def fun(): 
    print(&quot;呵呵....内奸出现&quot;)
    sleep(1)
    e.wait()
    global msg
    msg = &quot;小鸡炖蘑菇&quot; 

t1 = threading.Thread(target = bar)
t2 = threading.Thread(target = foo)
t3 = threading.Thread(target = fun)
t1.start()
t2.start()
t3.start()
t1.join()
t2.join()
t3.join()
</code></pre><p>运行结果：</p>
<pre><code>call foo
wait keyword
hehe...内奸出现
宝塔镇河妖，自己人，哈哈哈
</code></pre><h3 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h3><p>  lock = threading.Lock() 创建锁对象<br>  lock.acquire()  上锁<br>  lock.release()  解锁</p>
<pre><code>**在一个进程中对一个线程锁重复上锁则会阻塞
</code></pre><p>示例代码：</p>
<pre><code>import threading as th
import time
a = b = 0

lock = th.Lock()
def value():
    while True:
        lock.acquire()
        if a != b:
            print(&quot;a = %d  b = %d&quot;%(a,b))
        else:
            print(a,b)
        lock.release()

t = th.Thread(target= value)
t.start()

while True:
    lock.acquire()
    a += 1
    b += 1
    lock.release()
t.join()
</code></pre><p>运行结果片段：（需要ctrl+c结束死循环运行）<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937<br>        390937 390937</p>
<h3 id="Python线程的GIL问题-（全局解释器锁）"><a href="#Python线程的GIL问题-（全局解释器锁）" class="headerlink" title="Python线程的GIL问题 （全局解释器锁）"></a>Python线程的GIL问题 （全局解释器锁）</h3><p>python —》 支持多线程 –》同步互斥 –》加锁 —》超级锁，给解释器加锁</p>
<p>后果 ： 一个解释器，同一时刻只能解释一个线程。因此大大降低了Python线程的执行效率</p>
<p><strong>Python 的GIL问题 解决方法</strong></p>
<ul>
<li>尽量使用进程方式并行</li>
<li>不适用c作为解释器，可以采用 c# java</li>
<li>Python线程适用于高延迟的IO操作，网络操作。不适合用cpu密集型程序。线程在遇到IO阻塞时会让出解释器和cpu</li>
</ul>
<p>效率测试 </p>
<p>分别测试 在 IO密集型程序和CPU密集型程序下，多进程，多线程，单进程执行效率</p>
<p>Line cpu: 8.061699390411377<br>Line IO: 5.261598348617554</p>
<p>Thread cpu: 8.920610427856445<br>Thread io: 5.60230565071106</p>
<p>process cpu: 4.07219386100769<br>Process io: 3.383375406265259</p>
<p>测试代码：</p>
<pre><code>import threading as th
import multiprocessing as mp
from time import ctime,sleep,time
&quot;&quot;&quot;
效率测试
分别测试在ＩＯ密集型和ＣＰＵ密集型下，多进程　多线程　单线程执行效率
&quot;&quot;&quot;

def count(x,y):
    # print(time())
    c = 0 
    while c &lt; 7000000:
        c += 1
        x += 1
        y += 1
    # print(time())

def mywrite():
    # print(ctime())
    f = open(&quot;test.txt&quot;,&quot;w&quot;)
    for x in range(1000000):
        f.write(&quot;hehehehehehehe&quot;)
    f.close()
    # print(ctime())

def myread():
    # print(ctime())
    f = open(&quot;test.txt&quot;,&quot;r&quot;)
    lines = f.readlines()
    # print(ctime())

def myio():
    mywrite()
    myread()
start = time()
jobs = []
for i in range(10):
    t = th.Thread(target = myio)
    jobs.append(t)
    t.start()
for i in jobs:
    i.join()
end = time()
print(end - start)
</code></pre><p><strong>进程和线程的区别和联系</strong></p>
<ul>
<li>1.两者都是多任务编程的方式，都能够使用计算机多核</li>
<li>2.进程的创建和删除要比线程消耗更多计算机资源</li>
<li>3.进程空间独立，数据安全性好，有专门的进程间通信方法</li>
<li>4.线程使用全局变量通信，更加简单，但是往往要与同步互斥机制公用</li>
<li>5.一个进程可以包含多个线程，线程共享进程的资源空间</li>
<li>6.进线程都有自己特有的资源，如命令，属性 id等</li>
</ul>
<p><strong>使用场景 : </strong></p>
<ul>
<li>需要创建较多的并发，任务比较简单时，线程比较合适</li>
<li>如果程序数据资源比较复杂，特别是共享资源较多时，   需要考虑到线程锁的复杂性</li>
<li>如果多个任务无必要的关联性，不易将其强行融入到一   个进程中</li>
<li>Python线程不适合cpu密集型程序</li>
</ul>
<p><strong>总结 ： </strong></p>
<ol>
<li>进程线程的区别和关系</li>
<li>进程间以什么方式通信，有什么特点</li>
<li>同步互斥的意义，有什么方法实现同步互斥</li>
<li>僵尸进程，进程状态，线程GIL的概念</li>
<li>给一个情景，问选择进程还是线程，怎么做为什么</li>
</ol>
<h1 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h1><p>硬件服务器 ： 主机  集群<br>厂商 ： IBM  HP  联想  浪潮</p>
<p>软件服务器 ： 编写的服务端程序，依托于硬件服务器运行，提供给用户一定的软件服务</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>webserver   —-》 网络后端程序提供网络请 求的后端处理和数据交互<br>httpserver  —-》 处理HTTP请求，回复http响应<br>邮箱服务器 —–》 提供邮箱服务<br>文件服务器 —–》 提供文件的上传下载</p>
<p>功能： 网络连接，逻辑处理，数据的交互，数据的传输 协议的实现</p>
<h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p> c/s  (客户端服务器模型)<br> b/s  (浏览器服务器模型)</p>
<p>服务器目标：处理速度快，数据更安全，并发量大 </p>
<p>硬件 ： 更高的配置，集成分布的技术，更好的网络速度，更多的主机，网络安全</p>
<p>软件 ： 程序占有更少的计算机资源，更稳定的运行效果，更流畅的运行速度，采用更合理的技术。处理更高的并发</p>
<h2 id="服务器模型-1"><a href="#服务器模型-1" class="headerlink" title="服务器模型"></a>服务器模型</h2><ul>
<li><p>循环服务器 ：单进程程序，循环的接收客户端的请求，处理请求，每处理完一个请求后再去接收处理下一个请求 </p>
<p> 优点 ： 实现简单，占用系统资源少<br> 缺点 ： 无法同时连接多个客户端，当一个客户端长期占有服务器时会形成其他客户端无法访问的情况<br> 使用情况：任务比较短暂，udp套接字更适合循环</p>
</li>
</ul>
<ul>
<li><p>并发服务器 ： 同时能够处理多个客户端的任务请求。并发可分为IO并发或者多进程多线程并发。</p>
<p>  IO并发 ： IO多路复用    协程</p>
<p>  优点：资源消耗少，适用于IO类型服务器<br>  缺点：不能监控CPU密集的情况，单线程，不能长期阻塞的消息的收发</p>
<p>  进程/线程并发：为每个客户端单独提供一个进程线程，处理客户端请求</p>
<p>  优点： 客户端可以长期占用服务器<br>  缺点： 消耗系统资源较多</p>
</li>
</ul>
<h2 id="多进程并发模型"><a href="#多进程并发模型" class="headerlink" title="多进程并发模型"></a>多进程并发模型</h2><p>使用fork完成并发</p>
<ul>
<li>1.创建套接字  绑定  监听</li>
<li>2.等待接收客户端请求 accept</li>
<li>3.创建子进程处理客户端请求，<br>父进程继续准备接收其他客户端连接</li>
<li>4.客户端退出则子进程结束</li>
</ul>
<h2 id="tftp文件服务器"><a href="#tftp文件服务器" class="headerlink" title="tftp文件服务器"></a>tftp文件服务器</h2><p>项目功能 ： </p>
<ul>
<li>客户端有简单的页面命令提示</li>
<li><p>功能包含</p>
<ol>
<li>查看服务端文件库文件列表</li>
<li>下载其中的某个文件到本地</li>
<li>将本地文件上传到服务器文件库中</li>
<li>退出</li>
</ol>
</li>
<li><p>服务端需要：<br> 1.处理客户端的各种请求<br> 2.允许多个客户端同时进行操作</p>
</li>
</ul>
<p>技术分析 ：<br>        tcp套接字<br>        并发 —》 多进程<br>        对文件的读写发送操作<br>        查看文件列表时需要考虑到粘包问题</p>
<p>整体结构 ：功能封装在类中（上传，下载，查看列表）</p>
<pre><code>流程控制使用main（）
          创建套接字，创建连接创建进程，接收请求
</code></pre><p>作业 ： 完成 get  和 put功能</p>
<p>服务器端代码：</p>
<pre><code>&apos;&apos;&apos;
tftp 文件服务器程序
&apos;&apos;&apos;
from socket import * 
import os 
import signal 
import sys 
import time 

#文件库路径
FILE_PATH = &quot;/home/tarena/&quot;

#实现服务器功能模块
class TftpServer(object):
    def __init__(self,connfd):
        self.connfd = connfd
    def do_list(self):
        #获取列表
        file_list = os.listdir(FILE_PATH)
        if not file_list:
            self.connfd.send(&apos;文件库为空&apos;.encode())
            return 
        else:
            self.connfd.send(b&apos;OK&apos;)
            time.sleep(0.1)

        files = &quot;&quot;
        for file in file_list:
            if file[0] != &apos;.&apos; and \
            os.path.isfile(FILE_PATH + file):
                files = files + file + &apos;#&apos;
        self.connfd.send(files.encode())     


    def do_get(self,filename):
        try:
            fd = open(FILE_PATH + filename,&apos;rb&apos;)
        except:
            self.connfd.send(&quot;文件不存在&quot;.encode())
            return
        self.connfd.send(b&quot;OK&quot;)
        time.sleep(0.1) 
        #发送文件
        try:
            for line in fd:
                self.connfd.send(line)
            fd.close()
        except Exception as e:
            print(e)
        time.sleep(0.1)
        self.connfd.send(b&apos;##&apos;)
        print(&quot;文件发送完毕&quot;)


    def do_put(self,filename):
        try:
            fd = open(FILE_PATH + filename,&apos;w&apos;)
        except:
            self.connfd.send(&quot;无法完成上传&quot;)
        self.connfd.send(b&apos;OK&apos;)
        while True:
            data = self.connfd.recv(1024).decode()
            if data == &quot;##&quot;:
                break
            fd.write(data)
        fd.close()
        print(&quot;上传完毕&quot;)

#流程控制,创建套接字连接,接收请求
def main():
    HOST = &apos;0.0.0.0&apos;
    PORT = 8888
    ADDR = (HOST,PORT)

    sockfd = socket()
    sockfd.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
    sockfd.bind(ADDR)
    sockfd.listen(5)

    signal.signal(signal.SIGCHLD,signal.SIG_IGN)
    print(&quot;Listen to port 8888....&quot;)

    while True:
        try: 
            connfd,addr = sockfd.accept()
        except KeyboardInterrupt:
            sockfd.close()
            sys.exit(&quot;服务器退出&quot;)
        except Exception as e:
            print(e)
            continue
        print(&quot;客户端登录:&quot;,addr)
        #创建父子进程
        pid = os.fork()
        if pid &lt; 0:
            print(&quot;创建子进程失败&quot;)
            continue
        elif pid == 0:
            sockfd.close()
            tftp = TftpServer(connfd)
            #接收客户端请求
            while True:
                data = connfd.recv(1024).decode()
                if not data:
                    continue
                elif data[0] == &apos;L&apos;:
                    tftp.do_list()
                #data ==&gt; G filename
                elif data[0] == &apos;G&apos;:
                    filename = data.split(&apos; &apos;)[-1]
                    tftp.do_get(filename)
                elif data[0] == &apos;P&apos;:
                    filename = data.split(&apos; &apos;)[-1]
                    tftp.do_put(filename)
                elif data[0] == &apos;Q&apos;:
                    print(&quot;客户端退出&quot;)
                    sys.exit(0)

        else:
            connfd.close()
            continue

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><p>客户端代码：</p>
<pre><code>from socket import * 
import sys 
import time 

#实现基本的请求功能
class TftpServer(object):
    def __init__(self,sockfd):
        self.sockfd = sockfd

    def do_list(self):
        self.sockfd.send(b&quot;L&quot;) #发送请求类型
        #等待接收服务器端确认
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            data = self.sockfd.recv(4096).decode()
            files = data.split(&apos;#&apos;)
            for file in files:
                print(file)
            print(&quot;%%%%%文件列表展示完毕%%%%%\n&quot;)
        else:
            #失败的原因由服务器发送过来
            print(data)


    def do_get(self,filename):
        self.sockfd.send((&apos;G &apos;+filename).encode())
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            fd = open(filename,&apos;w&apos;)
            while True:
                data = self.sockfd.recv(1024).decode()
                if data == &quot;##&quot;:
                    break
                fd.write(data)
            fd.close()
            print(&quot;%s 下载完成\n&quot;%filename)
        else:
            print(data)

    def do_put(self,filename):
        try:
            fd = open(filename,&apos;rb&apos;)
        except:
            print(&quot;上传的文件不存在&quot;)
            return
        self.sockfd.send((&quot;P &quot; + filename).encode())
        data = self.sockfd.recv(1024).decode()
        if data == &apos;OK&apos;:
            for line in fd:
                self.sockfd.send(line)
            fd.close()
            time.sleep(0.1)
            self.sockfd.send(b&apos;##&apos;)
            print(&quot;%s 文件上传完毕&quot;%filename)
        else:
            print(data)


    def do_quit(self):
        self.sockfd.send(b&apos;Q&apos;)


#套接字连接
def main():
    if len(sys.argv) &lt; 3:
        print(&quot;argv is error&quot;)
        return 
    HOST = sys.argv[1]
    PORT = int(sys.argv[2])
    ADDR = (HOST,PORT)

    sockfd = socket()
    sockfd.connect(ADDR)

    tftp = TftpServer(sockfd) #tftp对象调用请求方法

    while True:
        print(&quot;=======命令选项========&quot;)
        print(&quot;******* list *********&quot;)
        print(&quot;*******get file ******&quot;)
        print(&quot;*******put file ******&quot;)
        print(&quot;******* quit *********&quot;)
        print(&quot;======================&quot;)

        cmd = input(&quot;请输入命令&gt;&gt;&quot;)

        if cmd.strip() == &apos;list&apos;:
            tftp.do_list()
        elif cmd[:3] == &quot;get&quot;:
            filename = cmd.split(&apos; &apos;)[-1]
            tftp.do_get(filename)
        elif cmd[:3] == &quot;put&quot;:
            filename = cmd.split(&apos; &apos;)[-1]
            tftp.do_put(filename)
        elif cmd.strip() == &quot;quit&quot;:
            tftp.do_quit()
            sockfd.close()
            sys.exit(&quot;欢迎使用&quot;) 
        else:
            print(&quot;请输入正确的命令!!!&quot;)
            continue

if __name__ == &quot;__main__&quot;:
    main()
</code></pre><hr>
<p>*小贴士：</p>
<p>文件处理函数</p>
<p>os.listdir(PATH) : 获取一个目录内文件列表<br>os.path.isfile() :判断一个文件的类型是否为普通文件<br>os.path.isdir() ：判断一个文件的类型是否为目录*</p>
<hr>
<h2 id="threading-的多线程并发"><a href="#threading-的多线程并发" class="headerlink" title="threading 的多线程并发"></a>threading 的多线程并发</h2><p>对比多进程并发：<br>优点 ： 资源消耗少<br>缺点 ： 需要注意共享资源的争夺<br>        Python多线程收到GIL的影响</p>
<p>实现步骤：</p>
<ul>
<li>1 创建套接字，绑定，监听</li>
<li>2 接收客户端连接请求，创建新的线程</li>
<li>3 主线程继续等待其他客户端连接，分支线程执行客户    端请求</li>
<li>4 处理完客户端请求后，分支线程退出，关闭客户端套    接字</li>
</ul>
<p>socket服务器集成模块</p>
<p>python2  SocketServer<br>python3  socketserver</p>
<p>功能 ： 通过模块的接口完成基于多进程/多线程的tcp/udp 的socket并发程序</p>
<p>模块类</p>
<p>DatagramRequestHandler  处理udp请求<br>StreamRequestHandler    处理tcp请求</p>
<p>UDPServer   提供udp服务端类<br>TCPServer   提供tcp服务端类</p>
<p>ForkingMixIn   提供进程创建<br>ForkingTCPServer   ==》ForkingMixIn + TCPServer<br>ForkingUDPServer   ==》ForkingMixIn + UDPServer</p>
<p>ThreadingMixIn  提供线程创建<br>ThreadingTCPServer  ==》ThreadingMixIn + TCPServer<br>ThreadingUDPServer  ==》ThreadingMixIn + TCPServer</p>
<p>基于多线程并发的 HTTPServer</p>
<p>HTTPServer的作用 </p>
<ul>
<li>1.就收浏览器发送的http请求</li>
<li>2.对http请求进行解析</li>
<li>3.组织响应内容进行回发</li>
</ul>
<p>升级</p>
<ul>
<li>使用多线程的并发可以同时处理多个客户端请求</li>
<li>增加简单的应用程序，使浏览器不仅可以访问静态网页也可以访问后台程序</li>
<li>使用类对服务器功能模块进行封装</li>
</ul>
<p>技术点 ： threading 并发<br>          tcp socket 套接字<br>                    http协议响应内容进行字符串拼接</p>
<p>代码示例：<br>        ‘’’<br>        http server 第二版<br>        ‘’’<br>        from socket import *<br>        from threading import Thread<br>        import time </p>
<pre><code>ADDR = (&apos;0.0.0.0&apos;,8000)
#存放静态页面的目录
STATIC_DIR = &quot;./static&quot;

#httpserver类 封装服务器功能
class HTTPServer(object):
    def __init__(self,addr): 
        #套接字创建
        self.sockfd = socket()
        self.sockfd.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)
        self.sockfd.bind(addr)
        self.sockfd.listen(5)
        #为对象添加一些属性
        self.name = &quot;HttpServer&quot;
        self.port = 8000
        self.address = addr

    # 监听客户端的链接请求,创建新的线程处理
    def serve_forever(self):
        print(&quot;Listen to port 8000.....&quot;)
        while True:
            connfd,addr = self.sockfd.accept()
            #创建新的线程处理具体请求
            clientThread = Thread(target = self.handleRequest,args = (connfd,))

            clientThread.setDaemon(True)
            clientThread.start()

    def handleRequest(self,connfd):
        #接收客户端请求
        request = connfd.recv(4096)
        requestHeadlers = request.splitlines()
        #请求行
        print(connfd.getpeername(),&quot;:&quot;,requestHeadlers[0])
        #获取具体请求
        getRequest = str(requestHeadlers[0]).split(&apos; &apos;)[1]

        #访问静态网页
        if getRequest[-3:] != &quot;.py&quot;:
            if getRequest == &apos;/&apos;:
                getFilename = STATIC_DIR + &quot;/index.html&quot;
            else:
                getFilename = STATIC_DIR + getRequest

            try:
                f = open(getFilename)
            except Exception:
                #没有找到页面
                responseHeaders = &quot;HTTP/1.1 404 not found\r\n&quot;
                responseHeaders += &quot;\r\n&quot;
                responseBody = &quot;===Sorry,the page not found===&quot;
            else:
                responseHeaders = &quot;HTTP/1.1 200 OK\r\n&quot;
                responseHeaders += &quot;\r\n&quot;
                responseBody = f.read()
            finally:
                response = responseHeaders + responseBody
                connfd.send(response.encode())
        #访问后台程序
        else:
            #通过函数得到响应体
            responseBody = self.application()

            responseHeaders = &quot;HTTP/1.1 200 OK\r\n&quot;
            responseHeaders += &quot;\r\n&quot;
            response = responseHeaders + responseBody

            connfd.send(response.encode())

        connfd.close()

    #获取去你要使用的外部函数,变为属性
    def setApp(self,application):
        self.application = application 


#后台程序
def app():
    return &quot;\n===假设这是一个很复杂的程序,你得到了一个很牛逼的内容===\n%s&quot;%time.ctime()


if __name__ == &quot;__main__&quot;:
    httpd = HTTPServer(ADDR)
    httpd.setApp(app)
    #启动服务器
    httpd.serve_forever()
</code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>定义： 纤程 微线程 ，协程本质只有一个线程在运行</p>
<p>功能原理 ： 通过应用层程序，记录上下文栈区，实现在程序执行过程中的跳跃，选择可以不阻塞的部分执行，从而提高IO的执行效率</p>
<p><strong>优点 ： </strong><br>资源消耗很少<br>无需多线程那样来回切换的开销<br>无需进行同步互斥操作<br>IO并发性好</p>
<p><strong>缺点 ： </strong><br>无法利用计算机的多核资源<br>程序不能够一个客户端单独长时间占有服务端</p>
<p>yield–&gt; 协程的基本实现关键字</p>
<pre><code>sudo pip3 install  greenlet
sudo pip3 install  gevent

greenlet 
greenlet.greenlet()
gr.switch()
</code></pre><p>示例代码：</p>
<pre><code>from greenlet import greenlet

def test1():
    print(12)
    gr2.switch()
    s =  input(&quot;t1 input: &quot;)
    print(&quot;s= &quot;,s)
    print(34)
    gr2.switch()

def test2():
    print(56)
    gr1.switch()
    print(78)

gr1 = greenlet(test1)
gr2 = greenlet(test2)

gr1.switch()
</code></pre><p>gevent</p>
<ul>
<li>将协程事件封装为函数</li>
</ul>
<p>gevent.spawn(func,argv)<br>功能 ： 将事件变为协程事件并启动<br>参数 ： func  传入一个函数变为协程<br>        argv  给func函数传参<br>返回值 ： 协程对象</p>
<p>gevent.joinall()<br>功能：回收协程</p>
<p>gevent.sleep(n)<br>功能 ； 模拟IO阻塞的情况</p>
<pre><code>from gevent import  monkey
monkey.patch_all()
</code></pre><p>功能 ： 在导入socket模块之前使用，修改socket的IO设置行为</p>
<p>示例代码：</p>
<pre><code>import gevent
from gevent import monkey

def foo():
    print(&quot;run in foo&quot;)
    gevent.sleep(2)
    print(&quot;switch to foo again&quot;)

def bar():
    print(&quot;run in bar&quot;)
    gevent.sleep(3)
    print(&quot;switch to bar again&quot;)

f = gevent.spawn(foo)
b = gevent.spawn(bar)

gevent.joinall([b,f])
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/图/" itemprop="url">图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T09:07:51+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2,248 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>python数据结构之图的实现，官方有一篇文章介绍，<br><a href="https://www.python.org/doc/essays/graphs/" target="_blank" rel="noopener">https://www.python.org/doc/essays/graphs/</a></p>
<p><strong>图</strong>是由边或弧连接的节点组成的网络。<br>在<strong>有向图</strong>中，节点之间的连接有一个方向，称为弧;在<strong>无向图</strong>中，连接没有方向，称为边。<br>我们主要讨论<strong>有向图</strong>。图中的算法包括找到两个节点之间的路径，找到两个节点之间的最短路径，确定图中的周期（周期是从节点到自身的非空路径），找到到达所有节点的路径（着名的“旅行商问题”），等等。有时图形的节点或弧具有与它们相关的权重或成本，我们有兴趣找到最便宜的路径。<br>关于图算法的文献很多，它们是离散数学的重要组成部分。图形在计算机算法中也有很多实际用途。在网络管理中可以找到明显的例子，但许多其他领域的例子比比皆是。例如，计算机程序中的调用者 - 被调用者关系可以被视为图形（其中周期指示递归，并且不可达的节点表示死节点）。</p>
<h2 id="列表和词典构建法"><a href="#列表和词典构建法" class="headerlink" title="列表和词典构建法"></a>列表和词典构建法</h2><p>很少有编程语言直接支持图形作为数据类型，Python也不例外。但是，图表很容易从列表和词典中构建。例如，这是一个简单的图形（我不能在这些列中使用图纸，所以我写下图形的弧形）：</p>
<pre><code>A -&gt; B
A -&gt; C
B -&gt; C
B -&gt; D
C -&gt; D
D -&gt; C
E -&gt; F
F -&gt; C
</code></pre><p>该图有六个节点（A-F）和八个弧。它可以由以下Python数据结构表示：</p>
<pre><code>graph = {&apos;A&apos;: [&apos;B&apos;, &apos;C&apos;],
         &apos;B&apos;: [&apos;C&apos;, &apos;D&apos;],
         &apos;C&apos;: [&apos;D&apos;],
         &apos;D&apos;: [&apos;C&apos;],
         &apos;E&apos;: [&apos;F&apos;],
         &apos;F&apos;: [&apos;C&apos;]}
</code></pre><p>这是一个字典，其键是图的节点。对于每个键，相应的值是一个列表，其中包含通过此节点的直接弧连接的节点。这很简单（更简单的是，节点可以用数字而不是名字来表示，但名称更方便，可以很容易地携带更多信息，例如城市名称）。<br>让我们编写一个简单的函数来确定两个节点之间的路径。它需要一个图形，并将起始和结束节点作为参数。它将返回包含路径的节点列表（包括开始和结束节点）。如果找不到路径，则返回None。同一节点在返回的路径上不会出现多次（即它不包含循环）。该算法使用一种称为回溯的重要技术：它依次尝试每种可能性，直到找到解决方案。</p>
<pre><code>def find_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if not graph.has_key(start):
        return None
    for node in graph[start]:
        if node not in path:
            newpath = find_path(graph, node, end, path)
            if newpath: return newpath
    return None
</code></pre><p>A sample run (using the graph above):<br>    &gt;&gt;&gt; find_path(graph, ‘A’, ‘D’)<br>    [‘A’, ‘B’, ‘C’, ‘D’]<br>    &gt;&gt;&gt;<br>第二个“if”语句仅在存在被列为弧的终点但没有外部弧的节点的情况下才是必需的，并且根本没有在图中列出。这样的节点也可以包含在图中，带有一个空的传出弧列表，但有时候更方便的是不要求它。<br>请注意，当用户使用三个参数调用find_graph（）时，它会使用第四个参数调用自身：已遍历的路径。此参数的默认值是空列表’[]’，表示尚未遍历任何节点。该参数用于避免循环（’for’循环内的第一个’if’）。 ‘path’参数未被修改：赋值“path = path + [start]”创建一个新列表。如果我们改写了“path.append（start）”，我们就会在调用者中修改变量’path’，结果是灾难性的。 （使用元组，我们可以肯定这不会发生，代价是必须编写“path = path +（start，）”，因为“（start）”不是单例元组 - 它只是一个括号表达。）</p>
<p>我们能轻易的更改此函数以返回所有路径（没有循环）的列表，而不是它找到的第一个路径：</p>
<pre><code>def find_all_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    if not graph.has_key(start):
        return []
    paths = []
    for node in graph[start]:
        if node not in path:
            newpaths = find_all_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths
</code></pre><p>运行示例:</p>
<pre><code>&gt;&gt;&gt; find_all_paths(graph, &apos;A&apos;, &apos;D&apos;)
[[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;], [&apos;A&apos;, &apos;B&apos;, &apos;D&apos;], [&apos;A&apos;, &apos;C&apos;, &apos;D&apos;]]
&gt;&gt;&gt; 
</code></pre><p>另一个方法找到最短路径：</p>
<pre><code>def find_shortest_path(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if not graph.has_key(start):
        return None
    shortest = None
    for node in graph[start]:
        if node not in path:
            newpath = find_shortest_path(graph, node, end, path)
            if newpath:
                if not shortest or len(newpath) &lt; len(shortest):
                    shortest = newpath
    return shortest
</code></pre><p>运行示例:<br>    &gt;&gt;&gt; find_shortest_path(graph, ‘A’, ‘D’)<br>    [‘A’, ‘C’, ‘D’]<br>    &gt;&gt;&gt; </p>
<p>这些功能非常简单。 然而，它们几乎是最优的（对于用Python编写的代码）。 在另一个Python Patterns专栏中，我将尝试分析其运行速度并提高其性能，代价是更多代码。<br>另一种变化是添加更多数据抽象：创建一个表示图的类，其方法实现各种算法。 虽然这吸引了对结构化编程的渴望，但它并没有使代码更有效（相反）。 它确实可以更容易地向节点或弧添加各种标签，并添加将这些标签考虑在内的算法（例如，找到地图上两个城市之间的最短路径）。 这也是另一个专栏的主题。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>会将每个结点可能的邻居位置排成一行（也就是一个数组，用于对应图中每一个结点），然后用某种值（如True或False）来表示相关结点是否为当前结点的邻居。为了让矩阵具有更好的可读性，我们将会用1和0来充当所谓的真值（也可用True和False）。</p>
<pre><code>v0,v1,v2,v3,v4,v5=range(6)
N=[[0,1,0,0,0,1],#v0
   [0,0,1,0,0,0],#v1
   [0,0,0,1,0,0],#v2
   [0,0,0,0,1,1],#v3
   [1,0,0,0,0,0],#v4 
   [0,0,1,0,1,0]]#v5 

   &gt;&gt;&gt; N[v0][v1]
1
&gt;&gt;&gt; sum(N[v0])
2
</code></pre><p>将邻接矩阵扩展成允许对边进行加权处理：在原来存储真值的地方直接存储相关的权值即可。例如，对于边（u,v）来说，我们只需要将N[u][v]处的True替换成w(u,v)即可，我们通常会将一些不存在的边的权值设置为无穷大。<br>对角线上的值依旧应该全为0，任何节点到自身的距离都应该始终为0。</p>
<p>把上面的代码改为：</p>
<pre><code>v0,v1,v2,v3,v4,v5=range(6)  
inf=float(&apos;inf&apos;)  
w=N=[[0,5,inf,inf,inf,2],#v0  
   [inf,0,4,inf,inf,inf],#v1
   [inf,inf,0,9,inf,inf],#v2
   [inf,inf,inf,0,7,3],#v3
   [1,inf,inf,inf,0,inf],#v4
   [inf,inf,1,inf,8,0]]#v5 
&gt;&gt;&gt;w[v0][v1]
Out[6]: 
5
&gt;&gt;&gt;w[v2][v1]
Out[7]: 
inf
</code></pre><h2 id="图的创建和广度深度遍历"><a href="#图的创建和广度深度遍历" class="headerlink" title="图的创建和广度深度遍历"></a>图的创建和广度深度遍历</h2><pre><code>class Graph(object):
    def __init__(self, maps):
        self.maps = maps
        self.nodenum = self.get_nodenum()
        self.edgenum = self.get_edgenum()

    def get_nodenum(self):
        return len(self.maps)

    def get_edgenum(self):
        count = 0
        for i in range(self.nodenum):
            for j in range(i):
                if self.maps[i][j] &gt; 0:
                    count += 1
        return count

    def insert_node(self):
        for i in range(len(self.maps)):
            self.maps[i].append(-1)
        self.maps.append([-1]*(self.nodenum) + [0])
        self.nodenum += 1

    def insert_edge(self, x, y, weight):
        if x &lt; 0 or x &gt;= self.nodenum or y &lt; 0 or y &gt; self.nodenum or weight &lt;= 0 or x == y:
            return
        else:
            self.maps[x][y] = self.maps[y][x] = weight
            self.edgenum += 1

    def breath_first_search(self):
        queue = []
        visited = [False]*self.nodenum
        res = []
        def bfs():
            while len(queue) &gt; 0:
                i = queue.pop(0)
                for j in range(self.nodenum):
                    if self.maps[i][j] &gt; 0 and visited[j] == False:
                        res.append(j)
                        visited[j] = True
                        queue.append(j)

        if self.nodenum &lt;= 0:
            return res
        else:
            queue.append(0)#index, value
            visited[0] = True
            res.append(0)
            bfs()

        for i in range(self.nodenum):
            if visited[i] == False:
                res.append(i)
                visited[i] = True
                queue.append(i)
                bfs()

        return res

    def depth_first_search(self):
        res = []
        visited = [False]*self.nodenum
        def dfs(i):
            res.append(i)
            visited[i] = True
            for j in range(self.nodenum):
                if self.maps[i][j] &gt; 0 and visited[j] == False:
                    dfs(j)
        if self.nodenum &gt; 0:
            dfs(0)
        for i in range(self.nodenum):
            if visited[i] == False:
                dfs(i)
</code></pre><p><strong>测试用例</strong><br>    maps = [[0,3,9,-1], [3,0,-1,5], [9,-1,0,-1], [-1,5,-1,0]]<br>    graph = Graph(maps)<br>    print(‘邻接矩阵为\n%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    graph.insert_node()<br>    print(‘——-插入一个节点——–’)<br>    print(‘邻接矩阵为%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    graph.insert_edge(0, 4, 7)<br>    print(‘——-插入一个边——–’)<br>    print(‘邻接矩阵为%s’%graph.maps)<br>    print(‘节点数据为%d，边数为%d\n’%(graph.nodenum, graph.edgenum))<br>    print(‘——-广度优先遍历——–’)<br>    print(graph.breath_first_search())<br>    print(‘——-深度优先遍历——–’)<br>    print(graph.depth_first_search())</p>
<p><strong>测试结果</strong><br>    邻接矩阵为<br>    [[0, 3, 9, -1], [3, 0, -1, 5], [9, -1, 0, -1], [-1, 5, -1, 0]]<br>    节点数据为4，边数为3</p>
<pre><code>-------插入一个节点--------
邻接矩阵为[[0, 3, 9, -1, -1], [3, 0, -1, 5, -1], [9, -1, 0, -1, -1], [-1, 5, -1, 0, -1], [-1, -1, -1, -1, 0]]
节点数据为5，边数为3

-------插入一个边--------
邻接矩阵为[[0, 3, 9, -1, 7], [3, 0, -1, 5, -1], [9, -1, 0, -1, -1], [-1, 5, -1, 0, -1], [7, -1, -1, -1, 0]]
节点数据为5，边数为4

-------广度优先遍历--------
[0, 1, 2, 4, 3]
-------深度优先遍历--------
[0, 1, 3, 2, 4]
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/树的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/树的实现/" itemprop="url">树的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-09T20:08:00+08:00">
                2018-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法和数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法和数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,988 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="普通树的实现"><a href="#普通树的实现" class="headerlink" title="普通树的实现"></a>普通树的实现</h1><pre><code>class TreeNode(object):
    &quot;&quot;&quot;The basic node of tree structure&quot;&quot;&quot;

    def __init__(self, name, parent=None):
        super(TreeNode, self).__init__()
        self.name = name
        self.parent = parent
        self.child = {}

    def __repr__(self) :
        return &apos;TreeNode(%s)&apos; % self.name


    def __contains__(self, item):
        return item in self.child


    def __len__(self):
        &quot;&quot;&quot;return number of children node&quot;&quot;&quot;
        return len(self.child)

    def __bool__(self, item):
        &quot;&quot;&quot;always return True for exist node&quot;&quot;&quot;
        return True

    @property
    def path(self):
        &quot;&quot;&quot;return path string (from root to current node)&quot;&quot;&quot;
        if self.parent:
            return &apos;%s %s&apos; % (self.parent.path.strip(), self.name)
        else:
            return self.name

    def get_child(self, name, defval=None):
        &quot;&quot;&quot;get a child node of current node&quot;&quot;&quot;
        return self.child.get(name, defval)

    def add_child(self, name, obj=None):
        &quot;&quot;&quot;add a child node to current node&quot;&quot;&quot;
        if obj and not isinstance(obj, TreeNode):
            raise ValueError(&apos;TreeNode only add another TreeNode obj as child&apos;)
        if obj is None:
            obj = TreeNode(name)
        obj.parent = self
        self.child[name] = obj
        return obj

    def del_child(self, name):
        &quot;&quot;&quot;remove a child node from current node&quot;&quot;&quot;
        if name in self.child:
            del self.child[name]

    def find_child(self, path, create=False):
        &quot;&quot;&quot;find child node by path/name, return None if not found&quot;&quot;&quot;
        # convert path to a list if input is a string
        path = path if isinstance(path, list) else path.split()
        cur = self
        for sub in path:
            # search
            obj = cur.get_child(sub)
            if obj is None and create:
                # create new node if need
                obj = cur.add_child(sub)
            # check if search done
            if obj is None:
                break
            cur = obj
        return obj

    def items(self):
        return self.child.items()

    def dump(self, indent=0):
        &quot;&quot;&quot;dump tree to string&quot;&quot;&quot;
        tab = &apos;    &apos;*(indent-1) + &apos; |- &apos; if indent &gt; 0 else &apos;&apos;
        print(&apos;%s%s&apos; % (tab, self.name))
        for name, obj in self.items():
            obj.dump(indent+1)
</code></pre><h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><pre><code>class BinaryTree:
    def __init__(self, rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None

    def insertLeft(self, newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild
            self.leftChild = t

    def insertRight(self, newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t

    def getRightChild(self):
        return self.rightChild

    def getLeftChild(self):
        return self.leftChild

    def setRootVal(self, obj):
        self.key = obj

    def getRootVal(self):
        return self.key
</code></pre><h1 id="哈夫曼树及python实现"><a href="#哈夫曼树及python实现" class="headerlink" title="哈夫曼树及python实现"></a>哈夫曼树及python实现</h1><p>哈夫曼（huffman）树<br>基本概念<br>路径和路径长度：树中一个结点到另一个结点之间的分支构成这两个结点之间的路径；路径上的分枝数目称作路径长度，它等于路径上的结点数减1.<br>结点的权和带权路径长度：在许多应用中，常常将树中的结点赋予一个有着某种意义的实数，我们称此实数为该结点的权；结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上权的乘积.<br>树的带权路径长度：为树中所有叶子结点的带权路径长度之和，公式为：<br>WPL=∑i=1nwili<br>其中，n表示叶子结点的数目，wi和li分别表示叶子结点ki的权值和树根结点到ki之间的路径长度。<br>如下图中树的带权路径长度 WPL = 9 x 2 + 12 x 2 + 15 x 2 + 6 x 3 + 3 x 4 + 5 x 4 = 122</p>
<p>哈夫曼树：哈夫曼树又称最优二叉树。它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度 WPL 最小的二叉树。</p>
<p>构造方法： 将最小的2个数，小的放左边，合并在一起，然后得到一个新数，将所有数再取最小的2个，左小右大，再次合并，以此类推直到最后一个数的时候结束 </p>
<p>构建哈夫曼树<br>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p>
<p>将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；<br>在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>从森林中删除选取的两棵树，并将新树加入森林；<br>重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p>
<img src="/2018/08/09/树的实现/2018/08/09/树的实现/aa.jpg" title="这是一个新的博客的图片的说明">
<p>注意：</p>
<p>为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权。<br>如果还是不清楚过程，可以参考<br><a href="https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html，过程介绍的更清晰。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a501d80c16dfa0ec620f5e70.html，过程介绍的更清晰。</a></p>
<p>哈夫曼编码<br>等长编码：这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）。假设字符集只含有4个字符A，B，C，D，用二进制两位表示的编码分别为00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为14位。当接收方接收到这段电文后，将按两位一段进行译码。这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</p>
<p>不等长编码：在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编码。例如，可以为A，B，C，D四个字符分别分配0，00，1，01，并可将上述电文用二进制序列：000011010发送，其长度只有9个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面4个0是4个A，1个B、2个A，还是2个B，即译码不唯一，因此这种编码方法不可使用。<br>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀，这宗编码称为前缀编码（prefix code）。</p>
<ol>
<li>利用字符集中每个字符的使用频率作为权值构造一个哈夫曼树； </li>
<li>从根结点开始，为到每个叶子结点路径上的左分支赋予0，右分支赋予1，并从根到叶子方向形成该叶子结点的编码.</li>
</ol>
<p>假设一个文本文件TFile中只包含7个字符{a，b，c，d，e，f}，这7个字符在文本中出现的次数为{9，12，6，3，5，15}<br>通过哈夫曼树来构造的编码称为哈弗曼编码（huffman code） </p>
<p>9 12 6 3 5 15<br>9 12 6 8 15<br>9 12 14 15<br>21 29<br>50<br>0表示左 1表示右<br>9-00<br>12 - 01<br>6 - 100<br>3 - 1010<br>5 - 1011<br>15 - 11</p>
<p>a 的编码为：00<br>b 的编码为：01<br>c 的编码为：100<br>d 的编码为：1010<br>e 的编码为：1011<br>f 的编码为：11</p>
<p>Python实现<br>若带编码字符的个数，即树中叶结点的最大个数为n时，哈夫曼树的总节点数为2n-1<br><strong>节点类</strong></p>
<pre><code>class Node(object):
    def __init__(self,name=None,value=None):
        self._name=name
        self._value=value
        self._left=None
        self._right=None
</code></pre><p><strong>哈夫曼树类</strong></p>
<p>class HuffmanTree(object):</p>
<pre><code>#根据Huffman树的思想：以叶子节点为基础，反向建立Huffman树
def __init__(self,char_weights):
    self.a=[Node(part[0],part[1]) for part in char_weights]  #根据输入的字符及其频数生成叶子节点
    while len(self.a)!=1:    
        self.a.sort(key=lambda node:node._value,reverse=True)
        c=Node(value=(self.a[-1]._value+self.a[-2]._value))
        c._left=self.a.pop(-1)
        c._right=self.a.pop(-1)
        self.a.append(c)
    self.root=self.a[0]
    self.b=range(10)          #self.b用于保存每个叶子节点的Haffuman编码,range的值只需要不小于树的深度就行

#用递归的思想生成编码
def pre(self,tree,length):
    node=tree
    if (not node):
        return
    elif node._name:
        print node._name + &apos;的编码为:&apos;,
        for i in range(length):
            print self.b[i],
        print &apos;\n&apos;
        return
    self.b[length]=0
    self.pre(node._left,length+1)
    self.b[length]=1
    self.pre(node._right,length+1)

 #生成哈夫曼编码   
def get_code(self):
    self.pre(self.root,0)

if __name__==&apos;__main__&apos;:
    #输入的是字符及其频数
    char_weights=[(&apos;a&apos;,5),(&apos;b&apos;,4),(&apos;c&apos;,10),(&apos;d&apos;,8),(&apos;f&apos;,15),(&apos;g&apos;,2)]
    tree=HuffmanTree(char_weights)
    tree.get_code()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Godshion</p>
              <p class="site-description motion-element" itemprop="description">本站主要提供python教学的系列知识汇总</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                主页
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_41661393" title="csdn_blog" target="_blank">csdn_blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Godshion</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">116.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  






	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
