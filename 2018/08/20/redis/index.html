<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="redis," />










<meta name="description" content="redis介绍redis是一种非关系型数据库(NOSQL not only sql)，是一个由Salvatore Sanfikippo写的key-value存储系统。Redis是开源的，使用的是ANSI C语言编写的，遵守BSD协议，支持网络，可基于内存，可持久化的日志型键值对的数据库值的数据类型： 字符串string 哈希Map 列表list 集合set 有序集合sorted sets等类型。">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://yoursite.com/2018/08/20/redis/index.html">
<meta property="og:site_name" content="响神的博客">
<meta property="og:description" content="redis介绍redis是一种非关系型数据库(NOSQL not only sql)，是一个由Salvatore Sanfikippo写的key-value存储系统。Redis是开源的，使用的是ANSI C语言编写的，遵守BSD协议，支持网络，可基于内存，可持久化的日志型键值对的数据库值的数据类型： 字符串string 哈希Map 列表list 集合set 有序集合sorted sets等类型。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-20T12:06:30.566Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis">
<meta name="twitter:description" content="redis介绍redis是一种非关系型数据库(NOSQL not only sql)，是一个由Salvatore Sanfikippo写的key-value存储系统。Redis是开源的，使用的是ANSI C语言编写的，遵守BSD协议，支持网络，可基于内存，可持久化的日志型键值对的数据库值的数据类型： 字符串string 哈希Map 列表list 集合set 有序集合sorted sets等类型。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/20/redis/"/>





  <title>redis | 响神的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">响神的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">计算机编程-python入门到精通</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Godshion">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="响神的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T18:07:40+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/20/redis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/08/20/redis/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,443 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  55 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><p>redis是一种非关系型数据库(NOSQL not only sql)，是一个由Salvatore Sanfikippo写的key-value存储系统。<br>Redis是开源的，使用的是ANSI C语言编写的，遵守BSD协议，支持网络，可基于内存，可持久化的日志型键值对的数据库<br>值的数据类型： 字符串string 哈希Map 列表list 集合set 有序集合sorted sets等类型。</p>
<h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。</p>
<h2 id="Redis优势"><a href="#Redis优势" class="headerlink" title="Redis优势"></a>Redis优势</h2><ul>
<li>性能极高 读写速度达到了110K/s 81K/s</li>
<li>丰富的数据类型</li>
<li>原子性</li>
<li>丰富的特性-Redis还支持publish/subscribe 通知，key过期等特性</li>
</ul>
<p>Redis与其他key-value存储的区别</p>
<ul>
<li>Redis有着更加复杂的数据结构并且提供对其的原子操作，redis的数据类型都是基本数据类型，对程序员透明，不需要进行抽象</li>
<li>Redis运行在内存中，但是可以持久化到磁盘，在运行速度上更加快。</li>
</ul>
<h1 id="Redis环境配置"><a href="#Redis环境配置" class="headerlink" title="Redis环境配置"></a>Redis环境配置</h1><h2 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h2><p>windows下载地址：<a href="https://github.com/MSOpenTech/redis/releases。" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases。</a><br>下载zip格式的文件，解压，然后在解压目录下，点击路径，将原来的删除，输入cmd，回车进入到该目录的命令行模式窗口下，为了方便，请添加该路径到环境变量，具体方法这里不详述了。<br>然后在打开的命令行运行指令</p>
<pre><code>redis-server.exe redis.windows.conf
</code></pre><p>这样就可以看到类型如下界面，我的路径是D:\Redis-x64-3.2.100&gt;：</p>
<pre><code>Microsoft Windows [版本 10.0.15063]
(c) 2017 Microsoft Corporation。保留所有权利。

D:\Redis-x64-3.2.100&gt;redis-server.exe redis.windows.conf
                _._
           _.-``__ &apos;&apos;-._
      _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.100 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._
 (    &apos;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 6379
 |    `-._   `._    /     _.-&apos;    |     PID: 1716
  `-._    `-._  `-./  _.-&apos;    _.-&apos;
 |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|
 |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io
  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;
 |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|
 |    `-._`-._        _.-&apos;_.-&apos;    |
  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;
      `-._    `-.__.-&apos;    _.-&apos;
          `-._        _.-&apos;
              `-.__.-&apos;

[1716] 20 Aug 18:31:21.434 # Server started, Redis version 3.2.100
[1716] 20 Aug 18:31:21.435 * The server is now ready to accept connections on port 6379
</code></pre><p>这个指令的作用是开启redis的服务器，我们需要再启动一个客户端，在刚刚的目录下再打开一个命令行窗口，执行指令</p>
<pre><code>redis-cli.exe -h 127.0.0.1 -p 6379
</code></pre><p>来启动客户端，以下指令不指定情况下都是在该窗口发送的。</p>
<p>设置键值对指令 set myKey abc<br>取出键值对  get myKey</p>
<pre><code>D:\Redis-x64-3.2.100&gt;redis-cli.exe -h 127.0.0.1 -p 6379
127.0.0.1:6379&gt; set myKey abc
OK
127.0.0.1:6379&gt; get myKey
&quot;abc&quot;
127.0.0.1:6379&gt;
</code></pre><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p>ubuntu下执行如下指令安装redis</p>
<pre><code>sudo apt-get install redis-server
</code></pre><p>启动reids</p>
<pre><code>redis-server
</code></pre><p>查看redis是否启动</p>
<pre><code>redis-cli
</code></pre><h2 id="Mac-下安装-（没有试过，手上没有这个系统的机器）"><a href="#Mac-下安装-（没有试过，手上没有这个系统的机器）" class="headerlink" title="Mac 下安装 （没有试过，手上没有这个系统的机器）"></a>Mac 下安装 （没有试过，手上没有这个系统的机器）</h2><ol>
<li><p>官网<a href="http://redis.io/" target="_blank" rel="noopener">http://redis.io/</a> 下载最新的稳定版本,这里是3.2.0</p>
</li>
<li><p>sudo mv 到 /usr/local/</p>
</li>
<li><p>sudo tar -zxf redis-3.2.0.tar 解压文件</p>
</li>
<li><p>进入解压后的目录 cd redis-3.2.0</p>
</li>
<li><p>sudo make test 测试编译</p>
</li>
<li><p>sudo make install </p>
</li>
</ol>
<p>mac 下安装也可以使用 homebrew，homebrew 是 mac 的包管理器。</p>
<p>1、执行 brew install redis</p>
<p>2、启动 redis，可以使用后台服务启动 brew services start redis。或者直接启动：redis-server /usr/local/etc/redis.conf</p>
<h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><p>查看配置名称<br>CONFIG GET CONFIG_SETTING_NAME<br>获取log级别<br>CONFIG GET loglevel<br>获取所有配置项<br>CONFIG GET *</p>
<p>设置配置项<br>基本语法规则： CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE<br>示例如下：</p>
<pre><code>CONFIG SET loglevel &quot;notice&quot;
</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>redis.conf 配置项说明如下：</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<p> daemonize no</p>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<p> pidfile /var/run/redis.pid</p>
</li>
<li><p>指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
<p> port 6379</p>
</li>
<li><p>绑定的主机地址</p>
<p> bind 127.0.0.1</p>
</li>
</ol>
<p>5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>
<pre><code>timeout 300
</code></pre><ol start="6">
<li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
<p> loglevel verbose</p>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<p> logfile stdout</p>
</li>
<li><p>设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</dbid></p>
<p> databases 16</p>
</li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<p> save <seconds> <changes></changes></seconds></p>
<p> Redis默认配置文件中提供了三个条件：</p>
<p> save 900 1</p>
<p> save 300 10</p>
<p> save 60 10000</p>
<p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
</li>
</ol>
<ol start="10">
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
<p>rdbcompression yes</p>
</li>
<li><p>指定本地数据库文件名，默认值为dump.rdb</p>
<p>dbfilename dump.rdb</p>
</li>
<li><p>指定本地数据库存放目录</p>
<p>dir ./</p>
</li>
<li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
<p>slaveof <masterip> <masterport></masterport></masterip></p>
</li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<p>masterauth <master-password></master-password></p>
</li>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</password></p>
<p>requirepass foobared</p>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<p>maxclients 128</p>
</li>
<li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
<p>maxmemory <bytes></bytes></p>
</li>
<li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
<p>appendonly no</p>
</li>
<li><p>指定更新日志文件名，默认为appendonly.aof</p>
<p> appendfilename appendonly.aof</p>
</li>
<li><p>指定更新日志条件，共有3个可选值：<br>no：表示等操作系统进行数据缓存同步到磁盘（快）<br>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>everysec：表示每秒同步一次（折衷，默认值）</p>
<p>appendfsync everysec</p>
</li>
</ol>
<ol start="21">
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
<p> vm-enabled no</p>
</li>
<li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
<p> vm-swap-file /tmp/redis.swap</p>
</li>
<li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
<p> vm-max-memory 0</p>
</li>
<li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
<p> vm-page-size 32</p>
</li>
<li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
<p> vm-pages 134217728</p>
</li>
<li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
<p> vm-max-threads 4</p>
</li>
<li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
<p>glueoutputbuf yes</p>
</li>
<li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
<p>hash-max-zipmap-entries 64</p>
<p>hash-max-zipmap-value 512</p>
</li>
<li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
<p>activerehashing yes</p>
</li>
<li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
<p>include /path/to/local.conf</p>
</li>
</ol>
<h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p>
<p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p>
<p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p>
<p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; SET name &quot;qixinyue&quot;
OK
redis 127.0.0.1:6379&gt; GET name
&quot;qixinyue&quot;
</code></pre><p>在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 qixinyue。</p>
<p>注意：一个键最大能存储512MB。</p>
<p>Redis 字符串命令<br>下表列出了常用的 redis 字符串命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>2</td>
<td>GET key</td>
<td>获取指定 key 的值。</td>
</tr>
<tr>
<td>3</td>
<td>GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>4</td>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
</tr>
<tr>
<td>5</td>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>6</td>
<td>MGET key1 [key2..]</td>
<td>获取所有(一个或多个)给定 key 的值。</td>
</tr>
<tr>
<td>7</td>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td>8</td>
<td>SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td>
</tr>
<tr>
<td>9</td>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值。</td>
</tr>
<tr>
<td>10</td>
<td>SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
</tr>
<tr>
<td>11</td>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度。</td>
</tr>
<tr>
<td>12</td>
<td>MSET key value [key value …]</td>
<td>同时设置一个或多个 key-value 对。</td>
</tr>
<tr>
<td>13</td>
<td>MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td>
</tr>
<tr>
<td>14</td>
<td>PSETEX key milliseconds value</td>
<td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td>
</tr>
<tr>
<td>15</td>
<td>INCR key</td>
<td>将 key 中储存的数字值增一。</td>
</tr>
<tr>
<td>16</td>
<td>INCRBY key increment</td>
<td>将 key 所储存的值加上给定的增量值（increment） 。</td>
</tr>
<tr>
<td>17</td>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment） 。</td>
</tr>
<tr>
<td>18</td>
<td>DECR key</td>
<td>将 key 中储存的数字值减一。</td>
</tr>
<tr>
<td>19</td>
<td>DECRBY key decrement</td>
<td>key 所储存的值减去给定的减量值（decrement） 。</td>
</tr>
<tr>
<td>20</td>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td>
</tr>
</tbody>
</table>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键值(key=&gt;value)对集合。</p>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>
<p>实例</p>
<pre><code>redis&gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;
&quot;OK&quot;
redis&gt; HGET myhash field1
&quot;Hello&quot;
redis&gt; HGET myhash field2
&quot;World&quot;
</code></pre><p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</p>
<p>每个 hash 可以存储 2<sup>32</sup> -1 键值对（40多亿）。</p>
<p>Redis hash 命令<br>下表列出了 redis hash 基本的相关命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>HDEL key field1 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>2</td>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>3</td>
<td>HGET key field</td>
<td>获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td>4</td>
<td>HGETALL key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>5</td>
<td>HINCRBY key field increment</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>6</td>
<td>HINCRBYFLOAT key field increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>7</td>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>8</td>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>9</td>
<td>HMGET key field1 [field2]</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>10</td>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td>11</td>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td>12</td>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>13</td>
<td>HVALS key</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>14</td>
<td>HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代哈希表中的键值对。</td>
</tr>
</tbody>
</table>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; lpush qixinyue redis
(integer) 1
redis 127.0.0.1:6379&gt; lpush qixinyue mongodb
(integer) 2
redis 127.0.0.1:6379&gt; lpush qixinyue rabitmq
(integer) 3
redis 127.0.0.1:6379&gt; lrange qixinyue 0 10
1) &quot;rabitmq&quot;
2) &quot;mongodb&quot;
3) &quot;redis&quot;
redis 127.0.0.1:6379&gt;
</code></pre><p>列表最多可存储 2<sup>32</sup> - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<p>Redis 列表命令<br>下表列出了列表相关的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>2</td>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>3</td>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>4</td>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>5</td>
<td>LINSERT key BEFORE&#124;AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>6</td>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>7</td>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>8</td>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>9</td>
<td>LPUSHX key value</td>
<td>将一个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>10</td>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>11</td>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>12</td>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>13</td>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>14</td>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>15</td>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>16</td>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>17</td>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<p>sadd 命令<br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p>
<p>sadd key member<br>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; sadd qixinyue redis
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue mongodb
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue rabitmq
(integer) 1
redis 127.0.0.1:6379&gt; sadd qixinyue rabitmq
(integer) 0
redis 127.0.0.1:6379&gt; smembers qixinyue

1) &quot;redis&quot;
2) &quot;rabitmq&quot;
3) &quot;mongodb&quot;
</code></pre><p>注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>
<p>集合中最大的成员数为 2<sup>32</sup> - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<p>Redis 集合命令<br>下表列出了 Redis 集合基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SADD key member1 [member2]</td>
<td>向集合添加一个或多个成员</td>
</tr>
<tr>
<td>2</td>
<td>SCARD key</td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td>SDIFF key1 [key2]</td>
<td>返回给定所有集合的差集</td>
</tr>
<tr>
<td>4</td>
<td>SDIFFSTORE destination key1 [key2]</td>
<td>返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>5</td>
<td>SINTER key1 [key2]</td>
<td>返回给定所有集合的交集</td>
</tr>
<tr>
<td>6</td>
<td>SINTERSTORE destination key1 [key2]</td>
<td>返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>7</td>
<td>SISMEMBER key member</td>
<td>判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>8</td>
<td>SMEMBERS key</td>
<td>返回集合中的所有成员</td>
</tr>
<tr>
<td>9</td>
<td>SMOVE source destination member</td>
<td>将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>10</td>
<td>SPOP key</td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>11</td>
<td>SRANDMEMBER key [count]</td>
<td>返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>12</td>
<td>SREM key member1 [member2]</td>
<td>移除集合中一个或多个成员</td>
</tr>
<tr>
<td>13</td>
<td>SUNION key1 [key2]</td>
<td>返回所有给定集合的并集</td>
</tr>
<tr>
<td>14</td>
<td>SUNIONSTORE destination key1 [key2]</td>
<td>所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>15</td>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代集合中的元素</td>
</tr>
</tbody>
</table>
<h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<p>zadd 命令<br>添加元素到集合，元素在集合中存在则更新对应score</p>
<p>zadd key score member<br>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; zadd qixinyue 0 redis
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 mongodb
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 rabitmq
(integer) 1
redis 127.0.0.1:6379&gt; zadd qixinyue 0 rabitmq
(integer) 0
redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE qixinyue 0 1000
1) &quot;mongodb&quot;
2) &quot;rabitmq&quot;
3) &quot;redis&quot;
</code></pre><p>Redis 有序集合命令<br>下表列出了 redis 有序集合的基本命令:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ZADD key score1 member1 [score2 member2]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>2</td>
<td>ZCARD key</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td>ZCOUNT key min max</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>4</td>
<td>ZINCRBY key increment member</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>5</td>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>6</td>
<td>ZLEXCOUNT key min max</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>7</td>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>8</td>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>9</td>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>10</td>
<td>ZRANK key member</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>11</td>
<td>ZREM key member [member …]</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>12</td>
<td>ZREMRANGEBYLEX key min max</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>13</td>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>14</td>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>15</td>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>16</td>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>17</td>
<td>ZREVRANK key member</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>18</td>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>19</td>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>20</td>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<h1 id="Redis-keys-命令"><a href="#Redis-keys-命令" class="headerlink" title="Redis keys 命令"></a>Redis keys 命令</h1><p>下表给出了与 Redis 键相关的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>DEL key</td>
<td>该命令用于在 key 存在时删除 key。</td>
</tr>
<tr>
<td>2</td>
<td>DUMP key</td>
<td>序列化给定 key ，并返回被序列化的值。</td>
</tr>
<tr>
<td>3</td>
<td>EXISTS key</td>
<td>检查给定 key 是否存在。</td>
</tr>
<tr>
<td>4</td>
<td>EXPIRE key seconds</td>
<td>为给定 key 设置过期时间。</td>
</tr>
<tr>
<td>5</td>
<td>EXPIREAT key timestamp</td>
<td>EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td>6</td>
<td>PEXPIRE key milliseconds</td>
<td>设置 key 的过期时间以毫秒计。</td>
</tr>
<tr>
<td>7</td>
<td>PEXPIREAT key milliseconds-timestamp</td>
<td>设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td>8</td>
<td>KEYS pattern</td>
<td>查找所有符合给定模式( pattern)的 key 。</td>
</tr>
<tr>
<td>9</td>
<td>MOVE key db</td>
<td>将当前数据库的 key 移动到给定的数据库 db 当中。</td>
</tr>
<tr>
<td>10</td>
<td>PERSIST key</td>
<td>移除 key 的过期时间，key 将持久保持。</td>
</tr>
<tr>
<td>11</td>
<td>PTTL key</td>
<td>以毫秒为单位返回 key 的剩余的过期时间。</td>
</tr>
<tr>
<td>12</td>
<td>TTL key</td>
<td>以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td>
</tr>
<tr>
<td>13</td>
<td>RANDOMKEY</td>
<td>从当前数据库中随机返回一个 key 。</td>
</tr>
<tr>
<td>14</td>
<td>RENAME key newkey</td>
<td>修改 key 的名称</td>
</tr>
<tr>
<td>15</td>
<td>RENAMENX key newkey</td>
<td>仅当 newkey 不存在时，将 key 改名为 newkey 。</td>
</tr>
<tr>
<td>16</td>
<td>TYPE key</td>
<td>返回 key 所储存的值的类型。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis HyperLogLog"></a>Redis HyperLogLog</h1><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p>
<p><strong>HyperLogLog作用</strong><br>Redis HyperLogLog 是用来做基数统计的算法</p>
<p><strong>HyperLogLog 的优点</strong><br>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>什么是基数?</strong><br>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。<br>基数估计就是在误差可接受的范围内，快速计算基数。</p>
<p>实例<br>以下实例演示了 HyperLogLog 的工作过程：</p>
<pre><code>redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;redis&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;mongodb&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFADD qixinyuekey &quot;mysql&quot;

1) (integer) 1

redis 127.0.0.1:6379&gt; PFCOUNT qixinyuekey

(integer) 3
</code></pre><p>Redis HyperLogLog 命令<br>下表列出了 redis HyperLogLog 的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PFADD key element [element …]</td>
<td>添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td>2</td>
<td>PFCOUNT key [key …]</td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td>3</td>
<td>PFMERGE destkey sourcekey [sourcekey …]</td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<h1 id="Redis-发布订阅"><a href="#Redis-发布订阅" class="headerlink" title="Redis 发布订阅"></a>Redis 发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系如下：<br>channel1 -&gt;client2<br>channel1 -&gt;client5<br>channel1 -&gt;client1</p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br>channel1（message） -&gt;client2<br>channel1（message） -&gt;client5<br>channel1（message） -&gt;client1</p>
<p>实例<br>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 redisChat:</p>
<pre><code>redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat

Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;redisChat&quot;
3) (integer) 1
</code></pre><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p>
<pre><code>redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Redis is a great caching technique&quot;

(integer) 1

redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;Learn redis by qixinyue.github.io&quot;

(integer) 1

# 订阅者的客户端会显示如下消息
1) &quot;message&quot;
2) &quot;redisChat&quot;
3) &quot;Redis is a great caching technique&quot;
1) &quot;message&quot;
2) &quot;redisChat&quot;
3) &quot;Learn redis by .github.io&quot;
</code></pre><p>Redis 发布订阅命令<br>下表列出了 redis 发布订阅常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PSUBSCRIBE pattern [pattern …]</td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td>2</td>
<td>PUBSUB subcommand [argument [argument …]]</td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td>3</td>
<td>PUBLISH channel message</td>
<td>将信息发送到指定的频道。</td>
</tr>
<tr>
<td>4</td>
<td>PUNSUBSCRIBE [pattern [pattern …]]</td>
<td>退订所有给定模式的频道。</td>
</tr>
<tr>
<td>5</td>
<td>SUBSCRIBE channel [channel …]</td>
<td>订阅给定的一个或多个频道的信息。</td>
</tr>
<tr>
<td>6</td>
<td>UNSUBSCRIBE [channel [channel …]]</td>
<td>指退订给定的频道。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p><strong>一个事务从开始到执行会经历以下三个阶段：</strong></p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<p>实例<br>以下是一个事务的例子， 它先以 MULTI 开始一个事务， 然后将多个命令入队到事务中， 最后由 EXEC 命令触发事务， 一并执行事务中的所有命令：</p>
<pre><code>redis 127.0.0.1:6379&gt; MULTI
OK

redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;
QUEUED

redis 127.0.0.1:6379&gt; GET book-name
QUEUED

redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;
QUEUED

redis 127.0.0.1:6379&gt; SMEMBERS tag
QUEUED

redis 127.0.0.1:6379&gt; EXEC
1) OK
2) &quot;Mastering C++ in 21 days&quot;
3) (integer) 3
4) 1) &quot;Mastering Series&quot;
   2) &quot;C++&quot;
   3) &quot;Programming&quot;
</code></pre><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>
<p>官网上的说明 :</p>
<pre><code>It&apos;s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.
</code></pre><p>比如：</p>
<pre><code>redis 127.0.0.1:7000&gt; multi
OK
redis 127.0.0.1:7000&gt; set a aaa
QUEUED
redis 127.0.0.1:7000&gt; set b bbb
QUEUED
redis 127.0.0.1:7000&gt; set c ccc
QUEUED
redis 127.0.0.1:7000&gt; exec
1) OK
2) OK
3) OK
</code></pre><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p>
<p>Redis 事务命令<br>下表列出了 redis 事务的相关命令：</p>
<p>序号|    命令|描述<br>1    DISCARD 取消事务，放弃执行事务块内的所有命令。<br>2    |EXEC |执行所有事务块内的命令。<br>3    |MULTI |标记一个事务块的开始。<br>4    |UNWATCH |取消 WATCH 命令对所有 key 的监视。<br>5    |WATCH key [key …]| 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p>
<h1 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h1><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>
<p>语法<br>Eval 命令的基本语法如下：</p>
<pre><code>redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]
</code></pre><p>实例<br>以下实例演示了 redis 脚本工作过程：</p>
<pre><code>redis 127.0.0.1:6379&gt; EVAL &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}&quot; 2 key1 key2 first second

1) &quot;key1&quot;
2) &quot;key2&quot;
3) &quot;first&quot;
4) &quot;second&quot;
</code></pre><p><strong>Redis 脚本命令</strong><br>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>EVAL script numkeys key [key …] arg [arg …]</td>
<td>执行 Lua 脚本。</td>
</tr>
<tr>
<td>2</td>
<td>EVALSHA sha1 numkeys key [key …] arg [arg …]</td>
<td>执行 Lua 脚本。</td>
</tr>
<tr>
<td>3</td>
<td>SCRIPT EXISTS script [script …]</td>
<td>查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td>4</td>
<td>SCRIPT FLUSH</td>
<td>从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td>5</td>
<td>SCRIPT KILL</td>
<td>杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td>6</td>
<td>SCRIPT LOAD script</td>
<td>将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody>
</table>
<h1 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis 连接"></a>Redis 连接</h1><p>Redis 连接命令主要是用于连接 redis 服务。</p>
<p>实例<br>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p>
<pre><code>redis 127.0.0.1:6379&gt; AUTH &quot;password&quot;
OK
redis 127.0.0.1:6379&gt; PING
PONG
</code></pre><p><strong>Redis 连接命令</strong><br>下表列出了 redis 连接的基本命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AUTH password</td>
<td>验证密码是否正确</td>
</tr>
<tr>
<td>2</td>
<td>ECHO message</td>
<td>打印字符串</td>
</tr>
<tr>
<td>3</td>
<td>PING</td>
<td>查看服务是否运行</td>
</tr>
<tr>
<td>4</td>
<td>QUIT</td>
<td>关闭当前连接</td>
</tr>
<tr>
<td>5</td>
<td>SELECT index</td>
<td>切换到指定的数据库</td>
</tr>
</tbody>
</table>
<h1 id="Redis服务器"><a href="#Redis服务器" class="headerlink" title="Redis服务器"></a>Redis服务器</h1><p>Redis服务器命令主要是用于管理redis服务。</p>
<p>实例<br>以下实例演示了如何获取redis服务器的统计信息：</p>
<pre><code>redis 127.0.0.1:6379&gt;信息

#Server
redis_version：2.8.13
redis_git_sha1：00000000
redis_git_dirty：0
redis_build_id：c2238b38b1edb0e2
redis_mode：独立
os：Linux 3.5.0-48-generic x86_64
arch_bits：64
multiplexing_api：epoll的
gcc_version：4.7.2
PROCESS_ID：3856
run_id：0e61abd297771de3fe812a3c21027732ac9f41fe
TCP_PORT：6379
uptime_in_seconds：11554
uptime_in_days：0
赫兹：10
lru_clock：16651447
CONFIG_FILE：

＃客户
connected_clients：1
客户longest_output_list：0
客户biggest_input_buf：0
blocked_clients：0

＃记忆
used_memory：589016
used_memory_human：575.21K
used_memory_rss：2461696
used_memory_peak：667312
used_memory_peak_human：651.67K
used_memory_lua：33792
mem_fragmentation_ratio：4.18
mem_allocator：jemalloc-3.6.0

#Persistence
负载：0
rdb_changes_since_last_save：3
rdb_bgsave_in_progress：0
rdb_last_save_time：1409158561
rdb_last_bgsave_status：OK
rdb_last_bgsave_time_sec：0
rdb_current_bgsave_time_sec：-1
aof_enabled：0
aof_rewrite_in_progress：0
aof_rewrite_scheduled：0
aof_last_rewrite_time_sec：-1
aof_current_rewrite_time_sec：-1
aof_last_bgrewrite_status：OK
aof_last_write_status：OK

#Stats
total_connections_received：24
total_commands_processed：294
instantaneous_ops_per_sec：0
rejected_connections：0
sync_full：0
sync_partial_ok：0
sync_partial_err：0
expired_keys：0
evicted_keys：0
keyspace_hits：41
keyspace_misses：82
pubsub_channels：0
pubsub_patterns：0
latest_fork_usec：264

#Replication
作用：主
connected_slaves：0
master_repl_offset：0
repl_backlog_active：0
repl_backlog_size：1048576
repl_backlog_first_byte_offset：0
repl_backlog_histlen：0

＃ 中央处理器
used_cpu_sys：10.49
used_cpu_user：4.96
used_cpu_sys_children：0.00
used_cpu_user_children：0.01

#Keyspace
DB0：键= 94，期满= 1，avg_ttl = 41638810
DB1：键= 1，过期= 0，avg_ttl = 0
DB3：键= 1，过期= 0，avg_ttl = 0
</code></pre><p><strong>Redis服务器命令</strong><br>下表列出了redis服务器的相关命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>BGREWRITEAOF</td>
<td>异步执行一个AOF（AppendOnly File）文件重写操作</td>
</tr>
<tr>
<td>2</td>
<td>BGSAVE</td>
<td>在后台异步保存当前数据库的数据到磁盘</td>
</tr>
<tr>
<td>3</td>
<td>CLIENT KILL [ip：port] [ID client-id]</td>
<td>关闭客户端连接</td>
</tr>
<tr>
<td>4</td>
<td>CLIENT LIST</td>
<td>获取连接到服务器的客户端连接列表</td>
</tr>
<tr>
<td>5</td>
<td>CLIENT GETNAME</td>
<td>获取连接的名称</td>
</tr>
<tr>
<td>6</td>
<td>客户端暂停超时</td>
<td>在指定时间内终止运行来自客户端的命令</td>
</tr>
<tr>
<td>7</td>
<td>CLIENT SETNAME connection-name</td>
<td>设置当前连接的名称</td>
</tr>
<tr>
<td>8</td>
<td>CLUSTER SLOTS</td>
<td>获取集群节点的映射数组</td>
</tr>
<tr>
<td>9</td>
<td>COMMAND</td>
<td>获取Redis命令详情数组</td>
</tr>
<tr>
<td>10</td>
<td>COMMAND COUNT</td>
<td>获取Redis命令总数</td>
</tr>
<tr>
<td>11</td>
<td>COMMAND GETKEYS</td>
<td>获取给定命令的所有键</td>
</tr>
<tr>
<td>12</td>
<td>TIME</td>
<td>返回当前服务器时间</td>
</tr>
<tr>
<td>13</td>
<td>COMMAND INFO command-name [command-name …]</td>
<td>获取指定Redis命令描述的数组</td>
</tr>
<tr>
<td>14</td>
<td>CONFIG GET参数</td>
<td>获取指定配置参数的值</td>
</tr>
<tr>
<td>15</td>
<td>CONFIG REWRITE</td>
<td>对启动Redis服务器时所指定的redis.conf配置文件进行改写</td>
</tr>
<tr>
<td>16</td>
<td>CONFIG SET参数值</td>
<td>修改redis配置参数，无需重启</td>
</tr>
<tr>
<td>17</td>
<td>CONFIG RESETSTAT</td>
<td>重置INFO命令中的某些统计数据</td>
</tr>
<tr>
<td>18</td>
<td>DBSIZE</td>
<td>返回当前数据库的key的数量</td>
</tr>
<tr>
<td>19</td>
<td>DEBUG OBJECT键</td>
<td>获取键的调试信息</td>
</tr>
<tr>
<td>20</td>
<td>DEBUG SEGFAULT</td>
<td>让Redis服务崩溃</td>
</tr>
<tr>
<td>21</td>
<td>FLUSHALL</td>
<td>删除所有数据库的所有关键</td>
</tr>
<tr>
<td>22</td>
<td>FLUSHDB</td>
<td>删除当前数据库的所有关键</td>
</tr>
<tr>
<td>23</td>
<td>INFO [section]</td>
<td>获取Redis服务器的各种信息和统计数值</td>
</tr>
<tr>
<td>24</td>
<td>LASTSAVE</td>
<td>返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示</td>
</tr>
<tr>
<td>25</td>
<td>MONITOR</td>
<td>实时打印出Redis服务器接收到的命令，调试用</td>
</tr>
<tr>
<td>26</td>
<td>ROLE</td>
<td>返回主从实例所属的角色</td>
</tr>
<tr>
<td>27</td>
<td>SAVE</td>
<td>同步保存数据到硬盘</td>
</tr>
<tr>
<td>28</td>
<td>SHUTDOWN [NOSAVE] [SAVE]</td>
<td>异步保存数据到硬盘，并关闭服务器</td>
</tr>
<tr>
<td>29</td>
<td>SLAVEOF主机端口</td>
<td>将当前服务器转变为指定服务器的从属服务器（从服务器）</td>
</tr>
<tr>
<td>30</td>
<td>SLOWLOG子命令[参数]</td>
<td>管理redis的慢日志</td>
</tr>
<tr>
<td>31</td>
<td>SYNC</td>
<td>用于复制功能（复制）的内部命令</td>
</tr>
</tbody>
</table>
<h1 id="Redis-数据备份与恢复"><a href="#Redis-数据备份与恢复" class="headerlink" title="Redis 数据备份与恢复"></a>Redis 数据备份与恢复</h1><h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><p>Redis SAVE 命令用于创建当前数据库的备份。</p>
<p>语法<br>redis Save 命令基本语法如下：</p>
<pre><code>redis 127.0.0.1:6379&gt; SAVE 
</code></pre><p>实例</p>
<pre><code>redis 127.0.0.1:6379&gt; SAVE 
OK
</code></pre><p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h2 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h2><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：</p>
<pre><code>redis 127.0.0.1:6379&gt; CONFIG GET dir
1) &quot;dir&quot;
2) &quot;/usr/local/redis/bin&quot;
</code></pre><p>以上命令 CONFIG GET dir 输出的 redis 安装目录为 /usr/local/redis/bin。</p>
<p>Bgsave<br>创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</p>
<p>实例</p>
<pre><code>127.0.0.1:6379&gt; BGSAVE

Background saving started
</code></pre><h1 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h1><p>我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</p>
<p>实例<br>我们可以通过以下命令查看是否设置了密码验证：</p>
<pre><code>127.0.0.1:6379&gt; CONFIG get requirepass
1) &quot;requirepass&quot;
2) &quot;&quot;
</code></pre><p>默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</p>
<p>你可以通过以下命令来修改该参数：</p>
<p>127.0.0.1:6379&gt; CONFIG set requirepass “qixinyue”<br>OK<br>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “qixinyue”</p>
<p>设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。</p>
<p>语法<br>AUTH 命令基本语法格式如下：</p>
<pre><code>127.0.0.1:6379&gt; AUTH password
</code></pre><p>实例</p>
<pre><code>127.0.0.1:6379&gt; AUTH &quot;qixinyue&quot;
OK
127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;
OK
127.0.0.1:6379&gt; GET mykey
&quot;Test value&quot;
</code></pre><h1 id="Redis-性能测试"><a href="#Redis-性能测试" class="headerlink" title="Redis 性能测试"></a>Redis 性能测试</h1><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<p>语法<br>redis 性能测试的基本命令如下：</p>
<pre><code>redis-benchmark [option] [option value]
</code></pre><p>实例<br>以下实例同时执行 10000 个请求来检测性能：</p>
<pre><code>$ redis-benchmark -n 10000  -q

PING_INLINE: 141043.72 requests per second
PING_BULK: 142857.14 requests per second
SET: 141442.72 requests per second
GET: 145348.83 requests per second
INCR: 137362.64 requests per second
LPUSH: 145348.83 requests per second
LPOP: 146198.83 requests per second
SADD: 146198.83 requests per second
SPOP: 149253.73 requests per second
LPUSH (needed to benchmark LRANGE): 148588.42 requests per second
LRANGE_100 (first 100 elements): 58411.21 requests per second
LRANGE_300 (first 300 elements): 21195.42 requests per second
LRANGE_500 (first 450 elements): 14539.11 requests per second
LRANGE_600 (first 600 elements): 10504.20 requests per second
MSET (10 keys): 93283.58 requests per second
</code></pre><p>redis 性能测试工具可选参数如下所示：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>-h</td>
<td>指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>2</td>
<td>-p</td>
<td>指定服务器端口</td>
<td>6379</td>
</tr>
<tr>
<td>3</td>
<td>-s</td>
<td>指定服务器 socket</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>-c</td>
<td>指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>-n</td>
<td>指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td>6</td>
<td>-d</td>
<td>以字节的形式指定 SET/GET 值的数据大小</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>-k</td>
<td>1=keep alive 0=reconnect</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>-r</td>
<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>-P</td>
<td>通过管道传输 <numreq> 请求</numreq></td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>-q</td>
<td>强制退出 redis。仅显示 query/sec 值</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>–csv</td>
<td>以 CSV 格式输出</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>-l</td>
<td>生成循环，永久执行测试</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>-t</td>
<td>仅运行以逗号分隔的测试命令列表。</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>-I(大写的i)</td>
<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td></td>
</tr>
</tbody>
</table>
<p>实例<br>以下实例我们使用了多个参数来测试 redis 性能：</p>
<pre><code>$ redis-benchmark -h 127.0.0.1 -p 6379 -t set,lpush -n 10000 -q

SET: 146198.83 requests per second
LPUSH: 145560.41 requests per second
</code></pre><p>以上实例中主机为 127.0.0.1，端口号为 6379，执行的命令为 set,lpush，请求数为 10000，通过 -q 参数让结果只显示每秒执行的请求数。</p>
<h1 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis 客户端连接"></a>Redis 客户端连接</h1><p>Redis 通过监听一个 TCP 端口或者 Unix socket 的方式来接收来自客户端的连接，当一个连接建立后，Redis 内部会进行以下一些操作：</p>
<p>首先，客户端 socket 会被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型。<br>然后为这个 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法<br>然后创建一个可读的文件事件用于监听这个客户端 socket 的数据发送<br>最大连接数<br>在 Redis2.4 中，最大连接数是被直接硬编码在代码里面的，而在2.6版本中这个值变成可配置的。</p>
<p>maxclients 的默认值是 10000，你也可以在 redis.conf 中对这个值进行修改。</p>
<pre><code>config get maxclients

1) &quot;maxclients&quot;
2) &quot;10000&quot;
</code></pre><p>实例<br>以下实例我们在服务启动时设置最大连接数为 100000：</p>
<pre><code>redis-server --maxclients 100000
</code></pre><p>客户端命令<br>S.N.    |命令|    描述<br>–|–|–<br>1    |CLIENT LIST    |返回连接到 redis 服务的客户端列表<br>2    |CLIENT SETNAME|    设置当前连接的名称<br>3    |CLIENT GETNAME    |获取通过 CLIENT SETNAME 命令设置的服务名称<br>4    |CLIENT PAUSE    |挂起客户端连接，指定挂起的时间以毫秒计<br>5    |CLIENT KILL    |关闭客户端连接</p>
<h1 id="Redis管道技术"><a href="#Redis管道技术" class="headerlink" title="Redis管道技术"></a>Redis管道技术</h1><p>Redis的是一种基于客户端 - 服务端模型以及请求/响应协议的TCP服务这意味着通常情况下一个请求会遵循以下步骤：</p>
<ul>
<li>客户端向服务端发送一个查询请求，并监听套接字返回，通常是以阻塞模式，等待服务端响应。</li>
<li>服务端处理命令，并将结果返回给客户端。</li>
</ul>
<h2 id="Redis管道技术-1"><a href="#Redis管道技术-1" class="headerlink" title="Redis管道技术"></a>Redis管道技术</h2><p>Redis管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。</p>
<p>实例<br>查看redis管道，只需要启动redis实例并输入以下命令：</p>
<pre><code>$（echo -en“PING \ r \ n \ nSET qixinyuekey redis \ r \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \ n \访问者\ r \ n \ n \ nIN访问者\ r \ nINCR访问者\ r \ n”;“睡眠10”| nc localhost 6379

+ PONG
+ OK
Redis的
：1
：2
：3
</code></pre><p>以上实例中我们通过使用PING命令查看redis服务是否可用，之后我们设置了qixinyuekey的值为redis，然后我们获取qixinyuekey的值并使得访客自增3次。</p>
<p>在返回的结果中我们可以看到这些命令一次性向redis服务提交，并最终一次性读取所有服务端的响应</p>
<h2 id="管道技术的优势"><a href="#管道技术的优势" class="headerlink" title="管道技术的优势"></a>管道技术的优势</h2><p>管道技术最显着的优势是提高了redis服务的性能。</p>
<p>一些测试数据<br>在下面的测试中，我们将使用Redis的的红宝石客户端，支持管道技术特性，测试管道技术对速度的提升效果。</p>
<pre><code>需要&apos;rubygems&apos; 
要求&apos;redis&apos;
def bench（descr） 
start = Time.now 
产量 
把“＃{descr}＃{Time.now-start}秒” 
结束
def without_pipelining 
r = Redis.new 
10000.times { 
    r.ping 
} 
结束
def with_pipelining 
r = Redis.new 
r.pipelined { 
    10000.times { 
        r.ping 
    } 
} 
结束
工作台（“没有流水线”）{ 
    without_pipelining 
} 
工作台（“与流水线”）{ 
    with_pipelining 
}
</code></pre><p>从处于局域网中的Mac OS X系统上执行上面这个简单脚本的数据表明，开启了管道操作后，往返时延已经被改善得相当低了。</p>
<pre><code>没有流水线1.185238秒 
使用流水线0.250783秒
</code></pre><p>如你所见，开启管道后，我们的速度效率提升了4.7倍。</p>
<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis 分区"></a>Redis 分区</h1><p>分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h2 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h2><ul>
<li>通过利用多台计算机内存的和值，允许我们构造更大的数据库。</li>
<li>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。</li>
</ul>
<h2 id="分区的不足"><a href="#分区的不足" class="headerlink" title="分区的不足"></a>分区的不足</h2><p>redis的一些特性在分区方面表现的不是很好：</p>
<ul>
<li>涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。</li>
<li>涉及多个key的redis事务不能使用。</li>
<li>当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。</li>
<li>增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。</li>
</ul>
<h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><p>Redis 有两种类型分区。 假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。</p>
<h2 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h2><p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。</p>
<p>比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。</p>
<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。</p>
<h2 id="哈希分区"><a href="#哈希分区" class="headerlink" title="哈希分区"></a>哈希分区</h2><p>另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：</p>
<ul>
<li>用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。</li>
<li>对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。</li>
</ul>
<h1 id="Python操作redis"><a href="#Python操作redis" class="headerlink" title="Python操作redis"></a>Python操作redis</h1><h2 id="1、String-操作"><a href="#1、String-操作" class="headerlink" title="1、String 操作"></a>1、String 操作</h2><p>　　redis中的String在在内存中按照一个name对应一个value来存储</p>
<p>set()</p>
<pre><code>#在Redis中设置值，默认不存在则创建，存在则修改
r.set(&apos;name&apos;, &apos;zhangsan&apos;)
&apos;&apos;&apos;参数：
     set(name, value, ex=None, px=None, nx=False, xx=False)
     ex，过期时间（秒）
     px，过期时间（毫秒）
     nx，如果设置为True，则只有name不存在时，当前set操作才执行,同setnx(name, value)
     xx，如果设置为True，则只有name存在时，当前set操作才执行&apos;&apos;&apos;


setex(name, value, time)
#设置过期时间（秒）

psetex(name, time_ms, value)
#设置过期时间（豪秒）
</code></pre><p>mset()</p>
<pre><code>#批量设置值
r.mset(name1=&apos;zhangsan&apos;, name2=&apos;lisi&apos;)
#或
r.mget({&quot;name1&quot;:&apos;zhangsan&apos;, &quot;name2&quot;:&apos;lisi&apos;})
</code></pre><p>get(name)</p>
<p>　　获取值</p>
<p>mget(keys, *args)</p>
<pre><code>#批量获取
print(r.mget(&quot;name1&quot;,&quot;name2&quot;))
#或
li=[&quot;name1&quot;,&quot;name2&quot;]
print(r.mget(li))
</code></pre><p>getset(name, value)</p>
<pre><code>#设置新值，打印原值
print(r.getset(&quot;name1&quot;,&quot;wangwu&quot;)) #输出:zhangsan
print(r.get(&quot;name1&quot;)) #输出:wangwu
</code></pre><p>getrange(key, start, end)</p>
<pre><code>#根据字节获取子序列
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.getrange(&quot;name&quot;,0,3))#输出:zhan
</code></pre><p>setrange(name, offset, value)</p>
<pre><code>#修改字符串内容，从指定字符串索引开始向后替换，如果新值太长时，则向后添加
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
r.setrange(&quot;name&quot;,1,&quot;z&quot;)
print(r.get(&quot;name&quot;)) #输出:zzangsan
r.setrange(&quot;name&quot;,6,&quot;zzzzzzz&quot;)
print(r.get(&quot;name&quot;)) #输出:zzangszzzzzzz
</code></pre><p>setbit(name, offset, value)</p>
<pre><code>#对二进制表示位进行操作
&apos;&apos;&apos; name:redis的name
    offset，位的索引（将值对应的ASCII码变换成二进制后再进行索引）
    value，值只能是 1 或 0 &apos;&apos;&apos;

str=&quot;345&quot;
r.set(&quot;name&quot;,str)
for i in str:
    print(i,ord(i),bin(ord(i)))#输出 值、ASCII码中对应的值、对应值转换的二进制
&apos;&apos;&apos;
输出:
    3 51 0b110011
    4 52 0b110100
    5 53 0b110101&apos;&apos;&apos;

r.setbit(&quot;name&quot;,6,0)#把第7位改为0，也就是3对应的变成了0b110001
print(r.get(&quot;name&quot;))#输出：145
</code></pre><p>getbit(name, offset)</p>
<pre><code>#获取name对应值的二进制中某位的值(0或1)
r.set(&quot;name&quot;,&quot;3&quot;) # 对应的二进制0b110011
print(r.getbit(&quot;name&quot;,5))   #输出:0
print(r.getbit(&quot;name&quot;,6))   #输出:1
</code></pre><p>bitcount(key, start=None, end=None)</p>
<pre><code>#获取对应二进制中1的个数
r.set(&quot;name&quot;,&quot;345&quot;)#0b110011 0b110100 0b110101
print(r.bitcount(&quot;name&quot;,start=0,end=1)) #输出:7
&apos;&apos;&apos; key:Redis的name
    start:字节起始位置
    end:字节结束位置&apos;&apos;&apos;
</code></pre><p>strlen(name)</p>
<pre><code>#返回name对应值的字节长度（一个汉字3个字节）
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.strlen(&quot;name&quot;)) #输出:8
</code></pre><p>incr(self, name, amount=1)</p>
<pre><code>#自增mount对应的值，当mount不存在时，则创建mount＝amount，否则，则自增,amount为自增数(整数)
print(r.incr(&quot;mount&quot;,amount=2))#输出:2
print(r.incr(&quot;mount&quot;))#输出:3
print(r.incr(&quot;mount&quot;,amount=3))#输出:6
print(r.incr(&quot;mount&quot;,amount=6))#输出:12
print(r.get(&quot;mount&quot;)) #输出:12
</code></pre><p>incrbyfloat(self, name, amount=1.0)</p>
<pre><code>#类似 incr() 自增,amount为自增数(浮点数)
</code></pre><p>decr(self, name, amount=1)</p>
<pre><code>#自减name对应的值,当name不存在时,则创建name＝amount，否则，则自减，amount为自增数(整数)
</code></pre><p>append(name, value)</p>
<pre><code>#在name对应的值后面追加内容
r.set(&quot;name&quot;,&quot;zhangsan&quot;)
print(r.get(&quot;name&quot;))    #输出:&apos;zhangsan
r.append(&quot;name&quot;,&quot;lisi&quot;)
print(r.get(&quot;name&quot;))    #输出:zhangsanlisi
</code></pre><h2 id="2、Hash-操作"><a href="#2、Hash-操作" class="headerlink" title="2、Hash 操作"></a>2、Hash 操作</h2><p>redis中的Hash 在内存中类似于一个name对应一个dic来存储 </p>
<p> hset(name, key, value)</p>
<pre><code>#name对应的hash中设置一个键值对（不存在，则创建，否则，修改）
r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
</code></pre><p>hget(name,key)</p>
<pre><code>r.hset(&quot;dic_name&quot;,&quot;a1&quot;,&quot;aa&quot;)
#在name对应的hash中根据key获取value
print(r.hget(&quot;dic_name&quot;,&quot;a1&quot;))#输出:aa
</code></pre><p>hgetall(name)</p>
<p>#获取name对应hash的所有键值<br>print(r.hgetall(“dic_name”))<br>hmset(name, mapping)</p>
<p>#在name对应的hash中批量设置键值对,mapping:字典<br>dic={“a1”:”aa”,”b1”:”bb”}<br>r.hmset(“dic_name”,dic)<br>print(r.hget(“dic_name”,”b1”))#输出:bb<br>hmget(name, keys, *args)</p>
<h1 id="在name对应的hash中获取多个key的值"><a href="#在name对应的hash中获取多个key的值" class="headerlink" title="在name对应的hash中获取多个key的值"></a>在name对应的hash中获取多个key的值</h1><p>li=[“a1”,”b1”]<br>print(r.hmget(“dic_name”,li))<br>print(r.hmget(“dic_name”,”a1”,”b1”))<br>hlen(name)、hkeys(name)、hvals(name)</p>
<p>复制代码<br>dic={“a1”:”aa”,”b1”:”bb”}<br>r.hmset(“dic_name”,dic)</p>
<p>#hlen(name) 获取hash中键值对的个数<br>print(r.hlen(“dic_name”))</p>
<p>#hkeys(name) 获取hash中所有的key的值<br>print(r.hkeys(“dic_name”))</p>
<p>#hvals(name) 获取hash中所有的value的值<br>print(r.hvals(“dic_name”))<br>复制代码<br>hexists(name, key)</p>
<p>#检查name对应的hash是否存在当前传入的key<br>print(r.hexists(“dic_name”,”a1”))#输出:True<br>hdel(name,*keys)</p>
<p>#删除指定name对应的key所在的键值对<br>r.hdel(“dic_name”,”a1”)<br>hincrby(name, key, amount=1)</p>
<p>#自增hash中key对应的值，不存在则创建key=amount(amount为整数)<br>print(r.hincrby(“demo”,”a”,amount=2))<br>hincrbyfloat(name, key, amount=1.0)</p>
<p>#自增hash中key对应的值，不存在则创建key=amount(amount为浮点数)</p>
<p>hscan(name, cursor=0, match=None, count=None)</p>
<p>hscan_iter(name, match=None, count=None)</p>
<p>3、List 操作</p>
<p>redis中的List在在内存中按照一个name对应一个List来存储 </p>
<p>lpush(name,values)</p>
<h1 id="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"><a href="#在name对应的list中添加元素，每个新的元素都添加到列表的最左边" class="headerlink" title="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"></a>在name对应的list中添加元素，每个新的元素都添加到列表的最左边</h1><p>r.lpush(“list_name”,2)<br>r.lpush(“list_name”,3,4,5)#保存在列表中的顺序为5，4，3，2<br>rpush(name,values)</p>
<p>#同lpush，但每个新的元素都添加到列表的最右边<br>lpushx(name,value)</p>
<p>#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边<br>rpushx(name,value)</p>
<p>#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最右边<br>llen(name)</p>
<h1 id="name对应的list元素的个数"><a href="#name对应的list元素的个数" class="headerlink" title="name对应的list元素的个数"></a>name对应的list元素的个数</h1><p>print(r.llen(“list_name”))<br>linsert(name, where, refvalue, value))</p>
<p>复制代码</p>
<h1 id="在name对应的列表的某一个值前或后插入一个新值"><a href="#在name对应的列表的某一个值前或后插入一个新值" class="headerlink" title="在name对应的列表的某一个值前或后插入一个新值"></a>在name对应的列表的某一个值前或后插入一个新值</h1><p>r.linsert(“list_name”,”BEFORE”,”2”,”SS”)#在列表内找到第一个元素2，在它前面插入SS</p>
<p>‘’’参数：<br>     name: redis的name<br>     where: BEFORE（前）或AFTER（后）<br>     refvalue: 列表内的值<br>     value: 要插入的数据’’’<br>复制代码<br>r.lset(name, index, value)</p>
<p>#对list中的某一个索引位置重新赋值<br>r.lset(“list_name”,0,”bbb”)<br>r.lrem(name, value, num)</p>
<p>复制代码</p>
<p>#删除name对应的list中的指定值<br>r.lrem(“list_name”,”SS”,num=0)</p>
<p>‘’’ 参数：<br>    name:  redis的name<br>    value: 要删除的值<br>    num:   num=0 删除列表中所有的指定值；<br>           num=2 从前到后，删除2个；<br>           num=-2 从后向前，删除2个’’’<br>复制代码<br>lpop(name)</p>
<p>#移除列表的左侧第一个元素，返回值则是第一个元素<br>print(r.lpop(“list_name”))<br>lindex(name, index)</p>
<p>#根据索引获取列表内元素<br>print(r.lindex(“list_name”,1))<br>lrange(name, start, end)</p>
<p>#分片获取元素<br>print(r.lrange(“list_name”,0,-1))<br>ltrim(name, start, end)</p>
<p>#移除列表内没有在该索引之内的值<br>r.ltrim(“list_name”,0,2)<br>rpoplpush(src, dst)</p>
<h1 id="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"><a href="#从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边" class="headerlink" title="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"></a>从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</h1><p>#src 要取数据的列表</p>
<p>#dst 要添加数据的列表<br>brpoplpush(src, dst, timeout=0)</p>
<p>#同rpoplpush，多了个timeout, timeout：取数据的列表没元素后的阻塞时间，0为一直阻塞<br>r.brpoplpush(“list_name”,”list_name1”,timeout=0)<br>blpop(keys, timeout)</p>
<p>复制代码</p>
<p>#将多个列表排列,按照从左到右去移除各个列表内的元素<br>r.lpush(“list_name”,3,4,5)<br>r.lpush(“list_name1”,3,4,5)</p>
<p>while True:<br>    print(r.blpop([“list_name”,”list_name1”],timeout=0))<br>    print(r.lrange(“list_name”,0,-1),r.lrange(“list_name1”,0,-1))</p>
<p>‘’’keys: redis的name的集合<br>   timeout: 超时时间，获取完所有列表的元素之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞’’’<br>复制代码<br>r.brpop(keys, timeout)</p>
<p>#同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素</p>
<p>4、Set 操作</p>
<p>Set集合就是不允许重复的列表</p>
<p>sadd(name,values)</p>
<p>#给name对应的集合中添加元素<br>r.sadd(“set_name”,”aa”)<br>r.sadd(“set_name”,”aa”,”bb”)<br>smembers(name)</p>
<p>#获取name对应的集合的所有成员<br>scard(name)</p>
<p>#获取name对应的集合中的元素个数<br>r.scard(“set_name”)<br>sdiff(keys, *args)</p>
<p>#在第一个name对应的集合中且不在其他name对应的集合的元素集合<br>r.sadd(“set_name”,”aa”,”bb”)<br>r.sadd(“set_name1”,”bb”,”cc”)<br>r.sadd(“set_name2”,”bb”,”cc”,”dd”)</p>
<p>print(r.sdiff(“set_name”,”set_name1”,”set_name2”))#输出:｛aa｝<br>sdiffstore(dest, keys, *args)</p>
<p>#相当于把sdiff获取的值加入到dest对应的集合中<br>sinter(keys, *args)</p>
<h1 id="获取多个name对应集合的并集"><a href="#获取多个name对应集合的并集" class="headerlink" title="获取多个name对应集合的并集"></a>获取多个name对应集合的并集</h1><p>r.sadd(“set_name”,”aa”,”bb”)<br>r.sadd(“set_name1”,”bb”,”cc”)<br>r.sadd(“set_name2”,”bb”,”cc”,”dd”)</p>
<p>print(r.sinter(“set_name”,”set_name1”,”set_name2”))#输出:｛bb｝<br>sinterstore(dest, keys, *args)</p>
<p>#获取多个name对应集合的并集，再讲其加入到dest对应的集合中<br>sismember(name, value)</p>
<p>#检查value是否是name对应的集合内的元素<br>smove(src, dst, value)</p>
<p>#将某个元素从一个集合中移动到另外一个集合<br>spop(name)</p>
<p>#从集合的右侧移除一个元素，并将其返回<br>srandmember(name, numbers)</p>
<h1 id="从name对应的集合中随机获取numbers个元素"><a href="#从name对应的集合中随机获取numbers个元素" class="headerlink" title="从name对应的集合中随机获取numbers个元素"></a>从name对应的集合中随机获取numbers个元素</h1><p>print(r.srandmember(“set_name2”,2))<br>srem(name, values)</p>
<p>#删除name对应的集合中的某些值<br>print(r.srem(“set_name2”,”bb”,”dd”))<br>sunion(keys, *args)</p>
<p>#获取多个name对应的集合的并集<br>r.sunion(“set_name”,”set_name1”,”set_name2”)<br>sunionstore(dest,keys, *args)</p>
<p>#获取多个name对应的集合的并集，并将结果保存到dest对应的集合中<br>有序集合：</p>
<p>　　在集合的基础上，为每元素排序，元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</p>
<p>zadd(name, *args, **kwargs)</p>
<h1 id="在name对应的有序集合中添加元素"><a href="#在name对应的有序集合中添加元素" class="headerlink" title="在name对应的有序集合中添加元素"></a>在name对应的有序集合中添加元素</h1><p>r.zadd(“zset_name”, “a1”, 6, “a2”, 2,”a3”,5)</p>
<p>#或<br>r.zadd(‘zset_name1’, b1=10, b2=5)<br>zcard(name)</p>
<p>#获取有序集合内元素的数量<br>zcount(name, min, max)</p>
<p>#获取有序集合中分数在[min,max]之间的个数<br>print(r.zcount(“zset_name”,1,5))<br>zincrby(name, value, amount)</p>
<p>#自增有序集合内value对应的分数<br>r.zincrby(“zset_name”,”a1”,amount=2)#自增zset_name对应的有序集合里a1对应的分数<br>zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)</p>
<p>复制代码</p>
<h1 id="按照索引范围获取name对应的有序集合的元素"><a href="#按照索引范围获取name对应的有序集合的元素" class="headerlink" title="按照索引范围获取name对应的有序集合的元素"></a>按照索引范围获取name对应的有序集合的元素</h1><p>aa=r.zrange(“zset_name”,0,1,desc=False,withscores=True,score_cast_func=int)<br>print(aa)<br>‘’’参数：<br>    name    redis的name<br>    start   有序集合索引起始位置<br>    end     有序集合索引结束位置<br>    desc    排序规则，默认按照分数从小到大排序<br>    withscores  是否获取元素的分数，默认只获取元素的值<br>    score_cast_func 对分数进行数据转换的函数’’’<br>复制代码<br>zrevrange(name, start, end, withscores=False, score_cast_func=float)</p>
<p>#同zrange，集合是从大到小排序的<br>zrank(name, value)、zrevrank(name, value)</p>
<p>#获取value值在name对应的有序集合中的排行位置（从0开始）<br>print(r.zrank(“zset_name”, “a2”))</p>
<p>print(r.zrevrank(“zset_name”, “a2”))#从大到小排序<br>zscore(name, value)</p>
<p>#获取name对应有序集合中 value 对应的分数<br>print(r.zscore(“zset_name”,”a1”))<br>zrem(name, values)</p>
<p>#删除name对应的有序集合中值是values的成员<br>r.zrem(“zset_name”,”a1”,”a2”)<br>zremrangebyrank(name, min, max)</p>
<p>#根据排行范围删除<br>zremrangebyscore(name, min, max)</p>
<p>#根据分数范围删除<br>zinterstore(dest, keys, aggregate=None)</p>
<p>复制代码<br>r.zadd(“zset_name”, “a1”, 6, “a2”, 2,”a3”,5)<br>r.zadd(‘zset_name1’, a1=7,b1=10, b2=5)</p>
<h1 id="获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作"><a href="#获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作" class="headerlink" title="获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作"></a>获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作</h1><h1 id="aggregate的值为-SUM-MIN-MAX"><a href="#aggregate的值为-SUM-MIN-MAX" class="headerlink" title="aggregate的值为: SUM  MIN  MAX"></a>aggregate的值为: SUM  MIN  MAX</h1><p>r.zinterstore(“zset_name2”,(“zset_name1”,”zset_name”),aggregate=”MAX”)<br>print(r.zscan(“zset_name2”))<br>复制代码<br>zunionstore(dest, keys, aggregate=None)</p>
<p>#获取两个有序集合的并集并放入dest集合，其他同zinterstore，<br>其他常用操作</p>
<p>delete(*names)</p>
<p>#根据name删除redis中的任意数据类型<br>exists(name)</p>
<p>#检测redis的name是否存在<br>keys(pattern=’*’)</p>
<p>#根据* ？等通配符匹配获取redis的name<br>expire(name ,time)</p>
<h1 id="为某个name设置超时时间"><a href="#为某个name设置超时时间" class="headerlink" title="为某个name设置超时时间"></a>为某个name设置超时时间</h1><p>rename(src, dst)</p>
<h1 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h1><p>move(name, db))</p>
<h1 id="将redis的某个值移动到指定的db下"><a href="#将redis的某个值移动到指定的db下" class="headerlink" title="将redis的某个值移动到指定的db下"></a>将redis的某个值移动到指定的db下</h1><p>randomkey()</p>
<p>#随机获取一个redis的name（不删除）<br>type(name)</p>
<h1 id="获取name对应值的类型"><a href="#获取name对应值的类型" class="headerlink" title="获取name对应值的类型"></a>获取name对应值的类型</h1>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/18/Django论坛搭建完整版/" rel="next" title="Django论坛搭建完整版">
                <i class="fa fa-chevron-left"></i> Django论坛搭建完整版
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js'];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  






        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Godshion</p>
              <p class="site-description motion-element" itemprop="description">本站主要提供python教学的系列知识汇总</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                主页
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.csdn.net/weixin_41661393" title="csdn_blog" target="_blank">csdn_blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#redis介绍"><span class="nav-number">1.</span> <span class="nav-text">redis介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis特点"><span class="nav-number">1.1.</span> <span class="nav-text">Redis特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis优势"><span class="nav-number">1.2.</span> <span class="nav-text">Redis优势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis环境配置"><span class="nav-number">2.</span> <span class="nav-text">Redis环境配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#windows下安装"><span class="nav-number">2.1.</span> <span class="nav-text">windows下安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux下安装"><span class="nav-number">2.2.</span> <span class="nav-text">linux下安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mac-下安装-（没有试过，手上没有这个系统的机器）"><span class="nav-number">2.3.</span> <span class="nav-text">Mac 下安装 （没有试过，手上没有这个系统的机器）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis配置"><span class="nav-number">3.</span> <span class="nav-text">Redis配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参数说明"><span class="nav-number">3.1.</span> <span class="nav-text">参数说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-数据类型"><span class="nav-number">4.</span> <span class="nav-text">Redis 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String（字符串）"><span class="nav-number">4.1.</span> <span class="nav-text">String（字符串）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash（哈希）"><span class="nav-number">4.2.</span> <span class="nav-text">Hash（哈希）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List（列表）"><span class="nav-number">4.3.</span> <span class="nav-text">List（列表）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set（集合）"><span class="nav-number">4.4.</span> <span class="nav-text">Set（集合）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zset-sorted-set：有序集合"><span class="nav-number">4.5.</span> <span class="nav-text">zset(sorted set：有序集合)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-keys-命令"><span class="nav-number">5.</span> <span class="nav-text">Redis keys 命令</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-HyperLogLog"><span class="nav-number">6.</span> <span class="nav-text">Redis HyperLogLog</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-发布订阅"><span class="nav-number">7.</span> <span class="nav-text">Redis 发布订阅</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-事务"><span class="nav-number">8.</span> <span class="nav-text">Redis 事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-脚本"><span class="nav-number">9.</span> <span class="nav-text">Redis 脚本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-连接"><span class="nav-number">10.</span> <span class="nav-text">Redis 连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis服务器"><span class="nav-number">11.</span> <span class="nav-text">Redis服务器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-数据备份与恢复"><span class="nav-number">12.</span> <span class="nav-text">Redis 数据备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#备份数据"><span class="nav-number">12.1.</span> <span class="nav-text">备份数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#恢复数据"><span class="nav-number">12.2.</span> <span class="nav-text">恢复数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-安全"><span class="nav-number">13.</span> <span class="nav-text">Redis 安全</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-性能测试"><span class="nav-number">14.</span> <span class="nav-text">Redis 性能测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-客户端连接"><span class="nav-number">15.</span> <span class="nav-text">Redis 客户端连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis管道技术"><span class="nav-number">16.</span> <span class="nav-text">Redis管道技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis管道技术-1"><span class="nav-number">16.1.</span> <span class="nav-text">Redis管道技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道技术的优势"><span class="nav-number">16.2.</span> <span class="nav-text">管道技术的优势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-分区"><span class="nav-number">17.</span> <span class="nav-text">Redis 分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分区的优势"><span class="nav-number">17.1.</span> <span class="nav-text">分区的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区的不足"><span class="nav-number">17.2.</span> <span class="nav-text">分区的不足</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区类型"><span class="nav-number">17.3.</span> <span class="nav-text">分区类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#范围分区"><span class="nav-number">17.4.</span> <span class="nav-text">范围分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希分区"><span class="nav-number">17.5.</span> <span class="nav-text">哈希分区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python操作redis"><span class="nav-number">18.</span> <span class="nav-text">Python操作redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、String-操作"><span class="nav-number">18.1.</span> <span class="nav-text">1、String 操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、Hash-操作"><span class="nav-number">18.2.</span> <span class="nav-text">2、Hash 操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在name对应的hash中获取多个key的值"><span class="nav-number">19.</span> <span class="nav-text">在name对应的hash中获取多个key的值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在name对应的list中添加元素，每个新的元素都添加到列表的最左边"><span class="nav-number">20.</span> <span class="nav-text">在name对应的list中添加元素，每个新的元素都添加到列表的最左边</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#name对应的list元素的个数"><span class="nav-number">21.</span> <span class="nav-text">name对应的list元素的个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在name对应的列表的某一个值前或后插入一个新值"><span class="nav-number">22.</span> <span class="nav-text">在name对应的列表的某一个值前或后插入一个新值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"><span class="nav-number">23.</span> <span class="nav-text">从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取多个name对应集合的并集"><span class="nav-number">24.</span> <span class="nav-text">获取多个name对应集合的并集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从name对应的集合中随机获取numbers个元素"><span class="nav-number">25.</span> <span class="nav-text">从name对应的集合中随机获取numbers个元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在name对应的有序集合中添加元素"><span class="nav-number">26.</span> <span class="nav-text">在name对应的有序集合中添加元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#按照索引范围获取name对应的有序集合的元素"><span class="nav-number">27.</span> <span class="nav-text">按照索引范围获取name对应的有序集合的元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作"><span class="nav-number">28.</span> <span class="nav-text">获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#aggregate的值为-SUM-MIN-MAX"><span class="nav-number">29.</span> <span class="nav-text">aggregate的值为: SUM  MIN  MAX</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为某个name设置超时时间"><span class="nav-number">30.</span> <span class="nav-text">为某个name设置超时时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重命名"><span class="nav-number">31.</span> <span class="nav-text">重命名</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将redis的某个值移动到指定的db下"><span class="nav-number">32.</span> <span class="nav-text">将redis的某个值移动到指定的db下</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取name对应值的类型"><span class="nav-number">33.</span> <span class="nav-text">获取name对应值的类型</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Godshion</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">112.1k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  






	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
